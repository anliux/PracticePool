//50 - 第一个只出现一次的字符位置
//思路：暴力法；哈希表法。
//哈希表优化时间复杂度；用数组实现哈希表。




//哈希表法：7ms，击败83.42%的用户
/*
  - 算法：
      - 定义数组；
      - 第一次遍历字符串：将字母转为int型，并减去65，作为key值，即索引值；或者直接获取字符并减去A(A==65)；
      - 第二次遍历字符串：如果对应值是1则返回对应的字符；（注意：是遍历字符串，不是遍历数组）
      - 如果循环结束后没有符合条件的，则返回空串（注意空串：单引号中间需要打空格）。
      - 注意返回值类型：char型，因此注意用单引号，特别是空串。
      - 注：不用判空，空串的情况包含在循环判断中了，只是开辟数组空间有点浪费。
*/
class Solution {
    public char firstUniqChar(String s) {
        //定义数组
        int[] words = new int[58];

        //第一次遍历：计数
        for(int i = 0; i < s.length(); i++){
            words[s.charAt(i) - 'A'] += 1;
        }

        //第二次遍历：遍历字符串，寻找对应数组值等于1的字符
        for(int i = 0; i <s.length(); i++){
            if(words[s.charAt(i) - 'A'] == 1)
                return s.charAt(i);
        }

        //找不到时，返回空串，单引号
        return ' ';
    }
}
