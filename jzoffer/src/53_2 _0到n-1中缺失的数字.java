//53.2 - 0到n-1中缺失的数字
//思路：暴力法；排序想到二分。
//关键：找到数组与索引值的对应关系，并将数组分为索引值相等和索引值不等两部分，然后转化为二分问题。



//二分：0ms/100%; 42.3 MB/30.45%
/*
  - 分析：
    - 排序数组中的搜索问题，首先想到 二分法 解决。
    - 根据题意，由于数组数字是从0开始的，与数组索引值的初始值0相符，因此数组可以按照以下规则划分为两部分。
      - 左子数组： nums[i]=i ；
      - 右子数组： nums[i] ≠ =i ；
    - 缺失的数字等于 “右子数组的首位元素” 对应的索引；因此考虑使用二分法查找 “右子数组的首位元素” 。
      - 若mid对应值等于索引值时，证明所求在对应值的右侧，则left=mid+1；
      - 若mid对应值不等于索引值时，证明所求在对应值的左侧，则right=mid-1;
      - 当大小指针交叉时，终止循环，此时小指针指向第一个对应值与索引不相等的值，而这个索引值就是缺失的值。
      - 最终返回小指针。
  - 算法：
    - 初始化大小指针；
    - 二分；
    - 循环结束后，返回小指针对应的值。
*/

class Solution {
    public int missingNumber(int[] nums) {
        //初始化
        int left = 0, right = nums.length - 1;

        //二分：
        while(left<=right){
            int mid = (left + right) / 2;
            if(nums[mid] == mid)
                left = mid + 1;
            else 
                right = mid - 1;
        }

        //返回循环结束后小指针对应的值
        return left;
    }
}
