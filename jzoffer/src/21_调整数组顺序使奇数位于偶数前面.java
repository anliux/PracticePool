//21-调整数组顺序使奇数位于偶数前面
//思路：双指针



//双指针：2ms，击败99.2%的用户
/*
  - 算法：
    - 边界值判断：对于空指针和数组长度为0的情况，直接返回。(注：本题题目规定了范围所以这一步可以省略)
    - 初始化： i , j 双指针，分别指向数组 nums 左右两端；
    - 循环交换： 当 i=j 时跳出；
      - 指针 i 遇到奇数则执行 i=i+1 跳过，直到找到偶数；
      - 指针 j 遇到偶数则执行 j=j−1 跳过，直到找到奇数；
      - 交换 nums[i] 和 nums[j] 值；
    - 返回值： 返回已修改的 nums 数组。
    - 注：两指针移动时，也需要满足小指针小于大指针，即i<j需要三处判断。
  - 注：奇偶性判断
    - 常规：整除2取余 -- 常规数学思维
    - 位运算：与1 -- 二进制的奇数最低位是1，偶数最低位是0，可通过和数字1做与运算n&1得出数字n的奇偶性。

*/
class Solution {
    public int[] exchange(int[] nums) {
        //判空：数组为空或数组长度为0时返回原数组

        //初始化
        int low = 0, high = nums.length - 1, temp;

        //循环：直到两指针相遇
        //小指针向后找偶数，大指针向前找奇数
        while(low < high){
            //小指针遍历
            while((low < high) && (nums[low] & 1 ) == 1) //为奇数时继续向前
                low++;

            //大指针遍历
            while((low < high) && (nums[high] & 1) == 0) //为偶数时继续向后
                high--;
            
            //注：==的优先级高于&&，因此需要加括号，不清楚优先级的一律加括号。
          
            //两指针交换
            temp = nums[low];
            nums[low] = nums[high];
            nums[high] = temp;
        }

        //返回结果数组
        return nums;
    }
}
