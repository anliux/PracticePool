# 剑指Offer题解目录
### 参考：[cyc大神剑指题解](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md)

<!-- GFM-TOC -->
* [2. 单例模式](#2-单例模式)
* [3. 数组中重复的数字](#3-数组中重复的数字)
* [4. 二维数组中的查找](#4-二维数组中的查找)
* [5. 替换空格](#5-替换空格)
* [6. 从尾到头打印链表](#6-从尾到头打印链表)
* [7. 重建二叉树](#7-重建二叉树)
* [8. 二叉树的下一个结点](#8-二叉树的下一个结点)
* [9. 用两个栈实现队列](#9-用两个栈实现队列)
<!-- GFM-TOC -->



# 2. 单例模式

- 单例模式即只生成一个实例，分为懒汉式和饿汉式。



# 3. 数组中重复的数字

- ## 题目描述
  - 在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。
  - 数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。
  - 请找出数组中任意一个重复的数字。

```html
Input: {2, 3, 1, 0, 2, 5}
Output: 2
```

- ## 解题思路
  - 要求时间复杂度 O(N)，空间复杂度 O(1)。因此不能使用排序的方法，也不能使用额外的标记数组。
  - 对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。
  - 考虑测试用例：无效（空指针，包含0-n-1之外数字），不包含重复数字等。
  - 以数组下标i为单位遍历并比较，符合时交换，直到下标对应的数字等于下标值时，进入i+1的比较。
  - 注意：交换时用到numbers[temp]而不是numbers[numbers[i]]；交换在while循环里
  - 以 (2, 3, 1, 0, 2, 5) 为例，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复

- ## 代码链接：
  - [数组中重复的数字](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/03_%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.java)



# 4. 二维数组中的查找

- ## 题目描述
  - 给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。
  - 给定一个数，判断这个数是否在该二维数组中。

```html
Consider the following matrix:
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

Given target = 5, return true.
Given target = 20, return false.
```

- ## 解题思路
  - 要求时间复杂度 O(M + N)，空间复杂度 O(1)。其中 M 为行数，N 为 列数。
  - 该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。
  - 考虑从右上角或者左下角开始，可以避免可能选取区域重叠。
  - 右上角：左侧为小于，下侧为大于。若小，下移；若大，左移。
  - 测试用例考虑：有目标；没有目标（大于max，小于min，介于但不存在）；空指针；行列数非正
  - 空指针即地址为null，行列数非正，这两个需要排除。而没有目标中各种情况都属于找不到，返回false即可，无需特意判断。
  - 注1：因为多次使用到行列数，判空之后循环之前，赋值给变量：int rows = array.length， int cols = array[0].length;
  - 注2：注意循环时阈值设置，不要太大防止角标越界，不要太小防止取不到所有。
  
 - ## 代码链接：
   - [二维数组中的查找](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/04_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.java)



# 5. 替换空格

- ## 题目描述
  - 将一个字符串中的空格替换成 "%20"。

```text
Input:
"A B"

Output:
"A%20B"
```

- ## 解题思路
  - 对于URL参数：无法识别特殊字符，故空格替换为"%20"，#替换为"%23"
  - 由于空格的一个字符变为三个字符，替换后变长，两种思路：创建新字符串和在原字符串修改。
  - 原字符串修改且空间充足时：正遍历-多空格时，部分字符会移动多次，时间复杂度太高；逆遍历-O(n)
  - 首先计算空格数得到最终字符串末尾，P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。
  - P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。
  - 从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。
  - 知识点 - str函数：
    - `str.charAt(i)`-获取i处某值
    - `str.setCharAt(i,'m')`-m赋值给i处
    - `str.length()`-获取str长度
    - `str.append("abc")`-在str新增
  - 注意：`str.charAt()`获取到的是字符型，用单引号；`str.setCharAt(int, char)`中Char的C大写

- ## 代码链接
  - [替换空格](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/05_%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.java)
  


# 6. 从尾到头打印链表
  
- ## 题目描述
  - 从尾到头反过来打印出单链表的每个结点的值。

- ## 解题思路
  ### 使用栈
  - 栈具有后进先出的特点，从第一个结点开始遍历后最后一个第一个输出，是典型的“后进先出”。
  - 思路：新建栈 -- 遍历并压栈直至尾结点为空 -- 新建容器 -- 遍历并弹栈直至栈空 -- 返回容器
  - 知识点：
    - 新建栈：`Stack<Integer> stack = new Stack<>();`
    - 压栈：`stack.add(i);`  弹栈：`stack.pop();`  栈空：`stack.isEmpty()==true;`
    - java链表：`ListNode listnode`  取值：`listNode.val;`  下一值：`listNode.next;`
    - 容器泛型之类的（不太会..）：`ArrayList<Integer> ret = new ArrayList<>();`
   - 注意：使用栈Stack要加这句：`import java.util.Stack;`

  ### 使用递归
  - 递归在本质上是一个栈结构，故可以考虑递归。
  - 先递归输出后面的结点，再输出该结点本身。
  - 思路：新建容器 -- 判断结点是否为空，空则调用本身并传入next结点，直到为空时打印，然后返回上一个函数调用并打印，直到最外层 -- 返回容器
  - 要逆序打印链表 1->2->3（3,2,1)，可以先逆序打印链表 2->3(3,2)，最后再打印第一个节点 1。
    而链表 2->3 可以看成一个新的链表，要逆序打印该链表可以继续使用求解函数，也就是在求解函数中调用自己，这就是递归函数。
  - 知识点：
    - add方法与addAll方法的区别：
      - Add方法是将传入的参数作为当前List中的一个item存储，即使传入一个List也只令当前的List增加1个元素
      - AddAll是传入一个List，将此List中的所有元素加入到当前List中，也就是当前List会增加的元素个数为传入的List的大小
      - `addAll(Collection c)`
      - `add(int index,Elelemt e)`
  
  ### 使用头插法
  - 使用头插法可以得到一个逆序的链表。
  - 头结点和第一个节点的区别：
     - 头结点是在头插法中使用的一个额外节点，这个节点不存储值；
     - 第一个节点就是链表的第一个真正存储值的节点。

- ## 代码链接
  - [从尾到头打印链表](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/06_%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.java)
 
  
  
# 7. 重建二叉树
  
  
  
  
# 8. 二叉树的下一个结点




# 9. 用两个栈实现队列
