# 剑指Offer题解目录
### 参考：[cyc大神剑指题解](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md)

<!-- GFM-TOC -->
* [2. 单例模式](#2-单例模式)
* [3. 数组中重复的数字](#3-数组中重复的数字)
* [4. 二维数组中的查找](#4-二维数组中的查找)
* [5. 替换空格](#5-替换空格)
* [6. 从尾到头打印链表](#6-从尾到头打印链表)
* [7. 重建二叉树](#7-重建二叉树)
* [8. 二叉树的下一个结点](#8-二叉树的下一个结点)
* [9. 用两个栈实现队列](#9-用两个栈实现队列)
* [10.1 斐波那契数列](#101-斐波那契数列)
* [10.2 矩形覆盖](#102-矩形覆盖)
* [10.3 跳台阶](#103-跳台阶)
* [10.4 变态跳台阶](#104-变态跳台阶)
* [11. 旋转数组的最小数字](#11-旋转数组的最小数字)
* [12. 矩阵中的路径](#12-矩阵中的路径)
* [13. 机器人的运动范围](#13-机器人的运动范围)
* [14. 剪绳子](#14-剪绳子)
* [15. 二进制中 1 的个数](#15-二进制中-1-的个数)
* [16. 数值的整数次方](#16-数值的整数次方)
* [17. 打印从 1 到最大的 n 位数](#17-打印从-1-到最大的-n-位数)
* [18.1 在 O(1) 时间内删除链表节点](#181-在-o1-时间内删除链表节点)
* [18.2 删除链表中重复的结点](#182-删除链表中重复的结点)
* [19. 正则表达式匹配](#19-正则表达式匹配)
* [20. 表示数值的字符串](#20-表示数值的字符串)
* [21. 调整数组顺序使奇数位于偶数前面](#21-调整数组顺序使奇数位于偶数前面)
* [22. 链表中倒数第 K 个结点](#22-链表中倒数第-k-个结点)
* [23. 链表中环的入口结点](#23-链表中环的入口结点)
* [24. 反转链表](#24-反转链表)
* [25. 合并两个排序的链表](#25-合并两个排序的链表)
* [26. 树的子结构](#26-树的子结构)
* [27. 二叉树的镜像](#27-二叉树的镜像)
* [28. 对称的二叉树](#28-对称的二叉树)
* [29. 顺时针打印矩阵](#29-顺时针打印矩阵)
* [30. 包含 min 函数的栈](#30-包含-min-函数的栈)
* [31. 栈的压入、弹出序列](#31-栈的压入弹出序列)
* [32.1 从上往下打印二叉树](#321-从上往下打印二叉树)
* [32.2 把二叉树打印成多行](#322-把二叉树打印成多行)
* [32.3 按之字形顺序打印二叉树](#323-按之字形顺序打印二叉树)
* [33. 二叉搜索树的后序遍历序列](#33-二叉搜索树的后序遍历序列)
* [34. 二叉树中和为某一值的路径](#34-二叉树中和为某一值的路径)
* [35. 复杂链表的复制](#35-复杂链表的复制)
* [36. 二叉搜索树与双向链表](#36-二叉搜索树与双向链表)
* [37. 序列化二叉树](#37-序列化二叉树)
* [38. 字符串的排列](#38-字符串的排列)
* [39. 数组中出现次数超过一半的数字](#39-数组中出现次数超过一半的数字)
* [40. 最小的 K 个数](#40-最小的-k-个数)
* [41.1 数据流中的中位数](#411-数据流中的中位数)
* [41.2 字符流中第一个不重复的字符](#412-字符流中第一个不重复的字符)
* [42. 连续子数组的最大和](#42-连续子数组的最大和)
* [43. 从 1 到 n 整数中 1 出现的次数](#43-从-1-到-n-整数中-1-出现的次数)
* [44. 数字序列中的某一位数字](#44-数字序列中的某一位数字)
* [45. 把数组排成最小的数](#45-把数组排成最小的数)
* [46. 把数字翻译成字符串](#46-把数字翻译成字符串)
* [47. 礼物的最大价值](#47-礼物的最大价值)
* [48. 最长不含重复字符的子字符串](#48-最长不含重复字符的子字符串)
* [49. 丑数](#49-丑数)
* [50. 第一个只出现一次的字符位置](#50-第一个只出现一次的字符位置)
* [51. 数组中的逆序对](#51-数组中的逆序对)
* [52. 两个链表的第一个公共结点](#52-两个链表的第一个公共结点)
* [53. 数字在排序数组中出现的次数](#53-数字在排序数组中出现的次数)
* [54. 二叉查找树的第 K 个结点](#54-二叉查找树的第-k-个结点)
* [55.1 二叉树的深度](#551-二叉树的深度)
* [55.2 平衡二叉树](#552-平衡二叉树)
* [56. 数组中只出现一次的数字](#56-数组中只出现一次的数字)
* [57.1 和为 S 的两个数字](#571-和为-s-的两个数字)
* [57.2 和为 S 的连续正数序列](#572-和为-s-的连续正数序列)
* [58.1 翻转单词顺序列](#581-翻转单词顺序列)
* [58.2 左旋转字符串](#582-左旋转字符串)
* [59. 滑动窗口的最大值](#59-滑动窗口的最大值)
* [60. n 个骰子的点数](#60-n-个骰子的点数)
* [61. 扑克牌顺子](#61-扑克牌顺子)
* [62. 圆圈中最后剩下的数](#62-圆圈中最后剩下的数)
* [63. 股票的最大利润](#63-股票的最大利润)
* [64. 求 1+2+3+...+n](#64-求-123n)
* [65. 不用加减乘除做加法](#65-不用加减乘除做加法)
* [66. 构建乘积数组](#66-构建乘积数组)
* [67. 把字符串转换成整数](#67-把字符串转换成整数)
* [68. 树中两个节点的最低公共祖先](#68-树中两个节点的最低公共祖先)
<!-- GFM-TOC -->



# 2. 单例模式
- ## 解题思路
  - 设计模式：解决某一类问题的行之有效的解决办法（或思想）
  - 单例模式即只生成一个实例，可以保证一个类的对象的唯一性。
  - 分析：
    - 构造函数私有：一个类只要提供了构造函数就可以产生多个对象，故私有构造函数
    - 因为不让其他程序创建对象，故自己在本类中new一个对象，并设为静态私有，好处是可控
      注：静态 -- 防止无法从静态上下文中访问非静态变量
    - 创建一个getInstance功能，对外提供访问接口，设为公共静态
  - 分为懒汉式和饿汉式。
  - 饿汉式：直接new，开发常用
  - 懒汉式：单例的延迟加载，当调用到时再new，面试多见
    - 懒汉式并发访问：加入同步机制解决安全问题，通过双重判断是否为空来减少访问锁的次数以提高效率

- ## 代码链接
  - [单例模式](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/02_%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.java)



# 3. 数组中重复的数字

- ## 题目描述
  - 在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。
  - 数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。
  - 请找出数组中任意一个重复的数字。

```html
Input: {2, 3, 1, 0, 2, 5}
Output: 2
```

- ## 解题思路
  - 要求时间复杂度 O(N)，空间复杂度 O(1)。因此不能使用排序的方法，也不能使用额外的标记数组。
  - 对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。
  - 考虑测试用例：无效（空指针，包含0-n-1之外数字），不包含重复数字等。
  - 以数组下标i为单位遍历并比较，符合时交换，直到下标对应的数字等于下标值时，进入i+1的比较。
  - 注意：交换时用到numbers[temp]而不是numbers[numbers[i]]；交换在while循环里
  - 以 (2, 3, 1, 0, 2, 5) 为例，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复

- ## 代码链接：
  - [数组中重复的数字](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/03_%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.java)



# 4. 二维数组中的查找

- ## 题目描述
  - 给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。
  - 给定一个数，判断这个数是否在该二维数组中。

```html
Consider the following matrix:
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

Given target = 5, return true.
Given target = 20, return false.
```

- ## 解题思路
  - 要求时间复杂度 O(M + N)，空间复杂度 O(1)。其中 M 为行数，N 为 列数。
  - 该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。
  - 考虑从右上角或者左下角开始，可以避免可能选取区域重叠。
  - 右上角：左侧为小于，下侧为大于。若小，下移；若大，左移。
  - 测试用例考虑：有目标；没有目标（大于max，小于min，介于但不存在）；空指针；行列数非正
  - 空指针即地址为null，行列数非正，这两个需要排除。而没有目标中各种情况都属于找不到，返回false即可，无需特意判断。
  - 注1：因为多次使用到行列数，判空之后循环之前，赋值给变量：int rows = array.length， int cols = array[0].length;
  - 注2：注意循环时阈值设置，不要太大防止角标越界，不要太小防止取不到所有。
  
 - ## 代码链接：
   - [二维数组中的查找](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/04_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.java)



# 5. 替换空格

- ## 题目描述
  - 将一个字符串中的空格替换成 "%20"。

```text
Input:
"A B"

Output:
"A%20B"
```

- ## 解题思路
  - 对于URL参数：无法识别特殊字符，故空格替换为"%20"，#替换为"%23"
  - 由于空格的一个字符变为三个字符，替换后变长，两种思路：创建新字符串和在原字符串修改。
  - 原字符串修改且空间充足时：正遍历-多空格时，部分字符会移动多次，时间复杂度太高；逆遍历-O(n)
  - 首先计算空格数得到最终字符串末尾，P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。
  - P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。
  - 从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。
  - 知识点 - str函数：
    - `str.charAt(i)`-获取i处某值
    - `str.setCharAt(i,'m')`-m赋值给i处
    - `str.length()`-获取str长度
    - `str.append("abc")`-在str新增
  - 注意：`str.charAt()`获取到的是字符型，用单引号；`str.setCharAt(int, char)`中Char的C大写

- ## 代码链接
  - [替换空格](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/05_%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.java)
  


# 6. 从尾到头打印链表
  
- ## 题目描述
  - 从尾到头反过来打印出单链表的每个结点的值。

- ## 解题思路
  ### 使用栈
  - 栈具有后进先出的特点，从第一个结点开始遍历后最后一个第一个输出，是典型的“后进先出”。
  - 思路：新建栈 -- 遍历并压栈直至尾结点为空 -- 新建容器 -- 遍历并弹栈直至栈空 -- 返回容器
  - 知识点：
    - 新建栈：`Stack<Integer> stack = new Stack<>();`
    - 压栈：`stack.add(i);`  弹栈：`stack.pop();`  栈空：`stack.isEmpty()==true;`
    - java链表：`ListNode listnode`  取值：`listNode.val;`  下一值：`listNode.next;`
    - 容器泛型之类的（不太会..）：`ArrayList<Integer> ret = new ArrayList<>();`
   - 注意：使用栈Stack要加这句：`import java.util.Stack;`

  ### 使用递归
  - 递归在本质上是一个栈结构，故可以考虑递归。
  - 先递归输出后面的结点，再输出该结点本身。
  - 思路：新建容器 -- 判断结点是否为空，空则调用本身并传入next结点，直到为空时打印，然后返回上一个函数调用并打印，直到最外层 -- 返回容器
  - 要逆序打印链表 1->2->3（3,2,1)，可以先逆序打印链表 2->3(3,2)，最后再打印第一个节点 1。
    而链表 2->3 可以看成一个新的链表，要逆序打印该链表可以继续使用求解函数，也就是在求解函数中调用自己，这就是递归函数。
  - 知识点：
    - add方法与addAll方法的区别：
      - Add方法是将传入的参数作为当前List中的一个item存储，即使传入一个List也只令当前的List增加1个元素
      - AddAll是传入一个List，将此List中的所有元素加入到当前List中，也就是当前List会增加的元素个数为传入的List的大小
      - `addAll(Collection c)`
      - `add(int index,Elelemt e)`
  
  ### 使用头插法（未实践）
  - 使用头插法可以得到一个逆序的链表。
  - 头结点和第一个节点的区别：
     - 头结点是在头插法中使用的一个额外节点，这个节点不存储值；
     - 第一个节点就是链表的第一个真正存储值的节点。

- ## 代码链接
  - [从尾到头打印链表](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/06_%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.java)
 
  
  
# 7. 重建二叉树
- ## 题目描述
  - 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。
  - 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
  - 例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

- ## 解题思路
  - 因为是树的结构，一般都是用递归来实现。
  - 用数学归纳法的思想就是，假设最后一步，就是root的左右子树都已经重建好了，那么只要考虑将root的左右子树安上去即可。
  - 根据前序遍历的性质，第一个元素必然就是root，那么下面的工作就是如何确定root的左右子树的范围。
  - 根据中序遍历的性质，root元素前面都是root的左子树，后面都是root的右子树。那么我们只要找到中序遍历中root的位置，就可以确定好左右子树的范围。
  - 正如上面所说，只需要将确定的左右子树安到root上即可。
  - 递归要注意出口，假设最后只有一个元素了，那么就要返回。  
  - 知识点：
    - `Arrays.copyOfRange(T[ ] original,int from,int to)` ：将一个原始的数组original，从下标from开始复制，复制到下标to，生成一个新的数组。注意这里包括下标from，不包括下标to。
 
 - ## 代码链接
   - [重建二叉树](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/07_%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.java)
  
  
  
# 8. 二叉树的下一个结点
- ## 题目描述
  - 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。
  - 注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。
   
- ## 解题思路
  - 若该结点存在右子树：则下一个结点为右子树最左子结点；若没有左子结点，则下一个结点即该右子树的根结点本身
  - 若该结点不存在右子树，分两种情况： 
    - 1 该结点为父结点的左子结点，则下一个结点为其父结点
    - 2 该结点为父结点的右子结点，则沿着父结点向上遍历，直到找到一个结点，它是其父结点的左子结点，则该结点的父结点是下一个结点
  - 思路：判空则返回 -- 判断该结点的右结点是否为空，并分两类情况进行讨论
  - 注意：没有右子且不是其父的左子的情况比较复杂，但是代码体现比较简单，只是循环。
  
- ## 代码链接
  - [二叉树的下一个结点](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/08_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9.java)



# 9. 用两个栈实现队列
- ## 题目描述
  - 用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。

- ## 解题思路
  - 栈“先入后出”，而队列“先入先出”，可利用两个栈的两次“先入后出”使得最终顺序为“先入先出”
    - 具体地，一个元素进入栈1之后，出栈的顺序被反转。当元素要出栈时，需要先进入2栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。
  - 只在栈1入栈（push）操作，只在栈2出栈（pop）操作。
    - 入栈即栈1入栈
    - 出栈需要先对栈2判空，若非空，直接出；若空，需要从栈1弹出后栈2入栈，直到栈1空，此时第一个进栈的在栈2top，可以弹出。
  - 思路：栈1push，栈2pop；pop先判空，都空时抛出异常；栈2非空时直接pop，栈2空时先栈1pop进栈2，再栈2pop
  - 知识点：
    - 使用栈要声明：`import java.util.Stack;`
    - 创建栈：`Stack<Integer> stackname = new Stack<Integer>();`
    - 压栈：stackname.push(val);
    - 弹栈：stackname.pop(); -- 弹栈会返回原栈顶值，可赋值给变量使用
    - 栈空：stackname.empty(); 空则true，否则false

- ## 代码链接
  - [用两个栈实现队列](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/09_%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.java)
  


# 10.1 斐波那契数列
- ## 题目描述
  - 现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n<=39
  - f(0)=0; f(1)=1; f(n)=f(n-1)+f(n-2),n>=2
  
- ## 解题思路
  - 斐波那契数列属于典型的递归，但是用递归求解的话，过多重复，时间效率低。
  - 考虑用循环实现递归，可以极大地提高时间效率。
    - 时间复杂度：O(n)
    - 第 i 项只与第 i-1 和第 i-2 项有关，因此只需要存储前两项的值就能求解第 i 项，从而将空间复杂度由 O(N) 降低为 O(1)。
    - 规定n<=39故在int范围内
  - 还有一种转换为求矩阵的乘方，思考过多不作考虑。

- ## 代码链接
  - [斐波那契数列](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/10_1_%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.java)



# 10.2 矩形覆盖
- ## 题目要求
  - 我们可以用2×1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2×1的小矩形无重叠地覆盖一个2×n的大矩形，总共有多少种方法？

- ## 解题思路
  - 被覆盖的大矩形是两行n列的（画示意图更明显，此处省略图）
  - n=1时：只有一种方法
  - n=2时：有横着覆盖和竖着覆盖两种方法
  - n>=2时：分为两种情况
    - 若第一个小矩形竖着，则剩余n-1个区域的覆盖方法记为f(n-1)
    - 若第一个小矩形横着，则它下方也应该横着填一个小矩形，则剩余n-2个区域的覆盖方法记为f(n-2)
    - 即f(n)=f(n-1)+f(n-2),n>=2
  - 综上，此问题可归结为斐波那契数列相同的问题。
  - 同上，依然是用循环来实现递归
  - 注意：首项和第二项与原斐波那契数列有不同。
  - 注意：代码初始化返回值时，要赋值，不能空着（比如int result;）会报错的。

- ## 代码链接
  - [矩阵覆盖](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/10_2_%E7%9F%A9%E9%98%B5%E8%A6%86%E7%9B%96.java)



# 10.3 跳台阶
- ## 题目描述
  - 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

- ## 解题思路
  - 当n=1时：只有1种跳法
  - 当n=2时：有2种跳法 -- 一级一级跳两次或者一次跳两级
  - 当n>=2时：分为两种情况
    - 当第一次跳一级，则跳法数等于剩余台阶的跳法f(n-1)
    - 当第一次跳两级，则跳法数等于剩余台阶的跳法f(n-2)
    - 即f(n)=f(n-1)+f(n-2),n>=2
  - 综上，跳台阶问题可以归结为斐波那契数列问题。

- ## 代码链接
  - [跳台阶](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/10_3_%E8%B7%B3%E5%8F%B0%E9%98%B6.java)



# 10.4 变态跳台阶
- ## 题目描述
  - 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

- ## 解题思路之数学推导：
  - 跳上 n-1 级台阶，可以从 n-2 级跳 1 级上去，也可以从 n-3 级跳 2 级上去...，那么
    - f(n-1) = f(n-2) + f(n-3) + ... + f(0)
  - 同样，跳上 n 级台阶，可以从 n-1 级跳 1 级上去，也可以从 n-2 级跳 2 级上去... ，那么
    - f(n) = f(n-1) + f(n-2) + ... + f(0)
  - 综上可得：f(n) - f(n-1) = f(n-1)
  - 即：f(n) = 2×f(n-1) 是等比数列，1,2，公比2可用位移运算优化
  - 用位移运算，1<<(target-1)，非正情况另考虑，从1开始到n都是符合公式的。

- ## 代码链接
  - [变态跳台阶](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/10_4_%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6.java)



# 11. 旋转数组的最小数字
- ## 题目描述
  - 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
  - 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
  - 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
  - NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

- ## 解题思路1：暴力搜索最小值
  - 虽然是面试官不愿意看到的废柴方法，但是牛客里可以ac，亲测....
  - 但是还是尽量不要这样做吧，除非没别的想法了
  
- ## 解题思路2：暴力搜索是否符合非降序
  - 在两段范围内都是非降序，当不符合这个规律时，就找到了最小数字
  
- ## 解题思路3：排序
  - 既然是找最小值，使用排序也是很常规的思路
  - 利用 Arrays 工具类里的排序函数，默认的排序规则是从小到大，排序后的数组第一个值就是最小值
  - 注意：需要import Arrays，干脆util.*
  
- ## 解题思路4：变相二分查找
  - 首先，因为有一定排序，故不能使用遍历整个数组，找出其中最小的数。(其实可以ac，亲测)
  - 因为有一定排序，故使用二分：
    - 大数组在前，小数组在后
    - 最小元素应该在大数组和小数组的交界处，且位于小数组的第一个
    - low，high分别指向数组的首尾，则low指向大数组，high指向小数组
    - 取mid=(low+high)/2
    - 若mid位于大数组，则大于等于low，最小值在mid后，故low向前移动到mid位置
    - 若mid位于小数组，则小于等于high，最小值在mid前，故high向后移动到mid位置
    - low和high不断向中间移动，最终将相邻，而high正好指向最小值，这是循环判停的条件：high-low==1，
  - 非递减，需要考虑相同数字的情况，比如数组 {1,1,1,0,1}
    - 对于不符合以上分类的情况
    - 此时无法用二分判断，故使用遍历方法暴力求解找到最小值

- ## 代码链接
  - [旋转数组的最小数字](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/11_%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.java)



# 12. 矩阵中的路径
- ## 题目描述
  - 请设计一个函数，用来判断在一个矩阵中**是否**存在一条包含某字符串所有字符的路径。
  - 路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。
  - 如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 
  - 例如 a b c e s f c s a d e e 矩阵中包含一条字符串"bccced"的路径，但是矩阵中不包含"abcb"路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。
  - 注意：传入的是一维矩阵，行数，列数，目标str

- ## 解题思路
  - 使用回溯法（backtracking）进行求解，它是一种暴力搜索方法，通过搜索所有可能的结果来求解问题。
  - 回溯法在一次搜索结束时需要进行回溯（回退），将这一次搜索过程中设置的状态进行清除，从而开始一次新的搜索过程。
  - 思路
    - 0.根据给定数组，初始化一个标志位数组，初始化为false，表示未走过，true表示已经走过，不能走第二次
    - 1.根据行数和列数，遍历数组，先找到一个与str字符串的第一个元素相匹配的矩阵元素，进入judge
    - 2.根据i和j先确定一维数组的位置，因为给定的matrix是一个一维数组
    - 3.确定递归终止条件：越界，当前找到的矩阵值不等于数组对应位置的值，已经走过的，这三类情况，都直接false，说明这条路不通
    - 4.若k，就是待判定的字符串str的索引已经判断到了最后一位，此时说明是匹配成功的
    - 5.下面就是本题的精髓，递归不断地寻找周围四个格子是否符合条件，只要有一个格子符合条件，就继续再找这个符合条件的格子的四周是否存在符合条件的格子，直到k到达末尾或者不满足递归条件就停止。
    - 6.走到这一步，说明本次是不成功的，我们要还原一下标志位数组index处的标志位，进入下一轮的判断。

- ## 代码链接
  - [矩阵中的路径](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/12_%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84.java)



# 13. 机器人的运动范围
- ## 题目描述
  - 地上有一个m行和n列的方格。
  - 一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 
  - 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。
  - 请问该机器人能够达到多少个格子？

- ## 解题思路
  - 深度优先搜索（Depth First Search，DFS）方法。
  - 回溯是深度优先搜索的一种特例，它在一次搜索过程中需要设置一些本次搜索过程的局部状态，并在本次搜索结束之后清除状态。
  - 而普通的深度优先搜索并不需要使用这些局部状态，虽然还是有可能设置一些全局状态。
  - 具体思路同上题，同时加一个位数和的限制条件
  - 注意：
    - flag是二维数组，定义还有传参的时候，别少写方括号[]
    - do{}while(); while之后的分号千万别忘写了。

- ## 代码链接
  - [机器人的运动范围](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/13_%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4.java)



# 14. 剪绳子




# 15. 二进制中 1 的个数




# 16. 数值的整数次方




# 17. 打印从 1 到最大的 n 位数




# 18.1 在 O(1) 时间内删除链表节点




# 18.2 删除链表中重复的结点




# 19. 正则表达式匹配






20. 表示数值的字符串
21. 调整数组顺序使奇数位于偶数前面
22. 链表中倒数第 K 个结点
23. 链表中环的入口结点
24. 反转链表
25. 合并两个排序的链表
26. 树的子结构
27. 二叉树的镜像
28. 对称的二叉树
29. 顺时针打印矩阵
30. 包含 min 函数的栈
31. 栈的压入、弹出序列
32.1 从上往下打印二叉树
32.2 把二叉树打印成多行
32.3 按之字形顺序打印二叉树
33. 二叉搜索树的后序遍历序列
34. 二叉树中和为某一值的路径
35. 复杂链表的复制
36. 二叉搜索树与双向链表
37. 序列化二叉树
38. 字符串的排列
39. 数组中出现次数超过一半的数字
40. 最小的 K 个数
41.1 数据流中的中位数
41.2 字符流中第一个不重复的字符
42. 连续子数组的最大和
* [43. 从 1 到 n 整数中 1 出现的次数](#43-从-1-到-n-整数中-1-出现的次数)
* [44. 数字序列中的某一位数字](#44-数字序列中的某一位数字)
* [45. 把数组排成最小的数](#45-把数组排成最小的数)
* [46. 把数字翻译成字符串](#46-把数字翻译成字符串)
* [47. 礼物的最大价值](#47-礼物的最大价值)
* [48. 最长不含重复字符的子字符串](#48-最长不含重复字符的子字符串)
* [49. 丑数](#49-丑数)
* [50. 第一个只出现一次的字符位置](#50-第一个只出现一次的字符位置)
* [51. 数组中的逆序对](#51-数组中的逆序对)
* [52. 两个链表的第一个公共结点](#52-两个链表的第一个公共结点)
* [53. 数字在排序数组中出现的次数](#53-数字在排序数组中出现的次数)
* [54. 二叉查找树的第 K 个结点](#54-二叉查找树的第-k-个结点)
* [55.1 二叉树的深度](#551-二叉树的深度)
* [55.2 平衡二叉树](#552-平衡二叉树)
* [56. 数组中只出现一次的数字](#56-数组中只出现一次的数字)
* [57.1 和为 S 的两个数字](#571-和为-s-的两个数字)
* [57.2 和为 S 的连续正数序列](#572-和为-s-的连续正数序列)
* [58.1 翻转单词顺序列](#581-翻转单词顺序列)
* [58.2 左旋转字符串](#582-左旋转字符串)
* [59. 滑动窗口的最大值](#59-滑动窗口的最大值)
* [60. n 个骰子的点数](#60-n-个骰子的点数)
* [61. 扑克牌顺子](#61-扑克牌顺子)
* [62. 圆圈中最后剩下的数](#62-圆圈中最后剩下的数)
* [63. 股票的最大利润](#63-股票的最大利润)
* [64. 求 1+2+3+...+n](#64-求-123n)
* [65. 不用加减乘除做加法](#65-不用加减乘除做加法)
* [66. 构建乘积数组](#66-构建乘积数组)
* [67. 把字符串转换成整数](#67-把字符串转换成整数)
* [68. 树中两个节点的最低公共祖先](#68-树中两个节点的最低公共祖先)
