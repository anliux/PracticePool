# 剑指Offer题解目录
### 参考：
- [cyc大神剑指题解](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md)
- 牛客网：[剑指offer](https://www.nowcoder.com/ta/coding-interviews)
- 力扣中国：[剑指offer](https://leetcode-cn.com/problemset/lcof/)


### 解题思路注意
- 首先：根据特殊测试用例排除’空指针‘，’用例越界‘等情况，增加鲁棒性；
- 其次：开始按正常用例思考解决办法，可以从易到难思考，可用具体例子突破，注意有无复杂度要求；
- 最后：检查保证有不符合全部条件下的返回值(return -1等)。
- 注：常规套路可以适当背诵。


#### 目录
<!-- GFM-TOC -->
* [2. 单例模式](#2-单例模式):
* [3. 数组中重复的数字](#3-数组中重复的数字): 遍历；集合(哈希表)；索引排列
* [4. 二维数组中的查找](#4-二维数组中的查找): 暴力；角值逼近(线性查找)
* [5. 替换空格](#5-替换空格): 库函数；可变字符串；原字符串倒序
* [6. 从尾到头打印链表](#6-从尾到头打印链表): 栈; 递归; 两次遍历
* [7. 重建二叉树](#7-重建二叉树)：递归 <绕，背!!!>
* [8. 二叉树的下一个结点](#8-二叉树的下一个结点)
* [9. 用两个栈实现队列](#9-用两个栈实现队列)：负负得正
* [10.1 斐波那契数列](#101-斐波那契数列): 递归；循环(自下而上)；公式；查表法
* [10.2 矩形覆盖](#102-矩形覆盖)
* [10.3 跳台阶](#103-跳台阶)：递归；动态规划
* [10.4 变态跳台阶](#104-变态跳台阶)：公式推导得出的位移运算
* [11. 旋转数组的最小数字](#11-旋转数组的最小数字)：暴力最小值; 暴力非降序; 库函数排序; 二分+暴力(复杂坑多); 二分(相等j--背下来)
* [12. 矩阵中的路径](#12-矩阵中的路径)：dfs套路
* [13. 机器人的运动范围](#13-机器人的运动范围): dfs套路
* [14.1 剪绳子](#141-剪绳子)：贪心(优先3，余1凑双2); 动态规划; 查表法
* [14.2 剪绳子进阶](#142-剪绳子进阶)
* [15. 二进制中 1 的个数](#15-二进制中-1-的个数)
* [16. 数值的整数次方](#16-数值的整数次方)
* [17. 打印从 1 到最大的 n 位数](#17-打印从-1-到最大的-n-位数)
* [18.1 在 O(1) 时间内删除链表节点](#181-在-o1-时间内删除链表节点)
* [18.2 删除链表中重复的结点](#182-删除链表中重复的结点)
* [19. 正则表达式匹配](#19-正则表达式匹配)
* [20. 表示数值的字符串](#20-表示数值的字符串)
* [21. 调整数组顺序使奇数位于偶数前面](#21-调整数组顺序使奇数位于偶数前面)
* [22. 链表中倒数第 K 个结点](#22-链表中倒数第-k-个结点)
* [23. 链表中环的入口结点](#23-链表中环的入口结点)
* [24. 反转链表](#24-反转链表)
* [25. 合并两个排序的链表](#25-合并两个排序的链表)
* [26. 树的子结构](#26-树的子结构)
* [27. 二叉树的镜像](#27-二叉树的镜像)
* [28. 对称的二叉树](#28-对称的二叉树)
* [29. 顺时针打印矩阵](#29-顺时针打印矩阵)
* [30. 包含 min 函数的栈](#30-包含-min-函数的栈)
* [31. 栈的压入、弹出序列](#31-栈的压入弹出序列)
* [32.1 从上往下打印二叉树](#321-从上往下打印二叉树)
* [32.2 把二叉树打印成多行](#322-把二叉树打印成多行)
* [32.3 按之字形顺序打印二叉树](#323-按之字形顺序打印二叉树)
* [33. 二叉搜索树的后序遍历序列](#33-二叉搜索树的后序遍历序列)
* [34. 二叉树中和为某一值的路径](#34-二叉树中和为某一值的路径)
* [35. 复杂链表的复制](#35-复杂链表的复制)
* [36. 二叉搜索树与双向链表](#36-二叉搜索树与双向链表)
* [37. 序列化二叉树](#37-序列化二叉树)
* [38. 字符串的排列](#38-字符串的排列)
* [39. 数组中出现次数超过一半的数字](#39-数组中出现次数超过一半的数字)
* [40. 最小的 K 个数](#40-最小的-k-个数)
* [41.1 数据流中的中位数](#411-数据流中的中位数)
* [41.2 字符流中第一个不重复的字符](#412-字符流中第一个不重复的字符)
* [42. 连续子数组的最大和](#42-连续子数组的最大和)
* [43. 从 1 到 n 整数中 1 出现的次数](#43-从-1-到-n-整数中-1-出现的次数)
* [44. 数字序列中的某一位数字](#44-数字序列中的某一位数字)
* [45. 把数组排成最小的数](#45-把数组排成最小的数)
* [46. 把数字翻译成字符串](#46-把数字翻译成字符串)
* [47. 礼物的最大价值](#47-礼物的最大价值)
* [48. 最长不含重复字符的子字符串](#48-最长不含重复字符的子字符串)
* [49. 丑数](#49-丑数)
* [50. 第一个只出现一次的字符位置](#50-第一个只出现一次的字符位置)
* [51. 数组中的逆序对](#51-数组中的逆序对)
* [52. 两个链表的第一个公共结点](#52-两个链表的第一个公共结点)
* [53.1 数字在排序数组中出现的次数](#531-数字在排序数组中出现的次数)
* [53.2 0到n-1中缺失的数字](#532-0到n-1中缺失的数字)
* [54. 二叉查找树的第 K 个结点](#54-二叉查找树的第-k-个结点)
* [55.1 二叉树的深度](#551-二叉树的深度)
* [55.2 平衡二叉树](#552-平衡二叉树)
* [56.1 数组中只出现一次的数字](#561-数组中只出现一次的数字)
* [56.2 数组中只出现一次的数字II](#562-数组中只出现一次的数字ii)
* [57.1 和为 S 的两个数字](#571-和为-s-的两个数字)
* [57.2 和为 S 的连续正数序列](#572-和为-s-的连续正数序列)
* [58.1 翻转单词顺序列](#581-翻转单词顺序列)
* [58.2 左旋转字符串](#582-左旋转字符串)
* [59.1 滑动窗口的最大值](#591-滑动窗口的最大值)
* [59.2 队列的最大值](592-队列的最大值)
* [60. n 个骰子的点数](#60-n-个骰子的点数)
* [61. 扑克牌顺子](#61-扑克牌顺子)
* [62. 圆圈中最后剩下的数字](#62-圆圈中最后剩下的数字)
* [63. 股票的最大利润](#63-股票的最大利润)
* [64. 求 1+2+3+...+n](#64-求-123n)
* [65. 不用加减乘除做加法](#65-不用加减乘除做加法)
* [66. 构建乘积数组](#66-构建乘积数组)
* [67. 把字符串转换成整数](#67-把字符串转换成整数)
* [68. 树中两个节点的最低公共祖先](#68-树中两个节点的最低公共祖先)
<!-- GFM-TOC -->



# 2. 单例模式
- ## 解题思路
  - 设计模式：解决某一类问题的行之有效的解决办法（或思想）
  - 单例模式即只生成一个实例，可以保证一个类的对象的唯一性。
  - 分析：
    - 构造函数私有：一个类只要提供了构造函数就可以产生多个对象，故私有构造函数
    - 因为不让其他程序创建对象，故自己在本类中new一个对象，并设为静态私有，好处是可控
      注：静态 -- 防止无法从静态上下文中访问非静态变量
    - 创建一个getInstance功能，对外提供访问接口，设为公共静态
  - 分为懒汉式和饿汉式。
  - 饿汉式：直接new，开发常用
  - 懒汉式：单例的延迟加载，当调用到时再new，面试多见
    - 懒汉式并发访问：加入同步机制解决安全问题，通过双重判断是否为空来减少访问锁的次数以提高效率

- ## 代码链接
  - [单例模式](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/02_%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 3. 数组中重复的数字
- ## 题目描述
  - 在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。
  - 数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。
  - 请找出数组中任意一个重复的数字。
  - 示例：Input: {2, 3, 1, 0, 2, 5}，Output: 2

- ## 解题思路
  - 思路：遍历；集合(哈希表)；索引排列
  - 遍历：
    - 复杂度：时间O(n^2)
    - 分析：最简单朴素的思路
    - 算法: 第一层循环依次选取一个锚点数字，第二层循环遍历剩下的数字，当找到相同的两个数字，退出循环，返回正确的结果。
    - 问题：时间复杂度较高，没有算法技巧。
  - 集合：
    - 复杂度：时间O(n)，空间O(n)
    - 分析：集合是无重复的，与本题非常切合
    - 算法：定义集合；遍历数组：将数组元素存入集合，当无法存入时，返回当前元素；返回-1。
    - HashSet add:
      - `public boolean add(E e)`，add是布尔型
      - 如果此 set 中尚未包含指定元素，则添加指定元素。
        - 更确切地讲，如果此 set 没有包含满足 (e==null ? e2==null : e.equals(e2)) 的元素 e2，则向此 set 添加指定的元素 e。
      - 如果此 set 已包含该元素，则该调用不更改 set 并返回 false。
    - 注：也可以用哈希表存(put(key,value))，每次查找哈希表中是否已有该元素 
  - 索引排列：
    - 复杂度：时间O(n)，空间O(1)
    - 用数组模拟哈希表的思想 
      - 本方法的关键点：用到了'数组元素0 到 n-1 的范围内'这个其他两个方法没有考虑的条件。
    - 如果要求时间复杂度 O(N)，空间复杂度 O(1)，则不能使用排序的方法，也不能使用额外的标记数组。
      - 注：翻了几处，都没有要求空间O(1)，用集合美滋滋啦 (这个有点绕，不如集合直接)
    - 对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。
      - 省掉额外的空间，将每个位置的数交换映射到其对应的数组下标下面，当出现新的元素与其对应的下标中的数字相等时，即为重复数字
    - 用到 while 循环，原因是保证交换过来的新元素位置也要正确
    - 算法：判空；遍历数组：如果不等，判断重复，交换；返回false
      - 考虑测试用例：无效（空指针，包含0-n-1之外数字），不包含重复数字等。
      - 以数组下标i为单位遍历并比较，符合时交换，直到(不能保证交换后一定符合因此这里要加一个循环)下标对应的数字等于下标值时，进入下一轮i+1的比较(相当于还是两层循环)。
      - 注意：交换时用到numbers[temp]而不是numbers[numbers[i]]；交换在while循环里 (可以额外设置一个变量存numbers[i])
      - 例如：(2, 3, 1, 0, 2, 5) ，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复
 
  - 注：牛客和力扣的本题参数和返回值类型不同，前一个是力扣，返回int，后一个是牛客，返回boolean
  
- ## 代码链接：
  - [数组中重复的数字](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/03_%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 4. 二维数组中的查找
- ## 题目描述
  - 给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。
  - 给定一个数，判断这个数是否在该二维数组中。

    ```html
    Consider the following matrix:
    [
      [1,   4,  7, 11, 15],
      [2,   5,  8, 12, 19],
      [3,   6,  9, 16, 22],
      [10, 13, 14, 17, 24],
      [18, 21, 23, 26, 30]
    ]

    Given target = 5, return true.
    Given target = 20, return false.
    ```

- ## 解题思路
  - 思路：暴力法；线性查找(角值逼近)。
  - 关键：选取正确的基准点；有方向地缩小查找范围。
  - 暴力法：忽略存在的顺序，直接暴力查找；时间复杂度高。
    - 复杂度：时间O(mn)，空间O(1)  -- m 为行数，n 为 列数。
  - 线性查找：
    - 复杂度：时间O(m+n)，空间O(1)  -- m 为行数，n 为 列数。
    - 关键：站在右上角看。这个矩阵其实就像是一个Binary Search Tree。
    - 分析：
      - 分析复杂问题：从一个具体的例子入手
      - 可以发现：该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。
      - 考虑从右上角或者左下角开始，可以避免可能选取区域重叠。
      - 右上角：左侧为小于，下侧为大于。若小，下移；若大，左移。
      - 测试用例考虑：有目标；没有目标（大于max，小于min，介于但不存在）；空指针；行列数非正
      - 空指针即地址为null，行列数非正，这两个需要排除。而没有目标中各种情况都属于找不到，返回false即可，无需特意判断。
    - 算法本质： 
      - 每轮 i 或 j 移动后，相当于生成了“消去一行（列）的新矩阵”， 索引(i,j) 指向新矩阵的左下角元素（标志数）
      - 因此可重复使用以上性质消去行（列）。
    - 算法：判空(如果定义了范围，可省略)；定义右上角行列索引值；遍历数组：范围内，大则左移，小则下移，否则返回true；最后返回false。
  
 - ## 代码链接：
   - [二维数组中的查找](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/04_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 5. 替换空格
- ## 题目描述
  - 将一个字符串中的空格替换成 "%20"。
  - 示例：Input: "A B"；Output: "A%20B"

- ## 解题思路
  - 思路：库函数；可变字符串；原字符串倒序。
  - 分析：
    - 对于URL参数：无法识别特殊字符，故空格替换为"%20"，#替换为"%23"
    - 由于空格的一个字符变为三个字符，替换后变长，两种思路：创建新字符串和在原字符串修改。
  - 库函数：
    - 算法：直接返回replace后的字符串s。
    - 用String的函数：`replace(CharSequence target, CharSequence replacement)`
      - 使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。
      - target：要被替换的 char 值序列
      - replacement：char 值的替换序列
    - 在Python等语言中同样适用。但是解算法题用库函数显得投机取巧。
  - 可变字符串：
    - 复杂度：时间O(n), 空间O(n)
    - 算法：
      - 初始化一个可变字符串 StringBuilder ，记为 res ；
      - 将字符串s转为字符数组chars；
      - 遍历字符数组中的每个字符，并添加到res字符串：
        - 当 c 为空格时：向 res 后添加字符串 "%20"；
        - 当 c 不为空格时：向 res 后添加字符 c ；
      - 将 res 转化为 String 类型并返回。
    - 注：如果要求不能开辟额外空间时，这种方法就行不通了。
  - 原字符串倒序：
    - 复杂度：时间O(n), 空间O(k) -- k是空格数，空间复杂度小一点
    - 分析：
      - 原字符串修改且空间充足时：正遍历-多空格时，部分字符会移动多次，时间复杂度太高；逆遍历-O(n)
      - 首先计算空格数得到最终字符串末尾，P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。
      - P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。
      - 从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。
    - 算法：
      - 定义指针p1指向原有字符串的末尾：p1从末尾遍历原字符串；
      - 遍历字符串，每一个空格，添加两个空格到原字符串；
      - 定义指针p2指向增加两倍空格数之后的字符串的末尾：p2从末尾更新字符串，并添加`%20`到字符串中；
      - 循环：直到 -- 原字符串遍历完成(`p1>=0`) 或 更新后字符串追上原字符串(`p2>p1`)
        - 判断是否是空格
      - 返回toString()。
    - 注：
      - 当题目定义好的参数类型是StringBuilder时，可以用这种方法。如果是String，就不好用了，直接开辟新空间。
      - 本方法太别扭了，为了省一点空间，走了很多弯路。不如重新开辟空间后操作了。
  - 字符串知识点：
    - `str.length()`: 获取str长度
    - `str.charAt(i)`: 获取i处某值
    - `str.toCharArray()`: str字符串转换成字符数组
    - `str.setCharAt(i,'m')`: m赋值给i处 注：StringBuilder的方法
    - `str.append("abc")`: 在StringBuilder的字符串str后新增子串
    - `sb.toString()`: 将StringBuilder转换为String字符串
  - 注意：`str.charAt()`获取到的是字符型，用单引号；`str.setCharAt(int, char)`中Char的C大写

- ## 代码链接
  - [替换空格](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/05_%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.java)
  
<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 6. 从尾到头打印链表
- ## 题目描述
  - 从尾到头反过来打印出单链表的每个结点的值。

- ## 解题思路
  - ### 思路：栈; 递归; 两次遍历
  - ### 使用栈
    - 栈具有后进先出的特点，从第一个结点开始遍历后最后一个第一个输出，是典型的“后进先出”。
      - 注：返回值可以是int[]，也可以是ArrayList<>，最后定义为不同的容器即可。
    - 算法：
      - 新建栈；遍历链表并压栈直至尾结点为空；新建容器；遍历并弹栈直至栈空；返回容器。
      - 即：先入栈，然后弹栈至新容器。
    - 知识点：
      - 新建栈：`Stack<Integer> stack = new Stack<>();`
      - 压栈：`stack.add(i);`  弹栈：`stack.pop();`  栈空：`stack.isEmpty()==true;` 栈长度：`stack.size();`
      - java链表：`ListNode listnode`  取值：`listNode.val;`  下一值：`listNode.next;`
      - 容器：`ArrayList<Integer> ret = new ArrayList<>();`或者`int[] res = new int[stack.size()];`
    - 注意：
      - 使用栈Stack要加这句：`import java.util.Stack;`
      - 弹栈时：直接操作栈，不用关心链表结点了
  - ### 使用递归
    - 递归在本质上是一个栈结构，故可以考虑递归。
    - 先递归输出后面的结点，再输出该结点本身。
    - 思路：
      - 新建容器 -- 判断结点是否为空，空则调用本身并传入next结点，直到为空时打印，然后返回上一个函数调用并打印，直到最外层 -- 返回容器
    - 要逆序打印链表 1->2->3（3,2,1)，可以先逆序打印链表 2->3(3,2)，最后再打印第一个节点 1。
      而链表 2->3 可以看成一个新的链表，要逆序打印该链表可以继续使用求解函数，也就是在求解函数中调用自己，这就是递归函数。
    - 知识点：
      - add方法与addAll方法的区别：
        - Add方法是将传入的参数作为当前List中的一个item存储，即使传入一个List也只令当前的List增加1个元素
        - AddAll是传入一个List，将此List中的所有元素加入到当前List中，也就是当前List会增加的元素个数为传入的List的大小
        - `addAll(Collection c)`
        - `add(int index,Elelemt e)`
  - ### 两次遍历：
    - 评论区看到的一种思路：不用栈和递归的纯纯遍历
    - 步骤：
      - 第一次遍历链表：算出长度，并将node复原到head结点；
      - 第二次遍历链表：从数组末尾开始倒序依次存入正序的链表对应元素
    - 注意点：
      - 第一次遍历链表：正序遍历
      - 第二次遍历链表：正序遍历链表，倒序遍历数组 -- 与倒序存入对应
  - ### 使用头插法（未实践）
    - 使用头插法可以得到一个逆序的链表。
    - 头结点和第一个节点的区别：
       - 头结点是在头插法中使用的一个额外节点，这个节点不存储值；
       - 第一个节点就是链表的第一个真正存储值的节点。

- ## 代码链接
  - [从尾到头打印链表](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/06_%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.java)
 
<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->

  

# 7. 重建二叉树
- ## 题目描述
  - 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。
  - 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
  - 例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

- ## 解题思路
  - 分析：因为是树的结构，一般都是用递归来实现。
    - 用数学归纳法的思想就是，假设最后一步，就是root的左右子树都已经重建好了，那么只要考虑将root的左右子树安上去即可。
    - 根据前序遍历的性质，第一个元素必然就是root，那么下面的工作就是如何确定root的左右子树的范围。
    - 根据中序遍历的性质，root元素前面都是root的左子树，后面都是root的右子树。那么我们只要找到中序遍历中root的位置，就可以确定好左右子树的范围。
    - 正如上面所说，只需要将确定的左右子树安到root上即可。
    - 递归要注意出口，假设最后只有一个元素了，那么就要返回。  
  - 具体分析：
    - 前序遍历的首元素 为 树的根节点 node 的值。
    - 在中序遍历中搜索根节点 node 的索引 ，可将 中序遍历 划分为 `[ 左子树 | 根节点 | 右子树 ]` 。
    - 根据中序遍历中的左（右）子树的节点数量，可将 前序遍历 划分为 `[ 根节点 | 左子树 | 右子树 ]`
  - 算法：
    - 通过【前序遍历列表】确定【根节点 (root)】
    - 将【中序遍历列表】的节点分割成【左分支节点】和【右分支节点】
    - 递归寻找【左分支节点】中的【根节点 (left child)】和 【右分支节点】中的【根节点 (right child)】
  - 算法具体：
    - 递推参数： 根节点在前序遍历的索引 root 、子树在中序遍历的左边界 left 、子树在中序遍历的右边界 right ；
    - 终止条件： 当 left > right ，代表已经越过叶节点，此时返回 nullnull ；
    - 递推工作：
      - 建立根节点 node ： 节点值为 preorder[root] ；
      - 划分左右子树： 查找根节点在中序遍历 inorder 中的索引 i ；
        - 为了提升效率，本文使用哈希表 dic 存储中序遍历的值与索引的映射，查找操作的时间复杂度为 O(1)；
        - TIPS： i - left + root + 1 含义为 根节点索引 + 左子树长度 + 1
      - 构建左右子树： 开启左右子树递归；
    - 返回值：回溯返回 node ，作为上一层递归中根节点的左 / 右子节点；
  - 哈希表保存中序遍历细节：
    - 在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。
    - 考虑使用哈希表来快速地定位根节点。
    - 对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。
      - 在构造二叉树的过程之前，对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。在此后构造二叉树的过程中，我们就只需要 O(1) 的时间对根节点进行定位了
  - 知识点：
    - 
    - `Arrays.copyOfRange(T[ ] original,int from,int to)` ：将一个原始的数组original，从下标from开始复制，复制到下标to，生成一个新的数组。注意这里包括下标from，不包括下标to。
  - 注意：评论区说了，此题的解题技巧就是：背！！下！！来！！
 
 - ## 代码链接
   - [重建二叉树](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/07_%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.java)
  
<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


  
# 8. 二叉树的下一个结点
- ## 题目描述
  - 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。
  - 注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。
   
- ## 解题思路
  - 若该结点存在右子树：则下一个结点为右子树最左子结点；若没有左子结点，则下一个结点即该右子树的根结点本身
  - 若该结点不存在右子树，分两种情况： 
    - 1 该结点为父结点的左子结点，则下一个结点为其父结点
    - 2 该结点为父结点的右子结点，则沿着父结点向上遍历，直到找到一个结点，它是其父结点的左子结点，则该结点的父结点是下一个结点
  - 思路：判空则返回 -- 判断该结点的右结点是否为空，并分两类情况进行讨论
  - 注意：没有右子且不是其父的左子的情况比较复杂，但是代码体现比较简单，只是循环。
  
- ## 代码链接
  - [二叉树的下一个结点](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/08_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 9. 用两个栈实现队列
- ## 题目描述
  - 用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。

- ## 解题思路
  - “负负得正” 
  - 栈“先入后出”，而队列“先入先出”，可利用两个栈的两次“先入后出”使得最终顺序为“先入先出”
    - 具体地，一个元素进入栈1之后，出栈的顺序被反转。当元素要出栈时，需要先进入2栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。
  - 只在栈1入栈（push）操作，只在栈2出栈（pop）操作。
    - 入栈：即栈1入栈
    - 出栈：需要先对栈2判空，若非空，直接出；若空，需要从栈1弹出后栈2入栈，直到栈1空，此时第一个进栈的在栈2top，可以弹出；若全空，抛出异常或指定值。
  - 算法：
    - 声明；
    - new栈对象：栈1push，栈2pop；
    - 压栈：栈1直接压栈；
    - 弹栈：先判空，都空时抛出异常；否则，栈2空时先栈1pop进栈2。之后统一补一句栈2弹栈并返回pop值；
  - 知识点：
    - 使用栈要声明：`import java.util.Stack;`
    - 创建栈：`Stack<Integer> stackname = new Stack<Integer>();`
    - 压栈：stackname.push(val);
    - 弹栈：stackname.pop(); -- 弹栈会返回原栈顶值，可赋值给变量使用
    - 栈空：stackname.empty(); 空则true，否则false(注：isEmpty()也可以)

- ## 代码链接
  - [用两个栈实现队列](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/09_%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.java)
  
<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 10.1 斐波那契数列
- ## 题目描述
  - 现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）
  - f(0)=0; f(1)=1; f(n)=f(n-1)+f(n-2),n>=2
  - 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
  
- ## 解题思路
  - 方法：递归；循环(自下而上)；公式；查表法
  - 法1-递归：
    - 斐波那契数列属于典型的递归，但是用递归求解的话，过多重复，时间效率低。
    - 在若干次递归的过程中，对中间的无数小参数值进行了多次的重复计算，累计下来就太多了。
  - 法2：循环(自下而上)
    - 针对递归的问题，考虑用《循环+数组》实现递归，可以极大地提高时间效率。
    - 时间复杂度：O(n)
    - 第 i 项只与第 i-1 和第 i-2 项有关，因此只需要存储前两项的值就能求解第 i 项，从而将空间复杂度由 O(N) 降低为 O(1)。
    - 注意结果的范围：如果题目要求对结果取模的话
  - 法3：公式
    - 有一种转换为求矩阵的乘方，思考过多不作考虑。
    - 面试不适用，主要记公式并转换为代码，没什么逻辑思考
  - 法4：查表法
    - 将100内的斐波那契数列存放在数组或某容器中，然后直接获取
    - 在评论区看到的邪典解法 
  - 其他：可用动态规划
  - 注意：
    - 赋值前两项0和1即可，2也符合前两项和 
    - 如果结果不取模（对和的变量取模），那么需要定义为long，否则会超过int范围。
    - 取模需要在求和结果就取，如果到最后取模，而定义的变量是int型，中途可能会溢出范围。
  
- ## 代码链接
  - [斐波那契数列](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/10_1_%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 10.2 矩形覆盖
- ## 题目要求
  - 我们可以用2×1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2×1的小矩形无重叠地覆盖一个2×n的大矩形，总共有多少种方法？

- ## 解题思路
  - 被覆盖的大矩形是两行n列的（画示意图更明显，此处省略图）
  - n=1时：只有一种方法
  - n=2时：有横着覆盖和竖着覆盖两种方法
  - n>=2时：分为两种情况
    - 若第一个小矩形竖着，则剩余n-1个区域的覆盖方法记为f(n-1)
    - 若第一个小矩形横着，则它下方也应该横着填一个小矩形，则剩余n-2个区域的覆盖方法记为f(n-2)
    - 即f(n)=f(n-1)+f(n-2),n>=2
  - 综上，此问题可归结为斐波那契数列相同的问题。
  - 同上，依然是用循环来实现递归
  - 注意：首项和第二项与原斐波那契数列有不同。
  - 注意：代码初始化返回值时，要赋值，不能空着（比如int result;）会报错的。

- ## 代码链接
  - [矩阵覆盖](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/10_2_%E7%9F%A9%E9%98%B5%E8%A6%86%E7%9B%96.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 10.3 跳台阶
- ## 题目描述
  - 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
  - 力扣：答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

- ## 解题思路
  - 当n=0时：只有原地不动一种方法
  - 当n=1时：只有1种跳法
  - 当n=2时：有2种跳法 -- 一级一级跳两次或者一次跳两级
  - 当n>=2时：分为两种情况
    - 当第一次跳一级，则跳法数等于剩余台阶的跳法f(n-1)
    - 当第一次跳两级，则跳法数等于剩余台阶的跳法f(n-2)
    - 即f(n)=f(n-1)+f(n-2),n>=2
  - 综上，跳台阶问题可以归结为斐波那契数列问题。
  - 注意：初始化值与斐波那契数列略不同，n=0时为1

- ## 代码链接
  - [跳台阶](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/10_3_%E8%B7%B3%E5%8F%B0%E9%98%B6.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 10.4 变态跳台阶
- ## 题目描述
  - 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

- ## 解题思路之数学推导：
  - 跳上 n-1 级台阶，可以从 n-2 级跳 1 级上去，也可以从 n-3 级跳 2 级上去...，那么
    - f(n-1) = f(n-2) + f(n-3) + ... + f(0)
  - 同样，跳上 n 级台阶，可以从 n-1 级跳 1 级上去，也可以从 n-2 级跳 2 级上去... ，那么
    - f(n) = f(n-1) + f(n-2) + ... + f(0)
  - 综上可得：f(n) - f(n-1) = f(n-1)
  - 即：f(n) = 2×f(n-1) 是等比数列，1,2，公比2可用位移运算优化
  - 用位移运算，1<<(target-1)，非正情况另考虑，从1开始到n都是符合公式的。

- ## 代码链接
  - [变态跳台阶](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/10_4_%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 11. 旋转数组的最小数字
- ## 题目描述
  - 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
  - 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
  - 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
  - NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

- ## 分析与解题思路
  - 分析：
    - 问题求的是最小值
    - 与一般数组的区别：有排序
  - 思路：
    - 暴力最小值; 暴力非降序; 库函数排序; 二分+暴力; 二分

- ## 解题思路1：暴力搜索最小值
  - 虽然是面试官不愿意看到的废柴方法，但是牛客里可以ac，亲测....
  - 但是还是尽量不要这样做吧，除非没别的想法了
  
- ## 解题思路2：暴力搜索是否符合非降序
  - 在两段范围内都是非降序，当不符合这个规律时，就找到了最小数字
  
- ## 解题思路3：排序
  - 既然是找最小值，使用排序也是很常规的思路
  - 利用 Arrays 工具类里的排序函数，默认的排序规则是从小到大，排序后的数组第一个值就是最小值
  - 注意：需要import Arrays，干脆util.*
  - 排序的时间复杂度是O(nlogn)，比暴力法O(n)更慢了。
  
- ## 解题思路4：变相二分查找 -- 二分+暴力
  - 首先，因为有一定排序，故不能使用遍历整个数组，找出其中最小的数。(其实可以ac，亲测)
  - 因为有一定排序，故使用二分：
    - 大数组在前，小数组在后：大数组中的所有元素均大于等于小数组中的所有元素
    - 最小元素应该在大数组和小数组的交界处，且位于小数组的第一个
    - low，high分别指向数组的首尾，则low指向大数组，high指向小数组
    - 取mid=(low+high)/2
    - 若mid位于大数组，则大于等于low，最小值在mid后，故low向前移动到mid位置
    - 若mid位于小数组，则小于等于high，最小值在mid前，故high向后移动到mid位置
    - low和high不断向中间移动，最终将相邻，而high正好指向最小值，这是循环判停的条件：high-low==1，
  - 非递减，需要考虑相同数字的情况，比如数组 {1,1,1,0,1}
    - 对于不符合以上分类的情况
    - 此时无法用二分判断，故使用遍历方法暴力求解找到最小值
  - 注意：
    - mid初始化值为第一个元素。
    - 分类方式：大于等于和小于等于是符合规律的情况，首、中、尾元素相同是另一种情况。

- ## 解题思路5：二分
  - 遇到重复数字但不用暴力法的方法
    - 针对《中-右》重复的情况，采用j--的处理方式 
    - 注：`j--`是经过分类讨论验证正确性的，具体如下
    - 注2：按法4的正常思路没毛病，这里需要记忆了。
    - 注3：看评论区会有例子不能通过此方法，慎用。 
  - 算法：
    - 定义双指针分别指向数组的头i和尾j；
    - 循环：当i<j时
      - 二分为mid
      - `nums[mid]>nums[j]`时：说明mid位于大数组，而最小值会在[mid+1，j]内，因此更新`i=mid+1;`
        - 注意这里是mid+1，如果mid会报错 (当left=right时死循环了) 
      - `nums[mid]<nums[j]`时：说明mid位于小数组，而最小值会在[i,mid]内，因此更新`j=mid;`
      - `nums[mid]==nums[j]`时：`j--;`
    - 当i=j时，返回`numbers[i]`
      - 注意：返回的是numbers[i], 不是mid对应元素。当不符合循环条件时不进入循环体求本次的mid，mid可能还是上一次的 
 - 注意：
   - 本方法的返回值是numbers[i], 而不是numbers[mid] ！！！
   - `nums[mid]==nums[j]`时：`j--;`的合理性：
     - 若mid位于小数组中，则表明小数组中从mid到j的所有元素相等，因此j--会抛弃一个重复元素，因此最小值仍在[i,j]；
       - 例如：[1, | 0,1,1,1]。
     - 若mid位于大数组中，而j位于小数组，则`min <= numbers[j] == numbers[m]`
       - 若`min < numbers[j]`，则j的左侧有更小的元素，因此j--后最小值仍在[i,j]中。例如：[1,1,1, | 0,1]。
          - 注：升序，故最右边的应该是大数，从最右侧开始抛弃。       
       - 若`min == numbers[j]`，分情况讨论均符合，大概是最小值有多个的情况，j--以后，仍然可以从剩余最小值中找到。
   - 是否可以用 numbers[m] 和 numbers[i] 比较做代替？
     - 不可以。因为做比较的目的是判断 m 在哪个排序数组中。
     - 但在 numbers[m] > numbers[i]情况下，无法判断 m 在哪个排序数组中。
     - 本质是因为 j 初始值肯定在右排序数组中； i 初始值无法确定在哪个排序数组中。

- ## 注：
  - 本题没有判空，大概是考点不在此处？
  - 考点1：整个数组旋转的情况，即顺序数组，整体旋转后，仍然是顺序数组；
  - 考点2：存在重复数字的情况，例如[0,1,1,1,1]旋转后得到[1,0,1,1,1]或[1,1,1,0,1]
  - 结果变量的初始化值：设为第一个元素的值，即考虑整个数组旋转的情况，此时仍为原数组，最小值是升序数组的第一个元素。

- ## 代码链接
  - [旋转数组的最小数字](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/11_%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 12. 矩阵中的路径
- ## 题目描述
  - 请设计一个函数，用来判断在一个矩阵中**是否**存在一条包含某字符串所有字符的路径。
  - 路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。
  - 如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 
  - 例如 a b c e s f c s a d e e 矩阵中包含一条字符串"bccced"的路径，但是矩阵中不包含"abcb"路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。
  - 注意：传入的是一维矩阵，行数，列数，目标str

- ## 解题思路1：DFS 深度优先遍历
  - 本问题是典型的矩阵搜索问题，可使用《深度优先搜索（DFS）+ 剪枝》解决。
    - 深度优先搜索：
      - 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。
    - 剪枝：
      - 在搜索中，遇到 “这条路不可能和目标字符串匹配成功” 的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 “可行性剪枝”
  - DFS 解析：
    - 递归参数： 
      - 当前元素在矩阵 board 中的行列索引 i 和 j ，当前目标字符在 word 中的索引 k 。
    - 终止条件：
      - 返回 false ： (1) 行或列索引越界 或 (2) 当前矩阵元素与目标字符不同 或 (3) 当前矩阵元素已访问过 （ (3) 可合并至 (2) ） 。
      - 返回 true ： k = len(word) - 1 ，即字符串 word 已全部匹配。
    - 递推工作：
      - 标记当前矩阵元素： 将 board[i][j] 修改为 空字符 '' ，代表此元素已访问过，防止之后搜索时重复访问。
      - 搜索下一单元格： 朝当前元素的 上、下、左、右 四个方向开启下层递归，使用 或 连接 （代表只需找到一条可行路径就直接返回，不再做后续 DFS ），并记录结果至 res 。
      - 还原当前矩阵元素： 将 board[i][j] 元素还原至初始值，即 word[k] 。
    - 返回值： 返回布尔量 res ，代表是否搜索到目标字符串。
    - 注意：
      - 使用空字符（Python: '' , Java/C++: '\0' ）做标记是为了防止标记字符与矩阵原有字符重复。当存在重复时，此算法会将矩阵原有字符认作标记字符，从而出现错误。
      - 递归之后：占用的空串位置释放，赋原值
  - 代码步骤：
    - 将目标word转为字符数组；
    - 遍历数组：从每一个位置作为入口尝试与目标word匹配，并在具体位置调用dfs()函数
      - 二维数组：用i，j遍历
      - dfs：以当前i-j位置，和word的初始位置开始匹配
        - 这里dfs放在if里，而不是直接return，因为要遍历所有，而不是中途判断是否有false
      - 遍历数组之外需要补充匹配失败的情况：遍历二维数组后没有符合的情况存在，则返回false
        - 这里不能少，否则会存在没有返回值返回的情况 
    - dfs(char[][] board, char[] word, int i, int j, int k)
      - char[][] board: 二维数组
      - char[] word：目标字符串word
      - i，j: 入口
      - k：word中的当前字符指针
    - dfs()函数的步骤：
      - 判断几种不符合的情况：超出四个边界或与word中k对应的字符不匹配，则返回false
        - 注意：大于等于length-1的等于号即属于不符合的情况 
      - 判断递归出口：如果已经达到word的最后，且没有被上一步判false，则返回true
      - 前两步都不符合：开始进入深度遍历，先将此时二维数组的i-j锁定，即赋空值
      - 设置布尔型res变量，对i-j四个方向进行递归dfs()函数的判断，一真即真
      - 回退一格：将二维数组的i-j重新赋值为原值，即word[k]对应的值 (判断了对应才会赋空值并深度遍历)
      - 返回res的值
  - 知识点：
    - str.toCharArray()：字符串转为字符数组
    - 几处判断为短路双与：一真即真，只要找到一种匹配情况即可

- ## 解题思路2：回溯法
  - 官方解法：回溯法（backtracking）进行求解，它是一种暴力搜索方法，通过搜索所有可能的结果来求解问题。
  - 回溯法在一次搜索结束时需要进行回溯（回退），将这一次搜索过程中设置的状态进行清除，从而开始一次新的搜索过程。
  - 思路
    - 0.根据给定数组，初始化一个标志位数组，初始化为false，表示未走过，true表示已经走过，不能走第二次
    - 1.根据行数和列数，遍历数组，先找到一个与str字符串的第一个元素相匹配的矩阵元素，进入judge
    - 2.根据i和j先确定一维数组的位置，因为给定的matrix是一个一维数组
    - 3.确定递归终止条件：越界，当前找到的矩阵值不等于数组对应位置的值，已经走过的，这三类情况，都直接false，说明这条路不通
    - 4.若k，就是待判定的字符串str的索引已经判断到了最后一位，此时说明是匹配成功的
    - 5.下面就是本题的精髓，递归不断地寻找周围四个格子是否符合条件，只要有一个格子符合条件，就继续再找这个符合条件的格子的四周是否存在符合条件的格子，直到k到达末尾或者不满足递归条件就停止。
    - 6.走到这一步，说明本次是不成功的，我们要还原一下标志位数组index处的标志位，进入下一轮的判断。

- ## 代码链接
  - [矩阵中的路径](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/12_%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 13. 机器人的运动范围
- ## 题目描述
  - 地上有一个m行和n列的方格。
  - 一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 
  - 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。
  - 请问该机器人能够达到多少个格子？

- ## 解题思路
  - 深度优先搜索（Depth First Search，DFS），思路可参考上题
    - 本题没有上一题复杂，只需要从(0,0)点开始进行一次dfs即可
    - 本题的搜索方向：只需要向下和向右即可
      - 根据可达解的结构和连通性，易推出机器人可 仅通过向右和向下移动，访问所有可达解 。
        - 三角形内部： 全部连通，易证；
        - 两三角形连通处： 若某三角形内的解为可达解，则必与其左边或上边的三角形连通（即相交），即机器人必可从左边或上边走进此三角形。 
    - 本题多了求各位数之和的与k值比较的步骤
      - `1 <= n,m <= 100`，因此 mn是两位数，即如果取边界值100，再减1，仍然是两位数
  - 代码步骤：
    - 定义与二维数组大小相同的标记数组：用来标记某一格是否符合k值条件
    - 从(0,0)位置开始，作为入口调用dfs()函数
      - dfs(int i, int j, int m, int n, int k, boolean[][] visited)
      - 参数：当前坐标i和j，边界坐标m和n，k值，标记数组visited 
    - dfs()函数的步骤：
      - 判false：四个边越界 或 不符合k值条件 或 已判断过本格不符
        - 注意返回值是int，一步都没有前进，则返回0
      - 如果没有在上一步排除，则标记为可以前进格
      - 返回结果：1 + 向下或向右两个方向移动的递归
        - 注意：需要+1，把当前匹配的格子也计算在内。

- ## 代码链接
  - [机器人的运动范围](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/13_%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 14.1 剪绳子
- ## 题目描述
  - 把一根长度为n的绳子剪成多段(大于一段)，并且使得每段的长度乘积最大（n为整数，n>1）
  - n = 2， return 1 (2 = 1 + 1)
  - n = 10， return 36 (10 = 3 + 3 + 4)

- ## 解题思路
  - ### 贪心：
    #### 每一步都做一个贪婪的选择，基于这个选择，可以得到最优解。一般需要数学方式证明贪婪选择的正确性。
    - 尽可能多剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现。
    - 如果出现了，就从已经切好长度为 3 的绳子中拿出一段与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。
    - 证明：
      - 当 n >= 5 时，3(n - 3) - n = 2n - 9 > 0，且 2(n - 2) - n = n - 4 > 0。
      - 因此在 n >= 5 的情况下，将绳子剪成一段为 2 或者 3，得到的乘积会更大。
      - 又因为 3(n - 3) - 2(n - 2) = n - 5 >= 0，所以剪成一段长度为 3 比长度为 2 得到的乘积更大。
    - 注：
      - 贪心：偏数学题算法，数学思路走通以后代码实现即可。
      - 定n>1,m>1，故dp[1]可0可1 (leetcode的测试用例中dp[1]为1)；为方便循环计算，可设为1
      - pow() 方法用于返回第一个参数的第二个参数次方。
        - double pow(double base, double exponent) -- 返回值类型默认为double型，而题目要求的是int型，强转为int
  - ### 动态规划：
    - 分析发现符合dp的问题特征：
      - 求一个问题的最优解； 
      - 整体的问题的最优解是依赖于各个子问题的最优解； 
      - 小问题之间还有相互重叠的更小的子问题； 
      - 从上往下分析问题，从下往上求解问题；
    - 不用过多分析，将问题无脑分解为更小的问题。
      - 从小到大，依次计算所有可能解并保存在数组中，直到计算到target为止。
    - 思路：
      - dp[i] 表示长度为i的绳子剪成m段后的最大乘积。
      - 初始化dp[2] = 1 表示如果一个绳子长度为2必然只能分成两段长度为1的绳子，两者的乘积为1。 
      - 然后尝试对绳子进行分割，如果只剪掉长度为1，对最后的乘积无任何增益，所以从长度为2开始剪，代码中的j就是表示尝试剪的长度。 
      - 剪下一段后，剩余部分可以剪也可以不剪。
        - 如果不剪则得到的长度乘积为 j * (i - j) 。
        - 如果剪得到的长度为j * dp[i - j]
        - 两者取最大值 
      - 不断修改剪的长度j （j范围为[2, i -1]）。
      - 从所有结果中找到最大值即为dp[i]的结果。 
      - 从而有状态转移方程dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))    
    - 注意：
      - i/2的略微优化没成，就暂时先这样吧..
      - dp[i]的值包含的内容（包括两个嵌套的Math.max()）需要缕清楚，别写错写漏了
  
- ## 代码链接
  - [剪绳子](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/14_1_剪绳子.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 14.2 剪绳子进阶
- ## 题目描述
  - 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m] 。
  - 请问 `k[0]*k[1]*...*k[m]` 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
  - 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
  - 示例 1：
    - 输入: 2
    - 输出: 1
    - 解释: 2 = 1 + 1, 1 × 1 = 1
  - 示例 2:
    - 输入: 10
    - 输出: 36
    - 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
  - 提示：2 <= n <= 1000
  
- ## 解题思路
  - 贪心
    - 注：因需要取模，不能用dp
  - 分析：
    - 本题与上一题的区别：需要对答案进行取模 
      - 因为n的取值范围变大了，可能超出变量范围。 
    - 每步取模
  - 算法：
    - 先处理2和3等特殊值；
    - 初始化long res = 1；
    - while循环：当n>4
      - 更新res，取模；
      - 更新n；
    - 返回res：与res与最终的n相乘，然后取模，然后强转为int。

- ## 代码链接
  - [剪绳子](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/14_2_剪绳子进阶.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 15. 二进制中 1 的个数
- ## 题目描述
  - 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

- ## 解题思路
  - 常规思路：
    - 右移+与1+count计数。
    - 注：与运算结果分为不为0（即1）和为0，故可放在if中作为判断条件。
    - 缺点：负数时最高位的问题。
  - 改进思路：
    - 既然右移数字不成，就左移flag1，之后和给定数字做与运算。
    - 不足：数字的二进制有多少位就需要循环多少次
  - 技巧思路：
    - n=(n-1)&n，当n不为0时，继续循环
    - 时间复杂度：O(M)，其中 M 表示 1 的个数。比上述改进思路稍快。
    - 小结论：把一个整数-1，并和自己做位与运算，相当于把最右边的1变成0.
      - 注：一个整数减去1，相当于把最右边的1变成0的同时，当1的右侧还有0，则把所有0变成1.例如，1100-1=1011. 1100&1011=1000.
  - 调用函数 Integer.bitCount()
    - 计算一个（byte,short,char,int统一按照int方法计算）int,long类型的数值在二进制下“1”的数量。
- ## 代码链接
  - [二进制中1的个数](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/15_%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 16. 数值的整数次方
- ## 题目描述
  - 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。
  - 保证base和exponent不同时为0

- ## 解题思路
  - 乘方功能，即实现类似pow()函数的功能
    - 注：double pow(double base, double exponent) -- 返回值类型默认为double型，可根据题目要求进行强转
    - 一行代码：`return Math.pow(base,exponent);`
  - 使用公式递归
    - n=奇数时，a^n=a^(n/2) × a^(n/2);
    - n=偶数时，a^n=a^((n-1)/2) × a^((n-1)/2) × a;
    - 代码中不需要减1的操作，因为会自动取整，结果一样
  - 注意：
    - 考虑指数的特殊情况：为1时返回base，为0时返回1.
    - 考虑指数是负数的情况：设置标志，先把指数取相反数变为正数，用公式计算，最后求结果的倒数（当标志为真时）
    - 可以考虑：用右移代替除以2，用与1运算代替整除取余%，可提高运算效率。
    
- ## 代码链接
  - [数值的整数次方](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/16_%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 17. 打印从 1 到最大的 n 位数
- ## 题目描述
  - 输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。
  - 比如输入 3，则打印出 1、2、3 一直到最大的 3 位数即 999。

- ## 解题思路
  - 思路：不考虑大数问题；考虑大数问题
  - 不考虑大数问题：返回int[]数组。
    - 直接遍历：n为1时，10的1次方为10，10-1是9，从1遍历到9.
    - 定义10的n次方得到最大值；
    - 定义数组来存储这些值；
    - 从1开始遍历并将这些数存入结果数组；
    - 返回结果数组。
  - 考虑大数问题：依次打印符合的值。
    - 这样考虑的话，其实不简单。
    - 由于n可能会非常大，因此考虑“大数问题”，不能直接用int表示数字，而是用char数组或者字符串进行存储。
    - 如果累加，计算量大，效率不高，代码冗长；考虑把问题转换成数字排列，每一位从0-9排列一遍，即可得到结果。
    - 代码终止条件为：当位数增加到等于数组长度时，相当于已经达到最大值，可以停止了。
    - 使用回溯法得到所有的数。
      - 注意：回溯法一定要注意设置好终止条件。
    - 打印时需要考虑不能前非零数字前的0也打印出来。
    - 因为有回溯，所以另外定义函数，方便调用。
    - 算法：
      - 主体函数：边界值(<=0)；定义char数组；调用同名函数，从0开始。
      - 同名函数：
      - 打印数字：
    - 未完待续，真的很难。
      
- ## 代码链接
  - [打印从1到最大的n位数](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/17_打印从1到最大的n位数.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 18.1 在 O(1) 时间内删除链表节点
- ## 题目描述
  - 时间复杂度O(n)的删除节点：
    - 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。
    - 返回删除后的链表的头节点。
    - 注意：此题对比原题有改动
    - 示例 1:
      - 输入: head = [4,5,1,9], val = 5
      - 输出: [4,1,9]
      - 解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
    - 示例 2:
      - 输入: head = [4,5,1,9], val = 1
      - 输出: [4,5,9]
      - 解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.
  - 时间复杂度O(1)的删除节点：
    - 给定单向链表的头指针和一个要删除的节点，定义一个函数删除该节点。
    - 返回删除后的链表的头节点。
    - 注意：这是剑指offer原题，可以在时间复杂度1内实现。
- ## 解题思路
  - 时间复杂度n：双指针
    - 分析：
      - 设节点 cur 的前驱节点为 pre ，后继节点为 cur.next ；
      - 执行 pre.next = cur.next ，即可实现删除 cur 节点。
    - 算法：
      - 特例处理： 当应删除头节点 head 时，直接返回 head.next 即可。
      - 初始化： pre = head , cur = head.next 。
      - 定位节点： 当 cur 为空 或 cur 节点值等于 val 时跳出。
      - 保存当前节点索引，即 pre = cur 。
      - 遍历下一节点，即 cur = cur.next 。
      - 删除节点： 执行 pre.next = cur.next 。
      - 返回值： 返回链表头部节点 head 即可。
  - 时间复杂度1：
    - 原题给了需要删除节点的指针，所以才能实现时间复杂度O（1）
    - 分析：
      - 因为给定了要删除的节点，因此不需要遍历，可以直接定位该节点。
      - 删除时为了不丢失next节点的信息，分为尾结点和非尾结点进行讨论。
      - 如果该节点不是尾节点，那么直接将下一个节点的值赋给该节点，然后令该节点指向下下个节点，再删除下一个节点，时间复杂度为 O(1)。
      - 否则，就需要先遍历链表，找到节点的前一个节点，然后让前一个节点指向 null，时间复杂度为 O(N)。
        - 注意：next为null有两种情况，一是尾结点，一是整个链表只有这一个结点，分类讨论。
      - 综合算下来，时间复杂度仍是O(1)，符合题目要求。
    - 算法：
      - 判空：头结点和删除结点，任一为null，则返回null；
      - 判断非尾结点：定义next结点，将next的值赋值给删除结点，然后将删除结点的next更新为next的next；
      - 如果删除结点的next为null，分类讨论：
        - 整个链表只有一个结点的情况：头结点等于删除结点，则将头结点指向null，即删除链表中的唯一结点；
        - 如果删除结点是尾结点，则定义指针cur，并遍历链表，直到cur的next为删除结点，然后将cur的next更新为null。
      - 删除完成后，返回头结点head。
      
- ## 代码链接
  - [在O(1)时间内删除链表节点](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/18_1_在O(1)时间内删除链表节点.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 18.2 删除链表中重复的结点
- ## 题目描述


- ## 解题思路


- ## 代码链接




<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 19. 正则表达式匹配
- ## 题目描述


- ## 解题思路


- ## 代码链接





<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->




# 20. 表示数值的字符串
- ## 题目描述


- ## 解题思路


- ## 代码链接





<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 21. 调整数组顺序使奇数位于偶数前面
- ## 题目描述
  - 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。
  - 示例：
    - 输入：nums = [1,2,3,4]
    - 输出：[1,3,2,4] 
    - 注：[3,1,2,4] 也是正确的答案之一。
  - 提示：
    - 1 <= nums.length <= 50000
    - 1 <= nums[i] <= 10000

- ## 解题思路
  - 思路：双指针
  - 复杂度：时间O(n)，空间O(1)
  - 分析：
    - 考虑定义双指针 i , j 分列数组左右两端，循环执行：
    - 指针 i 从左向右寻找偶数；
    - 指针 j 从右向左寻找奇数；
    - 将 偶数 nums[i] 和 奇数 nums[j] 交换。
    - 可始终保证： 指针 i 左边都是奇数，指针 j 右边都是偶数 。
  - 算法：
    - 边界值判断：对于空指针和数组长度为0的情况，直接返回。(注：本题题目规定了范围所以这一步可以省略)
    - 初始化： i , j 双指针，分别指向数组 nums 左右两端；
    - 循环交换： 当 i=j 时跳出；
      - 指针 i 遇到奇数则执行 i=i+1 跳过，直到找到偶数；
      - 指针 j 遇到偶数则执行 j=j−1 跳过，直到找到奇数；
      - 交换 nums[i] 和 nums[j] 值；
    - 返回值： 返回已修改的 nums 数组。
    - 注：
      - 两指针移动时，也需要满足小指针小于大指针，即i<j需要三处判断。
      - 两指针移动时，循环用while，不是用if，if的话只进行一次判断，不行的。
      - ==的优先级高于&&，因此需要加括号，不清楚优先级的一律加括号。
  - 注：奇偶性判断
    - 常规：整除2取余 -- 常规数学思维
    - 位运算：与1 -- 二进制的奇数最低位是1，偶数最低位是0，可通过和数字1做与运算n&1得出数字n的奇偶性。

- ## 代码链接
  - [调整数组顺序使奇数位于偶数前面](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/21_调整数组顺序使奇数位于偶数前面.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 22. 链表中倒数第 K 个结点
- ## 题目描述
  - 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。
  - 示例：
    - 给定一个链表: 1->2->3->4->5, 和 k = 2.
    - 返回链表 4->5.

- ## 解题思路
  - 思路：快慢指针
  - 复杂度：时间O(n)，空间O(1)
  - 分析：
    - 判空：当链表为空或者k为0时，所求结点不存在，因此返回空；
    - 逆推：两个指针，快指针指向尾结点后的null时，慢指针指向所求，则两指针间隔为k不变
    - 因此：先构建k的距离，然后同时走，当快指针指向null时，慢指针即为所求。
    - 算法实现：快指针先走k步，然后快慢指针同时走，直到快指针指向null，这时返回慢指针对应的结点。
  - 算法：
    - 判空：当链表为空或者k为0时返回空；
    - 初始化快慢指针；
    - 构建k的距离：循环实现，并判断，当快指针为null时，返回null(针对于k大于结点数的情况)
    - 双指针共同移动，直到快指针指向null，则返回慢指针对应结点。
  - 其他方法：数学思想
    - 先遍历统计链表长度，记为 n ；设置一个指针走 (n−k) 步，即可找到链表倒数第 k 个节点。
    - 缺点：两次遍历，用上述方法一次遍历即可达成。
  - 注意：剑指原书指出，本题关于鲁棒性的考点
    - 链表为空：返回空
    - k为0：返回空
    - 如果k大于链表节点数：返回空。
      - 在快指针走时进行判断：`if(former == null) return null;`
    
- ## 代码链接
  - [链表中倒数第 K 个结点](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/22_链表中倒数第K个结点.java)
 
<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 23. 链表中环的入口结点
- ## 题目描述


- ## 解题思路


- ## 代码链接




<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 24. 反转链表
- ## 题目描述
  - 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。
  - 示例: 输入: 1->2->3->4->5->NULL，输出: 5->4->3->2->1->NULL
  - 限制：0 <= 节点个数 <= 5000

- ## 解题思路
  - 思路：迭代；递归
    - 注：配合图示理解效果更佳。
    - 注意：链表要特别注意结点存储的顺序，防止把链子断了。
  - 迭代：
    - 复杂度：时间O(n)，空间O(1)
    - 分析：用双指针，实现每两个链表结点之间反转，以达到整体反转链表的目的。
      - 其实用到三个指针，因为在两个结点反转的时候，需要把cur存起来，防止丢失next信息使得链表断开。
    - 算法：
      - 定义双指针：当前指针cur指向当前结点，前指针pre指向当前结点的前一个结点；
      - 循环：当cur不指向null时遍历链表
        - 定义临时结点tmp，将cur的next结点信息存在tmp中；
        - 将cur的下个结点指向pre，完成反转；
        - 将pre和cur往后移动一个结点：pre赋值为cur，cur赋值为tmp（此时，pre与cur直接断开了，但是下个循环就会连起来）；
        - 注：循环到最后，cur会赋值为尾结点指向的null，这时pre是最后一个不为空的结点，并且和cur不连接，可以作为返回值。
      - 返回结果pre。
    - 注：本方法自带判空，也可以处理单个结点的链表。
  - 递归：
    - 复杂度：时间O(n)，空间O(n)
    - 分析：
      - 递归的两个条件：
        - 终止条件是当前节点或者下一个节点==null
        - 在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 递归函数那句：`head.next.next = head;`
        - 不好理解，其实就是 head 的下一个节点指向head：相当于head与head.next和head形成了一个环。
      - 递归函数中每次返回的 cur 其实只最后一个节点，在递归函数内部，改变的是当前节点的指向。
    - 算法：
      - 判空：当head为空，或者仅有一个结点时，返回head本身；
      - 递归：结点cur赋值为head.next的反转链表结果，这句会一直dfs到末尾，然后开始返回；
        - 把head看做一个结点，把剩余结点并且已经调用过反转函数的返回值看做cur。
      - 形成环：将head.next的下一个结点赋值为head，即将head.next连接到head；
      - 切断head与head.next的连接；
      - 最后返回cur：cur是尾结点。
    
- ## 代码链接：
  - [反转链表](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/24_反转链表.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 25. 合并两个排序的链表
- ## 题目描述
  - 输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。
  - 示例1：输入：1->2->4, 1->3->4；输出：1->1->2->3->4->4
  - 限制：0 <= 链表长度 <= 1000

- ## 解题思路
  - 思路：递归；迭代
  - 递归：
    - 边界：当任一链表为null时，直接返回剩余链表（即返回非空链表）
      - 注：这里包括当两链表都是null的情况，因为仍然会返回其一。
    - 比较：将两个链表中头部较小的一个，与剩下元素的 merge 操作结果合并，最终返回此链表
      - 当list1[0]<list2[0]时：list1[0] + merge(list1[1:], list2)，并返回list1
      - 否则（包含等于情况）：list2[0] + merge( list1l, list2[1:])，并返回list2
    - 递归的复杂度分析：
      - 时间复杂度：O(m+n)
      - 空间复杂度：O(m+n)
  - 迭代
    - 顺序迭代的思路
    - 设定一个哨兵节点 "prehead" （以便在最后比较容易地返回合并后的链表）
    - 维护一个 prev 指针，并调整它的 next 指针
    - 重复以下过程，直到 l1 或者 l2 指向了 null ：
      - 如果 l1 当前位置的值小于等于 l2 ，把 l1 的值接在 prev 节点的后面，同时将 l1 指针往后移一个。
      - 否则，对 l2 做同样的操作。
      - 不管将哪一个元素接在了后面，都把 prev 向后移一个元素。
    - 最后加一步对于空链表的分析，并返回prehead
    - 迭代的复杂度分析：
      - 时间复杂度：O(m+n)
      - 空间复杂度：O(1)
  - 链表相关使用：
    - 链表结点：ListNode l1, ListNode l2 -- 头结点的位置
    - 判空：直接结点名与null比较 `l2 == null;`
    - 结点对应的值：`l1.val` -- 结点l1对应的值
    - 下一个结点：`l1.next` -- 结点1的下一个结点
    - 新建一个哨兵结点保存整个组合链表的地址，最后prehea.next方便返回最终值：`ListNode prehead = new ListNode(-1);`
      - `ListNode list=new ListNode()` ：初始化一个空节点，无值,不提倡此种写法。
      - `ListNode list=new ListNode(0)`：初始化一个节点值为0的空节点，最常用最正规写法
      - `ListNode list=null`：为空，什么都没有，一般不这么写；
      - 注：参数为结点值

- ## 代码链接：
  - [合并两个排序的链表](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/25_合并两个排序的链表.java)
  
<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 26. 树的子结构
- ## 题目描述


- ## 解题思路


- ## 代码链接




<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 27. 二叉树的镜像
- ## 题目描述
  - 请完成一个函数，输入一个二叉树，该函数输出它的镜像。
  - 示例 1：
    - 输入：root = [4,2,7,1,3,6,9]
    - 输出：[4,7,2,9,6,3,1]
  - 限制：0 <= 节点个数 <= 1000

- ## 解题思路
  - 思路：递归；循环
  - 递归：
    - 复杂度：时间O(n), 空间O(n)
    - 分析：先序遍历，并交换每个节点的左右子树，交换时递归；当root为null时，结束遍历并返回
    - 算法：
      - 判空：root为null时，返回null；
      - 交换root的左右子树，并递归；
        - 注1：交换和递归可以分开，也可以合起来；
        - 注2：root为叶子节点时，也符合，递归时，root为空，停止递归并返回；
      - 返回结果root。
  - 循环实现：
    - 复杂度：时间O(n), 空间O(n)
    - 分析：利用栈（或队列）遍历树的所有节点 node ，并交换每个 node 的左 / 右子节点。
    - 算法：
      - 判空：root为空时，返回null
      - 初始化栈，并将root根节点添加到栈；
      - 循环：当栈不为空时，循环
        - 弹出栈顶结点，并赋值给node变量，
        - 添加子节点：将弹出结点的左右子树入栈 -- 注意判空：当子树不为空时入栈；
        - 交换node结点的左右子树 -- 注：此处不必判空，叶子节点的两个子树null和null交换也没问题，不必特意加判空，增加代码复杂性；
      - 返回结果root
      - 注：栈相当于保存结点的名字，并设置一定的修改顺序，交换子节点的效果是直接反映在原二叉树里的。
  - 栈的知识点：
    - 初始化并添加元素：`Stack<TreeNode> stack = new Stack<>() {{ add(root); }};`，不过最好分开写。
    - 压栈弹栈：push，pop；add也可以添加元素。
    
- ## 代码链接
  - [二叉树的镜像](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/27_二叉树的镜像.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 28. 对称的二叉树
- ## 题目描述
  - 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。
  - 示例 1：
    - 输入：root = [1,2,2,3,4,4,3]
    - 输出：true
  - 示例 2：
    - 输入：root = [1,2,2,null,3,null,3]
    - 输出：false
  - 限制：0 <= 节点个数 <= 1000

- ## 解题思路
  - 思路：递归；迭代
  - 递归
    - 复杂度：时间O(n)，空间O(n)
    - 如果一个树的左子树与右子树镜像对称，那么这个树是对称的。
    - 如果同时满足下面的条件，两个树互为镜像：
      - 它们的两个根结点具有相同的值。
      - 每个树的右子树都与另一个树的左子树镜像对称。
    - 定义镜像函数：
      - 判空：全空；一空一不空；
      - 根结点相等时，返回调用本体判断（结点1的左和结点2的右）以及（结点1的右和结点2度左）；
      - 注：借鉴100题的递归优化方法先判全空，后判根结点值相等，最后false这种设置可能用空指针异常，判相等一定记得 && 全不空
    - 算法：
      - 主体函数：判空；调用镜像函数。
      - 镜像函数：参数(root,root)
        - 判空：全为空时，返回true；
        - 判符合：当全不为空，且结点值相等时，返回子节点调用：注意左左对右右，左右对右左。
        - 否则：返回false。    
  - 迭代
    - 复杂度：时间O(n)，空间O(n)
    - 利用队列进行迭代。队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像。最初，队列中包含的是 root 以及 root。该算法的工作原理类似于 BFS，但存在一些关键差异。每次提取两个结点并比较它们的值。然后，将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束
     - 注：代码太多了，用递归就好

- ## 代码链接
  - [对称的二叉树](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/28_对称的二叉树.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 29. 顺时针打印矩阵
- ## 题目描述
  - 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。
  - 示例 1：
    - 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
    - 输出：[1,2,3,6,9,8,7,4,5]
  - 示例 2：
    - 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
    - 输出：[1,2,3,4,8,12,11,10,9,5,6,7]
  - 限制：
    - 0 <= matrix.length <= 100
    - 0 <= matrix[i].length <= 100

- ## 解题思路
  - 思路：模拟，设定边界
  - 分析：
    - 判空：当数组长度为0时，返回new int[0]; -- 注：本题规定了取值范围，因此判空可以省略。
    - 顺时针打印矩阵的顺序是 “从左向右、从上向下、从右向左、从下向上” 循环。
    - 因此，考虑设定矩阵的“左、上、右、下”四个边界，模拟以上矩阵遍历顺序。
  - 算法：
    - 复杂度：时间O(mn), 空间O(1) -- m、n为矩阵的行列数。
    - 判空：当数组长度为0时，return new int[0];；
    - 初始化四个边界，以及结果数组的索引值；
    - 初始化结果数组res；
    - 循环：死循环，跳出控制在循环体内。
      - 按照“从左向右、从上向下、从右向左、从下向上” 的顺序遍历，同时更新各个指标的值。
      - 用for循环完成一条边的遍历：注意循环起始位置是某一边界值；
      - 每次遍历完一条边之后，都要进行判断，当边界交错时，break跳出循环。
    - 返回结果数组res。
  - 注意：
    - 代码中运用大量自增自减，保持头脑清醒，注意是++--在前还是在后。
    
- ## 代码链接
  - [顺时针打印矩阵](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/29_顺时针打印矩阵.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 30. 包含 min 函数的栈
- ## 题目描述
  - 设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。
  - push(x) -- 将元素 x 推入栈中。
  - pop() -- 删除栈顶的元素。
  - top() -- 获取栈顶元素。
  - getMin() -- 检索栈中的最小元素。
  - 示例:
    ```
    MinStack minStack = new MinStack();
    minStack.push(-2);
    minStack.push(0);
    minStack.push(-3);
    minStack.getMin();   --> 返回 -3.
    minStack.pop();
    minStack.top();      --> 返回 0.
    minStack.getMin();   --> 返回 -2.
    ``` 
    
- ## 解题思路
  - 注：本题重点是getMin()，因此可以考虑借用现成栈实现，相当于重写功能
  - 思路：两个栈；一个栈；不借用栈
  - 两个栈：
    - 用两个栈，一个栈去保存正常的入栈出栈的值，另一个栈去存最小值，也就是用栈顶保存当前所有元素的最小值。
    - 存最小值的栈的具体操作流程如下：
      - 将第一个元素入栈。
      - 新加入的元素如果大于栈顶元素，那么新加入的元素就不处理。
      - 新加入的元素如果小于等于栈顶元素，那么就将新元素入栈。
      - 出栈元素不等于栈顶元素，不操作。
      - 出栈元素等于栈顶元素，那么就将栈顶元素出栈。
  - 一个栈：
    - 只用一个变量去保存最小值，这时的关键是：如何保留最小值的记录（如果最小值弹出了，就会用到历史的最小值）
    - 解决：当有更小的值来的时候，只需要把之前的最小值入栈，当前更小的值再入栈即可。当这个最小值要出栈的时候，下一个值便是之前的最小值了。
    - 注意：push()中的if判断需要包含等于：因为如果此时的x弹出，最小值仍是原来的那个。如果等于就不压栈，那么一旦弹出，原相等的最小值就没了。
      - 等于不会死循环，这里的push是库函数不是上面的push
  - 栈相关知识点
    - empty()：测试堆栈是否为空。
    - peek()： 查看堆栈顶部的对象，但不从堆栈中移除它。
    - pop()：  移除堆栈顶部的对象，并作为此函数的值返回该对象。
    - push(E item)： 把项压入堆栈顶部。
    - search(Object o)：返回对象在堆栈中的位置，以 1 为基数（指栈顶元素的位置为1）。

- ## 代码链接
  - [包含 min 函数的栈](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/30_包含min函数的栈.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 31. 栈的压入、弹出序列
- ## 题目描述


- ## 解题思路


- ## 代码链接




<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 32.1 从上往下打印二叉树
- ## 题目描述
  - 从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。
  - 例如: 给定二叉树: [3,9,20,null,null,15,7],
    - 返回：[3,9,20,15,7]
  - 提示：节点总数 <= 1000

- ## 解题思路
  - 分析：
    - 题目要求的二叉树的 从上至下 打印（即按层打印），又称为二叉树的 广度优先搜索（BFS）。
    - BFS 通常借助 队列 的先入先出特性来实现：先遍历到的，先弹出，先进先出用队列。
    - 虽然返回值是数组，但因为需要增删元素，因此用到ArrayList类型的变量。
    - 辅助队列可以多态使用LinkedList，以优化性能。
    - 用循环遍历，直到根结点为空。
  - 算法：
    - 复杂度：时间O(n)，空间O(n)
    - 判空：当根结点为空时，返回空列表[]（注：根据返回值类型设置）
    - 初始化结果列表list为空列表，辅助队列queue，并将根结点存入辅助队列；
    - 循环：当队列 queue 为空时跳出
      - 出队：队首元素出队，记为 node；
      - 打印：将 node.val 添加至列表 tmp 尾部；
      - 添加子节点：若 node 的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；
    - 返回值：新建结果数组res，遍历list并存入res，然后返回。
  - 知识点：
    - List<Integer> 转 Integer[]
      - Integer[] integers2 = list1.toArray(new Integer[0]);
      - 调用toArray。传入参数T[] a。这种用法是目前推荐的。
      - List<String>转String[]也同理。
    - List<Integer> 转 int[]
      - int[] arr1 = list1.stream().mapToInt(Integer::valueOf).toArray();
      - 想要转换成int[]类型，就得先转成IntStream。
      - 这里就通过mapToInt()把Stream<Integer>调用Integer::valueOf来转成IntStream
      - 而IntStream中默认toArray()转成int[]。
    - LinkedList: 
      - get(int index): 返回此列表中指定位置处的元素。
  
- ## 代码链接
  - [从上往下打印二叉树](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/32_1_从上往下打印二叉树.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 32.2 把二叉树打印成多行
- ## 题目描述
  - 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。
  - 例如:
    - 给定二叉树: [3,9,20,null,null,15,7],
    - 返回其层次遍历结果：[   [3],  [9,20],  [15,7] ]
  - 提示：节点总数 <= 1000

- ## 解题思路
  - 分析：
    - 按层打印：题目要求的二叉树的 从上至下 打印（即按层打印），又称为二叉树的 广度优先搜索（BFS）。BFS 通常借助 队列 的先入先出特性来实现。
    - 每层打印到一行：将本层全部节点打印到一行，并将下一层全部节点加入队列，以此类推，即可分为多行打印。
    - 需要用到循环嵌套，但总的循环次数仍是n，因此时间复杂度仍为O(n)。
  - 算法：
    - 复杂度：时间O(n)，空间O(n)
    - 判空：当根节点为空，则返回空列表 [] ；
      - (注：根结点判空需要新建，因此可以转为先初始化，然后对根结点判非空)
    - 初始化： 打印结果列表 res = [] ，包含根节点的队列 queue = [root] ；
    - BFS 循环： 当队列 queue 为空时跳出；
      - 新建一个临时列表 tmp ，用于存储当前层打印结果；
      - 当前层打印循环： 循环次数为当前层节点数（即队列 queue 长度）；
        - 出队： 队首元素出队，记为 node；
        - 打印： 将 node.val 添加至 tmp 尾部；
        - 添加子节点： 若 node 的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；
      - 将当前层结果 tmp 添加入 res 。
    - 返回值： 返回打印结果列表 res 即可。
    - 注意：内循环次数控制的for循环
      - 使用i--，让size()只在循环开始使用一次，使循环次数不受队列长度变化影响，妙啊！
      - 若i从0开始，使用i++，那么queue的size每一轮都在变，会导致错误。
      
- ## 代码链接
  - [把二叉树打印成多行](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/32_2_把二叉树打印成多行.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 32.3 按之字形顺序打印二叉树
- ## 题目描述
  - 请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。
  - 例如: 
    - 给定二叉树: [3,9,20,null,null,15,7],
    - 返回其层次遍历结果：[  [3],  [20,9],  [15,7]  ]
  - 提示：节点总数 <= 1000

- ## 解题思路
  - 思路：层序遍历+双端队列；奇偶分离；层序遍历+倒序。
    - 注：剑指原书用两个栈实现。
  - 方法一：层序遍历 + 双端队列
    - 复杂度：时间O(n), 空间O(n)
    - 分析：
      - 利用双端队列的两端皆可添加元素的特性，设打印列表（双端队列） tmp ，并规定：
      - 奇数层 则添加至 tmp 尾部 ，
      - 偶数层 则添加至 tmp 头部 。
      - Java 中将链表 LinkedList 作为双端队列使用，即在内循环中定义临时列表tmp为LinkedList类型。
      - 注：建立在上一题的方法基础上。
    - 算法流程：
      - 特例处理： 当树的根节点为空，则直接返回空列表 [] ；
      - 初始化： 打印结果空列表 res ，包含根节点的双端队列 deque ；
      - BFS 循环： 当 deque 为空时跳出；
      - 新建列表 tmp ，用于临时存储当前层打印结果；
        - 当前层打印循环： 循环次数为当前层节点数（即 deque 长度）；
          - 出队： 队首元素出队，记为 node；
          - 打印： 若为奇数层，将 node.val 添加至 tmp 尾部；否则，添加至 tmp 头部；
          - 添加子节点： 若 node 的左（右）子节点不为空，则加入 deque ；
        - 将当前层结果 tmp 转化为 list 并添加入 res ；
      - 返回值： 返回打印结果列表 res 即可；
      - 注：对于奇偶数层的判断是根据结果列表的长度，因为每次添加一行，因此可以用来判断是哪一行。
        - 初始化会添加根结点；
        - 第二次是偶数行，此时结果列表res的长度为1，是奇数，对应的下一行是偶数行，应该添加元素在头部；
        - 第三次是奇数行，此时结果列表res的长度为2，是偶数，对应的下一行的奇数行，应该正常添加元素，即在尾部添加；
        - 综上：size为奇数时，addFirst；size为偶数时，addLast。
  - 方法二：层序遍历 + 双端队列 + 奇偶分离
    - 复杂度：时间O(n), 空间O(n)
    - 分析：
      - 方法一代码简短、容易实现；但需要判断每个节点的所在层奇偶性，即冗余了 N 次判断。
      - 通过将奇偶层逻辑拆分，可以消除冗余的判断。
    - 算法流程：
      - 与方法一对比，仅 BFS 循环不同。
      - BFS 循环： 循环打印奇 / 偶数层，当 deque 为空时跳出；
        - 打印奇数层： 从左向右 打印，先左后右 加入下层节点；
        - 若 deque 为空，说明向下无偶数层，则跳出；
        - 打印偶数层： 从右向左 打印，先右后左 加入下层节点；
    - 注：
      - 用到双端队列deque，及其方法removeFirst() 和 removeLast()
      
- ## 代码链接
  - [按之字形顺序打印二叉树](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/32_3_按之字形顺序打印二叉树.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 33. 二叉搜索树的后序遍历序列
- ## 题目描述


- ## 解题思路


- ## 代码链接




<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 34. 二叉树中和为某一值的路径
- ## 题目描述


- ## 解题思路


- ## 代码链接




<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 35. 复杂链表的复制
- ## 题目描述


- ## 解题思路


- ## 代码链接




<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 36. 二叉搜索树与双向链表
- ## 题目描述


- ## 解题思路


- ## 代码链接




<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 37. 序列化二叉树
- ## 题目描述


- ## 解题思路


- ## 代码链接




<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 38. 字符串的排列
- ## 题目描述


- ## 解题思路


- ## 代码链接




<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 39. 数组中出现次数超过一半的数字
- ## 题目描述
  - 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。
  - 你可以假设数组是非空的，并且给定的数组总是存在多数元素。
  - 示例: 输入: [1, 2, 3, 2, 2, 2, 5, 4, 2], 输出: 2。
  - 限制: 1 <= 数组长度 <= 50000

- ## 解题思路
  - 思路：暴力法；哈希表法；排序；分治；投票..
  - 暴力法：
    - 复杂度：时间O(n^2)，空间O(1)
    - 暴力算法遍历整个数组，然后用另一重循环统计每个数字出现的次数。将出现次数比其他数字加起来出现次数还多的元素返回。
    - 算法：初始化n/2；双层循环：外层控制比较基准，内层统计与基准相同的个数，并在内层结束后与n/2比较；最后return任一int型，比如-1.
    - 不足：时间复杂度过高
  - 哈希表：
    - 复杂度：时间O(n)，空间O(n)
    - 使用哈希表来存储每个元素，然后用一个循环在线性时间内遍历 nums ，然后我们只需要返回有最大值的键。
    - 算法：
      - 新建哈希表；
      - 新建max值和次数的变量；
      - 遍历数组：第一次出现时count赋值为1，否则在哈希表中对应count基础上+1，每次判断count范围并更新max两个变量；
      - 返回max值。
    - HashMap知识点：
      - `getOrDefault(Object key, V defaultValue)` : 如果存在key返回对应的value，否则返回defaultValue
  - 排序：
    - 复杂度：时间O(nlogn)，空间O(1)
    - 如果所有数字被单调递增或者单调递减的顺序排了序，那么众数的下标为n/2
    - 算法：对数组排序；返回排序后的n/2索引对应的元素
  - 摩尔投票法：
    - 复杂度：时间O(n)，空间O(1)
    - 把众数记为 +1，把其他数记为 −1 ，将它们全部加起来，显然和大于 0 ，从结果本身我们可以看出众数比其他数多。
    - 算法：
      - 定义比较基准flag=nums[0]和计数器count=1；
      - 遍历数组：与基准相同+1，不同-1，且变为0时，更新基准为下一个索引对应的元素；
        - 循环体中，先判决count是否为0，后判空nums[j]是否等于flag，一前一后用if-else连接；
        - 否则，赋值flag和计数器count会冲突，每次更新一次count即可。      
      - 返回最后计数器不为0的基准。
  - 注：后三种的时间复杂度都是近似n，但是哈希表法明显比最后两种慢很多。 
   
- ## 代码链接:
  - [数组中出现次数超过一半的数字](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/39_数组中出现次数超过一半的数字.java)
  
<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 40. 最小的 K 个数
- ## 题目描述


- ## 解题思路


- ## 代码链接


- 镜像问题：<leetcode-215-数组中的第K个最大元素-medium>



- 相关知识点：
      - `Arrays.copyOfRange(arrName, start, end)`: 返回左闭右开索引值范围内的数组片段。
      
      
<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 41.1 数据流中的中位数
- ## 题目描述


- ## 解题思路


- ## 代码链接


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 41.2 字符流中第一个不重复的字符
- ## 题目描述


- ## 解题思路


- ## 代码链接


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 42. 连续子数组的最大和
- ## 题目描述
  - 输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。
  - 要求时间复杂度为O(n)。
  - 示例1: 输入: nums = [-2,1,-3,4,-1,2,1,-5,4], 输出: 6
     - 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
  - 提示：1 <= arr.length <= 10^5, -100 <= arr[i] <= 100

- ## 解题思路
  - 思路：暴力法；动态规划；贪心；分治
  - 暴力法：
    - 复杂度：时间O(N^2)，空间O(1)
    - 寻找所有的可能子序和，并求最大值
    - 首先定义并初始化max为数组第一个元素
    - 按照一定规律遍历数组，比如从i开始遍历到末尾，不断取和，比较并取max，然后i++
    - 两层循环：外循环控制开始的i值，内循环控制在i索引开始，形成的子序列
  - 贪心：
    - 复杂度：时间O(n)，空间O(1)
    - 分析：从左向右遍历，一个个数累加；当sum<0，重新开始找子序列
      - 所求最大值max可由if判断语句比较得到，也可由Math.max(i,j)直接求得
      - sum初始化为0，小于0的sum说明累加后比初始值更小了
      - "重新找"指的是：sum归0， 并从下一个元素起，重新累加
    - 算法：
      - 如果题目没有给定非空的范围，第一步判空；
      - 定义最大值max为数组第一个元素，定义子序列和sum为0；
      - 遍历数组：从0到length（左闭右开）
        - 求和：将nums[i]累加到sum；
        - 更新max的值为max和sum中最大的一个；
        - 判断sum与0：如果sum<0，则设置sum=0，重新开始计算子序列和；
      - 返回结果max。
  - 动态规划：
    - 复杂度：时间O(n), 空间O(n)，可优化到O(1)
      - 只用到dp数组中的前一项，因此可以用int代替一维数组，对空间复杂度优化
    - 分析：
      - dp[i]: nums中，以nums[i]结尾的最大子序和
      - dp[i]=max(dp[i-1]+nums[i], nums[i]);
      - 如果加上nums[i]之后的和，比nums[i]本身更小了，说明从nums[i]开始的子序列必然大于从前的和，因此重新开始计算。
    - 算法：
      - 初始化dp数组和max，dp[i]是指以nums[i]结尾的最大子序和;
      - 遍历数组：求dp[i]，并更新max为max和dp[i]中的最大值；
      - 返回结果变量max。
  - 分治：
    - 复杂度：时间O(nlogn)，空间O(logn)
    - 取数组的中心点为中心，那么最大子序列要么在中心左，要么在右，要么跨中心
    - 分三种情况进行考虑
    - 跨中心的情况，又可以分治中心点左侧和右侧的最大子序列问题
    - 注：对比以上思路，分治的思路过于复杂，不详细分析了。
  - 注：
    - 类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值`max=Integer.MIN_VALUE;`
    - Integer是java.lang包下的，自动导入不用再手写import
    - Math是java.lang包下的，不用再手写import
    - 本题可以定义max为数组第一个元素，因为只是累加计算
    
- ## 代码链接：
  - [连续子数组的最大和](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/42_连续子数组的最大和.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 43. 从 1 到 n 整数中 1 出现的次数
- ## 题目描述


- ## 解题思路


- ## 代码链接


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 44. 数字序列中的某一位数字
- ## 题目描述


- ## 解题思路


- ## 代码链接


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 45. 把数组排成最小的数
- ## 题目描述


- ## 解题思路


- ## 代码链接


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 46. 把数字翻译成字符串
- ## 题目描述


- ## 解题思路


- ## 代码链接


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 47. 礼物的最大价值
- ## 题目描述


- ## 解题思路


- ## 代码链接


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 48. 最长不含重复字符的子字符串
- ## 题目描述
  - 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
  - 示例 1: 
    - 输入: "abcabcbb"，输出: 3。
    - 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
  - 示例 2: 
    - 输入: "bbbbb"，输出: 1。
     - 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
  - 示例 3: 
    - 输入: "pwwkew"，输出: 3。
    - 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
  - 请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

- ## 解题思路
  - 思路：暴力法；滑动窗口。
  - 暴力法：
    - 复杂度：O(n^3)，O(min(m,n)) -- 字符串 n 的大小以及字符集/字母 m 的大小。
    - 分析：
      - 假设有一个函数 boolean allUnique(String substring) ，如果子字符串中的字符都是唯一的，它会返回 true，否则会返回 false。
      - 遍历给定字符串 s 的所有可能的子字符串并调用函数 allUnique。 如果事实证明返回值为 true，那么将会更新无重复字符子串的最大长度的答案。
      - 为了枚举给定字符串的所有子字符串，需要枚举它们开始和结束的索引。假设开始和结束的索引分别为 i 和 j。那么有 0≤i<j≤n（这里的结束索引 j 是按惯例排除的）。因此，使用 i 从 0 到 n−1 以及 j 从 i+1 到 n 这两个嵌套的循环，我们可以枚举出 s 的所有子字符串。
      - 要检查一个字符串是否有重复字符，使用集合。
      - 遍历字符串中的所有字符，并将它们逐个放入 set 中。在放置一个字符之前，检查该集合是否已经包含它。如果包含，返回 false。循环结束后，返回 true。
    - 算法：
      - 定义判断左闭右开区间内是否符合各个字符唯一的函数allUnique；
      - 主函数内定义结果变量res并初始化为0；
      - 两层循环：外循环定义起始基准，内循环定义基准起到末尾的所有子串，并调用allUnique函数判断，为真时与res比较并将res更新为其中的最大值；
      - 返回res。
    - HashSet知识点：
      - 新建：`Set<Character> set = new HashSet<>();`
      - add(E e) ：如果此 set 中尚未包含指定元素，则添加指定元素。
      - contains(Object o) ：如果此 set 包含指定元素，则返回 true。
      - isEmpty() ：如果此 set 不包含任何元素，则返回 true。
      - size() ：返回此 set 中的元素的数量（set 的容量）。
  - 滑动窗口
    - 复杂度：O(n)，O(min(m,n)) -- 字符串 n 的大小以及字符集/字母 m 的大小。
    - 滑动窗口是数组/字符串问题中常用的抽象概念。 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 i到j（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 i-j左闭右开 向右滑动 1 个元素，则它将变为 i+1到j+1（左闭，右开）。
    - 分析：
      - 使用 HashSet 将字符存储在当前窗口  `[i,j)` 左闭右开（最初 j=i）中。 然后我们向右侧滑动索引 j，如果它不在 HashSet 中，我们会继续滑动 j。直到 s[j] 已经存在于 HashSet 中。此时，我们找到的没有重复字符的最长子字符串将会以索引 i 开头。如果我们对所有的 i 这样做，就可以得到答案。
      - 优化：使用哈希map，如果 s[j] 在 `[i,j)` 范围内有与 j' 重复的字符，我们不需要逐渐增加 i ，直接跳过 [i，j′] 范围内的所有元素，并将 i 变为 j′+1。
      - HashMap：记录char的位置+1，便于窗口start位置的滑动
    - 算法：
      - 初始化结果变量res=0；
      - 定义哈希表map：存储 (k, v)，其中 key 值为字符，value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复
      - for循环遍历：初始化 开始位置为 start=0，结束位置为 end=0
        - 初始化字符：`char chs = s.charAt(end);` -- 以end对应的字符为基准进行遍历
        - map.containsKey -- 判断chs是否已经存在窗口中
          - 当存在时，更新start的值为start和map.get(key)中的max；
        - 更新res为res和end-start+1中的最大值；
        - map.put(key, value) -- 其中，key表示end对应字符，value为end+1，表示下一个无重复位置，方便get的时候更新start的值。
        - 注：无论是否更新 start，都会更新其 map 数据结构和结果 ans。
      - 返回结果变量res。

- ## 代码链接：
  - [无重复字符的最长子串](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/48_最长不含重复字符的子字符串.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 49. 丑数
- ## 题目描述
  - 把只包含质因子2、3和5的数称作丑数（Ugly Number）。
  - 例如6、8都是丑数，但14不是，因为它包含质因子7。
  - 习惯上我们把1当做是第一个丑数。
  - 求按从小到大的顺序的第N个丑数。

- ## 解题思路
  - 求丑数的思路：
    - 验证一个数是否是丑数：先看是否能整除2，即取模得0，若可以则整除2直至余数不为0；然后重复3和5
  - 常规思路：
    - 从1开始，依次验证各个数是否符合
    - 问题：对每个数字进行了运算，时间复杂度高
  - 改进思路：
    - 以空间换时间，创建数组保存已经找到的丑数，并在此基础上乘以因子继续找
    - 现在的思路是在丑数的基础上找新的丑数，避免了遍历每个自然数的操作
    - 具体思路：找下一个丑数，设置flag2,3,5，可从已有丑数基础上乘以因子2,3,5，取最小值，同时改变flag值
  - 注意：
    - Math.min()针对两个数，因此写为：`Math.min(next2, Math.min(next3, next5))`
  - 面试思路：三指针法
    - 分析：思路大致同改进思路。
      - 基数是2，3，5，设置三个指针参数，分别作为三个基数的倍数，求乘积后取三者最小值作为下一个丑数。
      - 求得最小值对应的指针，并更新。
    - 算法：
      - 初始化数组dp[]，三个指针i2，i3，i5;
      - for循环：计算指定前n个丑数
        - 定义并求三个乘积结果：乘积 = 前一个dp[i] * 某个指针；
        - 用两个min找出三者中的最小值，作为下一个丑数存入dp[i]中；
        - 比较并找出dp[i]对应的指针，并+1；
      - 返回结果dp[n-1]。
    - 注：if判断最小指针时，不能用if-else-if的格式，会报错；只能用if-if-if的格式
      - 不知道为什么。
  
- ## 代码链接
  - [丑数](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/49_%E4%B8%91%E6%95%B0.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 50. 第一个只出现一次的字符位置
- ## 题目描述
  - 在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。
  - 示例: s = "abaccdeff"，返回 "b"；s = "" ，返回 " "
  - 限制：0 <= s 的长度 <= 50000

- ## 解题思路
  - 思路：暴力法；哈希表法。
    - 注：参考<leetcode-136题：只出现一次的数字>，还可以用异或。
  - 暴力法：
    - n个字符，若遍历每个字符并每次扫描整个字符串得到出现次数，时间复杂度是n^2
  - 哈希表：
    - 键设为字符，值设为出现次数，第一次遍历每个字符次数+1，第二次找到
    - 时间复杂度：O(N)，空间复杂度：O(1)
    - 进一步地：可以用数组实现哈希表
    - 利用每个字母的ASCII码作hash来作为数组的index。
      - 用一个58长度的数组来存储每个字母出现的次数；
      - 58是因为A-Z对应的ASCII码为65-90，a-z对应的ASCII码值为97-122，而每个字母的index=int(word)-65，比如g=103-65=38。
    - 数组中具体记录的内容是该字母出现的次数，最终遍历一遍字符串，找出第一个数组内容为1的字母就可以了，时间复杂度为O(n)
    - 算法：
      - 定义数组；
      - 第一次遍历字符串：将字母转为int型，并减去65，作为key值，即索引值；或者直接获取字符并减去A(A==65)；
      - 第二次遍历字符串：如果对应值是1则返回对应的字符；（注意：是遍历字符串，不是遍历数组）
      - 如果循环结束后没有符合条件的，则返回空串（注意空串：单引号中间需要打空格）。
      - 注意返回值类型：char型，因此注意用单引号，特别是空串。
      - 注：不用判空，空串的情况包含在循环判断中了，只是开辟数组空间有点浪费。
  - 注意：
    - ASCII码有256个字符，仅考虑字母（题目说明仅包含字母）
    - ASCII码中的90-96不是字母，但是为了统一减65来计算，所以要再加上6个长度，不然就要判断是否是小写字母，小写字母要减65再减6
    - （无所谓了，写成256大小的数组也可）
    - charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。返回值是一个字符。
    - (int)(charAt())将对应的字符转为int型
  - 异或：
    - 如果是数组数组不是字符串的话，可以考虑这种思路。
    - 位运算，求异，即找不同，相同为0，不同为1。且：0和0为0，0和1为1，而1和1为0.
    - 交换律：a ^ b ^ c <=> a ^ c ^ b
    - 任何数与0异或为任何数 0 ^ n => n -- 与0运算时，有1即为1，否则为0.
    - 相同的数异或为0: n ^ n => 0
    - 示例：var a = [2,3,2,4,4]，`2 ^ 3 ^ 2 ^ 4 ^ 4` 等价于 `2 ^ 2 ^ 4 ^ 4 ^ 3 => 0 ^ 0 ^3 => 3`

- ## 代码链接
  - [第一个只出现一次的字符位置](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/50_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%E4%BD%8D%E7%BD%AE.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 51. 数组中的逆序对
- ## 题目描述


- ## 解题思路


- ## 代码链接


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 52. 两个链表的第一个公共结点
- ## 题目描述
  - 编写一个程序，找到两个单链表相交的起始节点。
  - 注意：
    - 如果两个链表没有交点，返回 null.
    - 在返回结果后，两个链表仍须保持原有的结构。
    - 可假定整个链表结构中没有循环。
    - 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。

- ## 解题思路
  - 思路：暴力法；哈希表法；双指针法
  - 注：本题同LeetCode160题-easy。
  - 方法一: 暴力法
    - 对链表A中的每一个结点 ai ，遍历整个链表 B 并检查链表 B 中是否存在结点和 ai 相同。
    - 复杂度分析：时间O(mn)，空间O(1)。
  - 方法二: 哈希表法 
    - 遍历链表 A 并将每个结点的地址/引用存储在哈希表中。然后检查链表 B 中的每一个结点 bi 是否在哈希表中。若在，则 bi 为相交结点。
    - 复杂度分析：时间O(m+n), 空间 O(m) 或 O(n)。
  - 方法三：双指针法 
    - 复杂度：时间O(m+n)，空间O(1)。
    - 思路：链表A：a+c, 链表B : b+c. a+c+b+c = b+c+a+c 。则会在第二个c起点相遇。若不相交，a+b = b+a 。因此相遇处是NULL（尾）
    - 算法：判空；新建结点；循环：两结点移动，直到相等。
    - 注：没有公共时，最后都指向null，此时相等，退出循环。因此不会死循环。
    - 代码使用了三目运算符，很巧妙。
      - 注意：三目运算符，如果pa或pb为null，则指向headA或headB，不是pb或pa！！！
  - 注：剑指原书提供了一种栈从尾到头比较，最后一个相同结点即为所求的方法。

- ## 代码链接:
  - [两个链表的第一个公共结点](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/52_两个链表的第一个公共结点.java)
  
<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 53.1 数字在排序数组中出现的次数
- ## 题目描述
  - 统计一个数字在排序数组中出现的次数。
  - 示例 1:
    - 输入: nums = [5,7,7,8,8,10], target = 8
    - 输出: 2
  - 示例 2:
    - 输入: nums = [5,7,7,8,8,10], target = 6
    - 输出: 0
  - 限制：0 <= 数组长度 <= 50000

- ## 解题思路
  - 思路：二分查找
  - 复杂度：时间O(logn), 空间O(1)
  - 分析：
    - 排序数组中的搜索问题，首先想到 二分法 解决。
      - 但可能只找到target其中之一，若向前向后遍历来找所有target，则时间复杂度变为暴力遍历相同的O(n)。
    - 排序数组 nums 中的所有数字 target 形成一个窗口，记窗口的 左 / 右边界 索引分别为 left 和 right ，分别对应窗口左边 / 右边的首个元素。
    - 本题要求统计数字 target 的出现次数，可转化为：使用二分法分别找到 左边界 left 和 右边界 right ，易得数字 target 的数量为 right−left+1 
      - 分别用二分求左右边界，则时间复杂度仍为O(logn)。
  - 算法：
    - 初始化边界指针为数组的左右端点；
    - 两次二分；
      - 不等时，同二分处理；
      - nums[mid]与target相等时：
        - 右边界：在mid对应元素的右侧，因此小指针更新为mid+1；
        - 左边界：在mid对应元素的左侧，因此大指针更新为mid-1；
        - 注：这种区别可以通过<=的等于号，并配合if-else实现。
    - 返回左右边界索引值的差值+1；
    - 注：target不存在的情况会返回0，符合预期结果。
  - 改进：两次二分的代码可以封装起来，然后进行调用，并直接返回差值。
    - 数组 nums 中元素都为整数，因此可以分别二分查找 target 和 target−1 的右边界，将两结果相减并返回即可。
    - 未尝试：如果target-1对应的值不存在或存在多个，需要考虑的东西很多。

- ## 代码链接
  - [数字在排序数组中出现的次数](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/53_1_数字在排序数组中出现的次数.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 53.2 0到n-1中缺失的数字
- ## 题目描述
  - 一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。
  - 示例 1:
    - 输入: [0,1,3]
    - 输出: 2
  - 示例 2:
    - 输入: [0,1,2,3,4,5,6,7,9]
    - 输出: 8
  - 限制：1 <= 数组长度 <= 10000

- ## 解题思路
  - 思路：二分
  - 复杂度：时间O(logn), 空间O(1)
  - 分析：
    - 排序数组中的搜索问题，首先想到 二分法 解决。
    - 根据题意，由于数组数字是从0开始的，与数组索引值的初始值0相符，因此数组可以按照以下规则划分为两部分。
      - 左子数组： nums[i]=i ；
      - 右子数组： nums[i] ≠ =i ；
    - 缺失的数字等于 “右子数组的首位元素” 对应的索引；因此考虑使用二分法查找 “右子数组的首位元素” 。
      - 若mid对应值等于索引值时，证明所求在对应值的右侧，则left=mid+1；
      - 若mid对应值不等于索引值时，证明所求在对应值的左侧，则right=mid-1;
      - 当大小指针交叉时，终止循环，此时小指针指向第一个对应值与索引不相等的值，而这个索引值就是缺失的值。
      - 最终返回小指针。
  - 算法：
    - 初始化大小指针；
    - 二分；
    - 循环结束后，返回小指针对应的值。

- ## 代码链接
  - [0到n-1中缺失的数字](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/53_2%20_0到n-1中缺失的数字.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 54. 二叉查找树的第 K 个结点
- ## 题目描述
  - 给定一棵二叉搜索树，请找出其中第k大的节点。
  - 示例 1:
    - 输入: root = [3,1,4,null,2], k = 1
    - 输出: 4
  - 示例 2:
    - 输入: root = [5,3,6,2,4,null,null,1], k = 3
    - 输出: 4
  - 限制：1 ≤ k ≤ 二叉搜索树元素个数

- ## 解题思路
  - 思路：二叉搜索树中序遍历的逆序。
  - 思路：
    - 二叉搜索树的中序遍历为 递增序列 。
    - 根据以上性质，易得二叉搜索树的 中序遍历倒序 为 递减序列 。
    - 因此，求 “二叉搜索树第 k 大的节点” 可转化为求 “此树的中序遍历倒序的第 k 个节点”。
  - 算法：
    - 终止条件： 当节点 root 为空（越过叶节点），则直接返回；
    - 递归右子树： 即 dfs(root.right) ；
    - 三项工作：
      - 提前返回： 若 k=0 ，代表已找到目标节点，无需继续遍历，因此直接返回；
      - 统计序号： 执行 k=k−1 （即从 k 减至 0 ）；
      - 记录结果： 若 k=0 ，代表当前节点为第 k 大的节点，因此记录 res=root.val ；
    - 递归左子树： 即 dfs(root.left) ；

- ## 代码链接
  - [二叉查找树的第 K 个结点](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/54_二叉搜索树的第k大节点.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 55.1 二叉树的深度
- ## 问题描述
  - 输入一棵二叉树，求该树的深度。
  - 从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。
  
- ## 解题思路
  - 考虑“记录二叉树的路径”的方法比较繁琐
  - 递归的思想。分析规律可知用递归比较快。
  - 可以用三元运算符 A?B:C 将代码化简为一句代码。
  - 分析：
    - 如果只有根节点：深度为1
    - 如果只有左子树：深度为左子树的深度+1
    - 如果只有右子树：深度为右子树的深度+1
    - 如果既有左子树又有右子树：深度为左右子树的深度中的较大值+1
    - 结合图示更清晰

- ## 代码链接
  - [二叉树的深度](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/55_1_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 55.2 平衡二叉树
- ## 题目描述
  - 给定一个二叉树，判断它是否是高度平衡的二叉树。
  - 本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。
  - 示例 1: 给定二叉树 [3,9,20,null,null,15,7]，返回 true 。
  - 示例 2: 给定二叉树 [1,2,2,3,3,null,null,4,4]，返回 false 。

- ## 解题思路
  - 思路：dfs -- 自顶向下，自底向上
  - 平衡二叉树（Balanced Binary Tree）具有以下性质：
    - 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1
    - 并且左右两个子树都是一棵平衡二叉树。
    - 注：子树也是平衡树在题目中没有说，但是具有此性质，判断时需要判断左右子树也平衡才行
  - 自顶向下（暴力法）：
    - 复杂度：时间O(nlogn)，空间O(n)
    - 算法：判空返回真；调用height函数判断子树高度差<2,以及调用本体函数判断左右子树是否平衡
    - height函数：判空返回-1，否则返回1+max(root.left的高度,root.right的高度)
      - 注：-1对应叶节点(两子树为-1，再+1为0，即一个结点深度为0)，最大子树高度+1是指加上子树到根结点这层
    - 注意：
      - 减法：要取绝对值，否则可能是负数 `Math.abs()`
  - 自底向上（提前阻断）：
    - 复杂度：时间O(n)，空间O(n)
    - 思路是对二叉树做先序遍历，从底至顶返回子树最大高度，若判定某子树不是平衡树则 “剪枝” ，直接向上返回。
    - 方法一计算 height 存在大量冗余。每次调用 height 时，要同时计算其子树高度。但是自底向上计算，每个子树的高度只会计算一次。可以递归先计算当前节点的子节点高度，然后再通过子节点高度判断当前节点是否平衡，从而消除冗余。
    - 算法：
      - 使用与方法一中定义的 height 方法。逻辑相反，首先判断子树是否平衡，然后比较子树高度判断父节点是否平衡。
      - 算法如下：检查子树是否平衡。如果平衡，则使用它们的高度判断父节点是否平衡，并计算父节点的高度。
      - 当发现不是平衡树时，后面的高度计算都没有意义了，因此一路返回-1，避免后续多余计算。
  - 区别：
    - 自底向上会在递归过程中加入判断，如果出现不符合情况直接阻断；
    - 自顶向下则是无脑递归，中间不进行判断。
  - 注意：root为空时，符合平衡树条件。
        
- ## 代码链接:
  - [平衡二叉树](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/55_2_%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 56.1 数组中只出现一次的数字
- ## 题目描述
  - 一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。
  - 要求时间复杂度是O(n)，空间复杂度是O(1)。
  - 示例 1：
    - 输入：nums = [4,1,4,6]
    - 输出：[1,6] 或 [6,1]
  - 示例 2：
    - 输入：nums = [1,2,10,4,1,4,3,3]
    - 输出：[2,10] 或 [10,2]
  - 限制：2 <= nums.length <= 10000

- ## 解题思路
  - 思路：异或+分组+异或。
  - 分析：
    - 根据复杂度要求，不能用哈希表。
    - 考虑异或：a^a=0的性质
      - 求只出现一次的一个数字时，可以遍历数组并将所有数字异或，剩余的数字即为所求。
      - 当有两个数字只出现一次时，遍历并全部异或的结果是所求两个数字异或的结果。
      - 根据结果将所有数字分为两组：结果中二进制位1的位数即为两个数字相异的位数，可以根据这一位进行分组
      - 分组之后分别异或，即可得到最终的两个数字。
    - 注：分组不用实际分开，就if判断即可。
  - 算法：
    - 定义变量k用于存储异或结果，并初始化为0；
      - 注：0与任何数异或，结果为该任意数。
    - 遍历数组，并将所有数字异或，结果存入k；
    - 获取k的最低位1：
      - 定义flag=1；
      - while循环，当flag与k的&结果为0时，左移一位flag；
    - 定义结果数组a和b，并初始化为0；
    - for循环遍历数组：
      - if判断遍历到的每个元素，按照`该元素&flag`结果是否为0进行分组进行，并分别与a和b进行异或运算。
    - 返回new的数组并将结果数字a和b存入该数组。  
  - 注意：
    - 不确定运算符的优先级时，多加括号来区分优先级。
    
- ## 代码链接
  - [数组中只出现一次的数字](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/56_1_数组中数字出现的次数.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 56.2 数组中只出现一次的数字II
- ## 题目描述
  - 在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。
  - 示例 1：
    - 输入：nums = [3,4,3,3]
    - 输出：4
  - 示例 2：
    - 输入：nums = [9,1,7,9,7,9,7]
    - 输出：1
  - 限制：
    - 1 <= nums.length <= 10000
    - 1 <= nums[i] < 2^31

- ## 解题思路
  - 思路：
    - 位运算+遍历统计
  - 分析：
    - 考虑数字的二进制形式，对于出现三次的数字，各 二进制位 出现的次数都是 3 的倍数。
    - 因此，统计所有数字的各二进制位中 1 的出现次数，并对 3 求余，结果则为只出现一次的数字。
    - 两种方法：有限变量自动机；遍历统计。
      - 法1设计模电的一些知识；法2虽然效率不及法1，但是够用了。
  - 算法：
    - 初始化一个统计数组counts，长度根据定义的元素范围：`<2^31`设置为32；
    - 两层循环：外循环遍历数组元素，内循环统计数组元素中每一位的1的个数
      - 外循环因为不涉及索引值，因此可以用`for(int i : array)`的形式
      - 内循环中，`元素 & 1`求最低位是否为1并累加到统计数组counts的对应元素，然后将数组元素无符号右移一位后，循环再次计算。
    - 初始化结果变量res，和参数m=3
      - 注：这里m可以根据题目要求修改为其他数字，依然适用
    - 遍历统计数组counts，对每一位`%3`，并通过或运算添加到res
      - 这里用到了或运算的性质，比较巧妙。
      - 注：这里因为res左移，因此先计算高位，从高到低 `counts[31-i] % m`
    - 返回结果变量res。

- ## 代码链接
  - [数组中只出现一次的数字II](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/56_2_数组中数字出现的次数II.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 57.1 和为 S 的两个数字
- ## 题目描述
  - 输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S
  - 如果有多对数字的和等于S，输出两个数的乘积最小的。

- ## 解题思路
  - 使用双指针，一个指针指向元素较小的值，一个指针指向元素较大的值。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。
    - 如果两个指针指向元素的和 sum == target，那么得到要求的结果；
    - 如果 sum > target，移动较大的元素，使 sum 变小一些；
    - 如果 sum < target，移动较小的元素，使 sum 变大一些。
  - a+b=sum,a和b越远乘积越小，而一头一尾两个指针往内靠近的方法找到的就是乘积最小的情况
  - 注意牛客题目默认用了ArrayList：
    - 实现了List的接口，实现了可变大小的数组，随机访问和遍历元素时，提供更好的性能。
    - 该类也是非同步的,在多线程的情况下不要使用。
    - ArrayList 增长当前长度的50%，插入删除效率低。
    - 往list添加元素：list.add(array[index]); -- list.add(x);

- ## 代码链接
  - [和为S的两个数字](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/57_1_%E5%92%8C%E4%B8%BAS%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->




# 57.2 和为 S 的连续正数序列
- ## 题目描述
  - 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。
  - 现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!
  - 输出描述:
    - 输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序
    - 例如：sum=15时，[1,2,3,4,5], [4,5,6], [7,8]

- ## 解题思路
  - 参考上一题的思路：双指针技术
    - 相当于有一个窗口，窗口的左右两边就是两个指针，根据窗口内值之和来确定窗口的位置和宽度。
    - 虽然双指针或者所谓的滑动窗口技巧还是蛮常见的，但是这一题还真想不到这个思路。
  - 基本步骤：
    - 初始化两个指针big和small，并在自然数上移动两个指针（循环），直到小指针追上大指针。
    - 设置窗口内的和cur，由于是等差数列，cur可由（a1+an）n/2的等差数列求和公式求得。
    - 当cur<sum时，可以增大big指针，增加窗口内的数值，以此增大cur的值
    - 当cur>sum时，可以增大small指针，减少窗口内的数值，以此减小cur的值
    - 当cur=sum时，循环将窗口内的序列添加到list内，并big++来继续寻找符合的序列。
    - 当small追上big时，表示不再有符合条件的序列了。跳出循环。
  - 注意：
    - 本题默认`public ArrayList<ArrayList<Integer> > FindContinuousSequence(int sum)`，即元素为ArrayList的ArrayList
    - ArrayList<Integer>: list.add(i);
    - ArrayList<ArrayList<Integer>>: result.add(list);

- ## 代码链接
  - [和为S的连续正数序列](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/57_2_%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 58.1 翻转单词顺序列
- ## 题目描述
  - 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？
  - 说明：LeetCode相关题目<151题-medium>中对本题进行了修改，加入对空格的处理，如下：
    - 无空格字符构成一个单词。
    - 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
    - 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。

- ## 解题思路
  - 思路：两次翻转(字符角度)；一次翻转(字符串角度)
  - 注：本题按照对空格处理和不对空格处理，分别整理代码。
  - 分析：
    - 两次翻转：从字符数组的角度，一次翻转所有字母，一次翻转每个单词。每个单词以空格分隔。
    - 一次翻转：从字符串数组的角度，从后遍历字符串数组，并添加到可变字符串，判断后添加一个空格。
    - 翻转：即依次交换收尾，然后夹逼。
    - 可以将翻转功能定义为private函数然后直接调用，提高代码复用性。
    - 多空格：`String[] s1=s.trim().split(" +");` -- 加上+以后，可以剪去字符串之间的多个空格，只保留非空格字符。  
  - 算法1：两次翻转
    - 定义翻转指定索引值的字符串的函数并定义为私有；
    - 首先处理空格：剪去所有空格后，将字符串数组重新用一个空格连起来；
    - 将字符串转为字符数组；
    - 定义双指针：大指针遍历并找空格，小指针为要翻转单词的首个索引；
    - 遍历：翻转每个单词；
    - 翻转整个字符串；
    - 返回：新建字符串，并将字符数组传入。
  - 算法2：一次翻转
    - 首先处理空格：剪去所有空格后，将字符串数组重新用一个空格连起来；
    - 定义可变字符串StringBuilder；
    - 从后遍历字符串数组：如果不是第一个元素，则额外添加空格，否则，只添加元素本身；
    - 将可变字符串转为String类型，并返回。
    - 注：简单多了，但是用了很多库函数吧。

- ## 代码链接
  - [翻转单词顺序列](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/58_1_%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 58.2 左旋转字符串
- ## 题目描述
  - 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。
  - 请定义一个函数实现字符串左旋转操作的功能。
  - 比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。
  - 示例 1：
    - 输入: s = "abcdefg", k = 2
    - 输出: "cdefgab"
  - 示例 2：
    - 输入: s = "lrloseumgh", k = 6
    - 输出: "umghlrlose"
  - 限制：1 <= k < s.length <= 10000

- ## 解题思路
  - 思路：三次翻转
    - 具体地，先将 "abc" 和 "XYZdef" 分别翻转，得到 "cbafedZYX"，然后再把整个字符串翻转得到 "XYZdefabc"
  - 注意：仍然是先转成字符数组进行操作，最后再转成String返回
  - 算法：
    - 定义翻转函数；
    - 边界值判断；（如果题目规定边界值，可简化或省略）
    - 将字符串转为字符数组；
    - 整体翻转以及分别翻转两段字符串；
    - 重新构建字符串并返回。
  - 注意：
    - return Arrays.toString(chs); //返回值："[f, g, a, b, c, d, e]"，不符合格式
    - 翻转时注意先整体翻转还是后整体翻转，先后顺序不同，则两端字符串的翻转范围也不一样。
  - 直接用库函数substring：注意是左闭右开的。
  
- ## 代码链接
  - [左旋转字符串](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/58_2_%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 59.1 滑动窗口的最大值
- ## 题目描述
  - 给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
  - 返回滑动窗口中的最大值。

- ## 解题思路
  - 同LeetCode239题
  - 思路：暴力法；双向队列；动态规划
  - ### 暴力法：
    - 复杂度：时间O(nk)，空间O(n-k+1)，n是数组元素个数
    - 遍历每个滑动窗口，找到每个窗口的最大值。
    - 一共有 N - k + 1 个滑动窗口，每个有 k 个元素，于是算法的时间复杂度为 O(Nk)，表现较差。
    - 算法：
      - 定义数组元素个数n
      - 判空：`n*k==0`，意味着n和k中存在0，此时，新建长度为0的数组并返回
        - 注：测试用例`输入：[] 0; 输出：[]`，因此判空不能返回null，需要返回新建长度为0的数组
      - 定义结果数组output，数组长度为滑动窗口个数 `n-k+1`
      - 两层循环：外层控制起始，内层控制小窗口内的遍历
        - 定义最大值max，遍历本窗口内的所有数字并更新max，然后将max作为output[i]存入结果数组
      - 返回结果数组
  - ### 双向队列
    - 复杂度：时间O(n)，空间O(n)
    - 存储双向队列的索引，以优化时间复杂度
      - 队首存储每个窗口的最大值，队尾存储可能成为最大值的其他元素（当最大值滑出后）
    - 先遍历第一个窗口，找出最大值；然后从第二个窗口开始遍历，以每个窗口最右端为基准，遍历至最后一个元素
    - 清理双向队列:
      - 只保留当前滑动窗口中有的元素的索引。
      - 移除比当前元素小的所有元素，它们不可能是最大的。
    - 算法：
      - 定义数组元素个数n；
      - 判空：`n*k==0`；
      - 边界值：`k=1`时返回原数组；
      - 新建数组双端队列deq：`ArrayDeque<Integer> deq = new ArrayDeque<Integer>();`；
      - 定义窗口最大值对应的索引max_index；
      - 首先：遍历第一个窗口，清理队首队尾，将元素添加到队列last，并找出最大值；
      - 定义输出数组output，并将第一个元素初始化为max_index对应的元素；
      - 其次：以每个窗口的最右端为基准，从第二个窗口开始，遍历至数组末尾最后一个元素
        - 首先清理队首first：判断 -- 当队列不为空，且队首等于本窗口最左侧的左侧元素时，移除首位（i-k是已经滑出本窗口的最近索引）；
        - 其次清理队尾last：循环（可能存在多个不符的队尾元素） -- 当队列不为空，且当前元素大于队尾时，移除队尾元素；
          - 这里：如果i索引值大于已有队尾，会在这一步移除，因此，下一步直接添加到队尾即可，包含了两种情况
        - 将当前元素的索引添加到队列（作为在最大值滑出窗口后，可能成为最大值的元素，放入队尾）
        - 最后将队首索引值对应的数组元素赋值给第i个元素
      - 返回结果数组output
      - 注：
        - 存入队列的是索引值，不是数组元素值；
        - 赋值给结果数组output的是队首索引值对应的数组元素，不是直接将队首元素存入结果数组；
        - 清理队首队尾重复代码，可以封装到一个函数中，这里就全写在同一个函数中了；

- ## 代码链接
  - [滑动窗口的最大值](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/59_1_滑动窗口的最大值.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 59.2 队列的最大值
- ## 题目描述


- ## 解题思路


- ## 代码链接
  - [队列的最大值]()

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->




# 60. n 个骰子的点数
- ## 题目描述


- ## 解题思路


- ## 代码链接
  - []()

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 61. 扑克牌顺子
- ## 题目描述
  - 从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。
  - 示例 1:
    - 输入: [1,2,3,4,5]
    - 输出: True
  - 示例 2:
    - 输入: [0,0,1,2,5]
    - 输出: True
  - 限制：
    - 数组长度为 5 
    - 数组的数取值为 [0, 13] .

- ## 解题思路
  - 解题思路：
    - 思路：排序+判重+求差
    - 分析：
      - 根据题意，此 5 张牌是顺子的 充分条件 如下：
        - 除大小王外，所有牌 无重复 ；
        - 设此 5 张牌中最大的牌为 max ，最小的牌为 min （大小王除外），则需满足：max−min<5
    - 算法：
      - 初始化joker=0；
      - 对数组进行排序：用Arrays.sort(array);
      - 遍历数组：统计大小王，并判重
        - 统计大小王：为0时，joker++；
        - 判重：n[i]==n[i+1]时，说明有重复数字，则false；
      - 求差：根据分析中的规律，当n[4]-n[joker]<5时，可以组成顺子
        - 注：中间间隔的部分用大小王填充，只要符合最值的差小于5即可。

- ## 代码链接
  - [扑克牌顺子](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/61_扑克牌中的顺子.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 62. 圆圈中最后剩下的数字
- ## 题目描述
  - 0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。
  - 例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。
  - 示例 1：
    - 输入: n = 5, m = 3
    - 输出: 3
  - 示例 2：
    - 输入: n = 10, m = 17
    - 输出: 2
  - 限制：
    - 1 <= n <= 10^5
    - 1 <= m <= 10^6

- ## 解题思路
  - 约瑟夫环问题的思路：
    - 模拟链表：时间复杂度O(n^2)
    - 数学方法：时间复杂度O(n)
  - 分析：
    - 选择时间复杂度更低的数学方法
    - 规律：上一轮索引 = (当前index + m) % 上一轮剩余数字的个数
      - 从最后一轮开始逆推；
      - 最后一轮：剩余一个数字res，只有一个索引值0；
      - 上一轮：剩余两个数字，res在本轮的索引值a = (0 + m) % 2;
      - 上一轮：剩余三个数字，res在本轮的索引值b = (a + m) % 3;
      - 以此类推，逆推至n，最终的结果即为首轮中res的索引值。
  - 算法：
    - 判空：m<1或n<1时，return -1;
    - 初始化res=0;
    - for循环遍历：最后一轮剩余一个，index=0，上一轮剩余两个，从i=2开始遍历
      - 循环体：`res = (res + m) % i;`
    - 返回结果：`return res;`

- ## 代码链接
  - [圆圈中最后剩下的数字](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/62_圆圈中最后剩下的数字.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 63. 股票的最大利润
- ## 题目描述
  - 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
  - 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。
  - 注意你不能在买入股票前卖出股票。
  - 限制：0 <= 数组长度 <= 10^5
  - 示例 1: 输入: [7,1,5,3,6,4]，输出: 5
    - 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
    - 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
  - 示例 2: 输入: [7,6,4,3,1]，输出: 0
    - 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0

- ## 解题思路
  - 思路：暴力法；一次遍历
  - 暴力法：
    - 复杂度：时间O(n^2)，空间O(1)
    - max初始化为0(至少为0)；
    - 两次遍历：外层控制开始位置，内层比较从开始位置往后的值，并不断更新减去开始结点所得的最大值。
    - 最终返回max。
  - 一次遍历：
    - 复杂度：时间O(n)，空间O(1)
    - 思路：找到最小的谷之后的最大的峰
    - 维持两个变量 - minprice 和 maxprofit，它们分别对应迄今为止所得到的最小的谷值和最大的利润（卖出价格与最低价格之间的最大差值）。
    - 算法：定义两个最值并初始化；遍历：先小后大 - 当[i]值更小时，更新min，否则，比较[i]-min与max的大小并更新max；返回max。

- ## 代码链接
  - [股票的最大利润](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/63_股票的最大利润.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 64. 求1+2+3+...+n
- ## 题目描述
  - 求1+2+3+...+n
  - 要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

- ## 解题思路
  - 思路：递归，短路与
  - 分析：
    - 求前n项和：等差数列求和公式有乘除；逐项累加用到循环；
    - 递归：不能用循环的情况下，只能用递归来实现循环的过程；
    - &&：短路可以用来做判断，前一个成立则做后一个，前一个不成立时，后一个不再做。
    - 综：利用短路 && 来实现 if 的功能；利用递归来实现循环while的功能
  - 算法： 
    - 借助一个不需要返回的布尔型值来实现这个与运算递归过程。
    - 从n开始往前递归，在最开始的地方0不操作并返回值：
    - 当n==0时，(n>0)&&((sum+=Sum_Solution(n-1))>0)只执行前面的判断，为false，然后直接返回0；
    - 当n>0时，执行sum+=Sum_Solution(n-1)，实现递归计算Sum_Solution(n)。
  - 注意：双与连接的都是布尔型变量，可以在进行计算的`sum+=..`部分加一个`>0`之类的判断。
  - 思路拓展：同样的道理，用双或||也是可以的，详见代码

- ## 代码链接
  - [求1+2+3+...+n](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/64_%E6%B1%821%2B2%2B3%2B...%2Bn.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 65. 不用加减乘除做加法
- ## 题目描述
  - 写一个函数，求两个整数之和，要求在函数体内不得使用加减乘除四则运算符号。

- ## 解题思路
  - 首先看十进制是如何做的： 5+7=12，三步走
    - 第一步：相加各位的值，不算进位，得到2。
    - 第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。
    - 第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。
  - 用三步走的方式计算二进制值相加： 5-101，7-111 
    - 第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。
    - 第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&111)<<1。
    - 第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&1010)<<1。
    - 继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。
  - 综上，使用异或和左移进行加法运算，在进位相加时（遇加法可调用本函数）递归，重复以上两步
  - 算法：
    - 不进位相加：0+0,1+1得0,而1+0,0+1得1，这与“异或”运算的结果相同，即不同时得1，反之得0.
    - 进位：0+0,1+0,0+1都不进位，只有1+1进位，这与“与运算”的结果相同，且进位在高一位，因此左移1位；
    - 将第一步的“不进位相加”结果与第二步的“进位并左移”结果相加：相加又可以调用本体函数，构成循环；
    - 重复，直到不产生进位：只有存在进位时，才需要继续做加法；若没有进位，则循环停止。
    - 然而事实是：循环停止的条件是，当两个数中有一个数变为0时，返回另一个数
  - 关键要找到这个规律
    - 两个数异或：相当于每一位相加，而不考虑进位；
    - 两个数相与，并左移一位：相当于求得进位；
    - 将上述两步的结果相加，相加则递归
    
- ## 代码链接
  - [不用加减乘除做加法](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/65_%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 66. 构建乘积数组
- ## 题目描述
  - 给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1]
  - 其中B中的元素B[i]=A[0]×A[1]×...×A[i-1]×A[i+1]×...×A[n-1]。
  - 不能使用除法。

- ## 解题思路
  - B[i]的值可以看作对角线为1、其余每行为A[i]的矩阵中每行的乘积。
  - 下三角用连乘可以很容求得，上三角，从下向上也是连乘。
  - 因此可以先算下三角中的连乘，即先算出B[i]中的一部分，然后倒过来按上三角中的分布规律，把另一部分也乘进去。
  - 规律：下三角从上到下递归，上三角从下到上递归。注意循环的起点。
  - 配合矩阵图食用效果更佳。

- ## 代码链接
  - [构建乘积数组](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/65_%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 67. 把字符串转换成整数
- ## 题目描述
  - 将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0
  - 输入描述: 输入一个字符串,包括数字字母符号,可以为空
  - 输出描述: 如果是合法的数值表达则返回该数字，否则返回0
  - 示例：
    - 输入：+2147483647     1a33
    - 输出：2147483647      0

- ## 解题思路


- ## 代码链接
  - []()

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 68. 树中两个节点的最低公共祖先
- ## 题目描述


- ## 解题思路


- ## 代码链接
  - []()

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->

