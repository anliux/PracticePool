# 剑指Offer题解目录
### 参考：[cyc大神剑指题解](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md)

<!-- GFM-TOC -->
* [2. 单例模式](#2-单例模式)
* [3. 数组中重复的数字](#3-数组中重复的数字)
* [4. 二维数组中的查找](#4-二维数组中的查找)
* [5. 替换空格](#5-替换空格)
* [6. 从尾到头打印链表](#6-从尾到头打印链表)
* [7. 重建二叉树](#7-重建二叉树)
* [8. 二叉树的下一个结点](#8-二叉树的下一个结点)
* [9. 用两个栈实现队列](#9-用两个栈实现队列)
* [10.1 斐波那契数列](#101-斐波那契数列)
* [10.2 矩形覆盖](#102-矩形覆盖)
* [10.3 跳台阶](#103-跳台阶)
* [10.4 变态跳台阶](#104-变态跳台阶)
* [11. 旋转数组的最小数字](#11-旋转数组的最小数字)
* [12. 矩阵中的路径](#12-矩阵中的路径)
* [13. 机器人的运动范围](#13-机器人的运动范围)
* [14. 剪绳子](#14-剪绳子)
* [15. 二进制中 1 的个数](#15-二进制中-1-的个数)
* [16. 数值的整数次方](#16-数值的整数次方)
* [17. 打印从 1 到最大的 n 位数](#17-打印从-1-到最大的-n-位数)
* [18.1 在 O(1) 时间内删除链表节点](#181-在-o1-时间内删除链表节点)
* [18.2 删除链表中重复的结点](#182-删除链表中重复的结点)
* [19. 正则表达式匹配](#19-正则表达式匹配)
* [20. 表示数值的字符串](#20-表示数值的字符串)
* [21. 调整数组顺序使奇数位于偶数前面](#21-调整数组顺序使奇数位于偶数前面)
* [22. 链表中倒数第 K 个结点](#22-链表中倒数第-k-个结点)
* [23. 链表中环的入口结点](#23-链表中环的入口结点)
* [24. 反转链表](#24-反转链表)
* [25. 合并两个排序的链表](#25-合并两个排序的链表)
* [26. 树的子结构](#26-树的子结构)
* [27. 二叉树的镜像](#27-二叉树的镜像)
* [28. 对称的二叉树](#28-对称的二叉树)
* [29. 顺时针打印矩阵](#29-顺时针打印矩阵)
* [30. 包含 min 函数的栈](#30-包含-min-函数的栈)
* [31. 栈的压入、弹出序列](#31-栈的压入弹出序列)
* [32.1 从上往下打印二叉树](#321-从上往下打印二叉树)
* [32.2 把二叉树打印成多行](#322-把二叉树打印成多行)
* [32.3 按之字形顺序打印二叉树](#323-按之字形顺序打印二叉树)
* [33. 二叉搜索树的后序遍历序列](#33-二叉搜索树的后序遍历序列)
* [34. 二叉树中和为某一值的路径](#34-二叉树中和为某一值的路径)
* [35. 复杂链表的复制](#35-复杂链表的复制)
* [36. 二叉搜索树与双向链表](#36-二叉搜索树与双向链表)
* [37. 序列化二叉树](#37-序列化二叉树)
* [38. 字符串的排列](#38-字符串的排列)
* [39. 数组中出现次数超过一半的数字](#39-数组中出现次数超过一半的数字)
* [40. 最小的 K 个数](#40-最小的-k-个数)
* [41.1 数据流中的中位数](#411-数据流中的中位数)
* [41.2 字符流中第一个不重复的字符](#412-字符流中第一个不重复的字符)
* [42. 连续子数组的最大和](#42-连续子数组的最大和)
* [43. 从 1 到 n 整数中 1 出现的次数](#43-从-1-到-n-整数中-1-出现的次数)
* [44. 数字序列中的某一位数字](#44-数字序列中的某一位数字)
* [45. 把数组排成最小的数](#45-把数组排成最小的数)
* [46. 把数字翻译成字符串](#46-把数字翻译成字符串)
* [47. 礼物的最大价值](#47-礼物的最大价值)
* [48. 最长不含重复字符的子字符串](#48-最长不含重复字符的子字符串)
* [49. 丑数](#49-丑数)
* [50. 第一个只出现一次的字符位置](#50-第一个只出现一次的字符位置)
* [51. 数组中的逆序对](#51-数组中的逆序对)
* [52. 两个链表的第一个公共结点](#52-两个链表的第一个公共结点)
* [53. 数字在排序数组中出现的次数](#53-数字在排序数组中出现的次数)
* [54. 二叉查找树的第 K 个结点](#54-二叉查找树的第-k-个结点)
* [55.1 二叉树的深度](#551-二叉树的深度)
* [55.2 平衡二叉树](#552-平衡二叉树)
* [56. 数组中只出现一次的数字](#56-数组中只出现一次的数字)
* [57.1 和为 S 的两个数字](#571-和为-s-的两个数字)
* [57.2 和为 S 的连续正数序列](#572-和为-s-的连续正数序列)
* [58.1 翻转单词顺序列](#581-翻转单词顺序列)
* [58.2 左旋转字符串](#582-左旋转字符串)
* [59. 滑动窗口的最大值](#59-滑动窗口的最大值)
* [60. n 个骰子的点数](#60-n-个骰子的点数)
* [61. 扑克牌顺子](#61-扑克牌顺子)
* [62. 圆圈中最后剩下的数](#62-圆圈中最后剩下的数)
* [63. 股票的最大利润](#63-股票的最大利润)
* [64. 求 1+2+3+...+n](#64-求-123n)
* [65. 不用加减乘除做加法](#65-不用加减乘除做加法)
* [66. 构建乘积数组](#66-构建乘积数组)
* [67. 把字符串转换成整数](#67-把字符串转换成整数)
* [68. 树中两个节点的最低公共祖先](#68-树中两个节点的最低公共祖先)
<!-- GFM-TOC -->



# 2. 单例模式
- ## 解题思路
  - 设计模式：解决某一类问题的行之有效的解决办法（或思想）
  - 单例模式即只生成一个实例，可以保证一个类的对象的唯一性。
  - 分析：
    - 构造函数私有：一个类只要提供了构造函数就可以产生多个对象，故私有构造函数
    - 因为不让其他程序创建对象，故自己在本类中new一个对象，并设为静态私有，好处是可控
      注：静态 -- 防止无法从静态上下文中访问非静态变量
    - 创建一个getInstance功能，对外提供访问接口，设为公共静态
  - 分为懒汉式和饿汉式。
  - 饿汉式：直接new，开发常用
  - 懒汉式：单例的延迟加载，当调用到时再new，面试多见
    - 懒汉式并发访问：加入同步机制解决安全问题，通过双重判断是否为空来减少访问锁的次数以提高效率

- ## 代码链接
  - [单例模式](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/02_%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.java)



# 3. 数组中重复的数字

- ## 题目描述
  - 在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。
  - 数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。
  - 请找出数组中任意一个重复的数字。

```html
Input: {2, 3, 1, 0, 2, 5}
Output: 2
```

- ## 解题思路
  - 要求时间复杂度 O(N)，空间复杂度 O(1)。因此不能使用排序的方法，也不能使用额外的标记数组。
  - 对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。
  - 考虑测试用例：无效（空指针，包含0-n-1之外数字），不包含重复数字等。
  - 以数组下标i为单位遍历并比较，符合时交换，直到下标对应的数字等于下标值时，进入i+1的比较。
  - 注意：交换时用到numbers[temp]而不是numbers[numbers[i]]；交换在while循环里
  - 以 (2, 3, 1, 0, 2, 5) 为例，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复

- ## 代码链接：
  - [数组中重复的数字](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/03_%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.java)



# 4. 二维数组中的查找

- ## 题目描述
  - 给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。
  - 给定一个数，判断这个数是否在该二维数组中。

```html
Consider the following matrix:
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

Given target = 5, return true.
Given target = 20, return false.
```

- ## 解题思路
  - 要求时间复杂度 O(M + N)，空间复杂度 O(1)。其中 M 为行数，N 为 列数。
  - 该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。
  - 考虑从右上角或者左下角开始，可以避免可能选取区域重叠。
  - 右上角：左侧为小于，下侧为大于。若小，下移；若大，左移。
  - 测试用例考虑：有目标；没有目标（大于max，小于min，介于但不存在）；空指针；行列数非正
  - 空指针即地址为null，行列数非正，这两个需要排除。而没有目标中各种情况都属于找不到，返回false即可，无需特意判断。
  - 注1：因为多次使用到行列数，判空之后循环之前，赋值给变量：int rows = array.length， int cols = array[0].length;
  - 注2：注意循环时阈值设置，不要太大防止角标越界，不要太小防止取不到所有。
  
 - ## 代码链接：
   - [二维数组中的查找](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/04_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.java)



# 5. 替换空格

- ## 题目描述
  - 将一个字符串中的空格替换成 "%20"。

```text
Input:
"A B"

Output:
"A%20B"
```

- ## 解题思路
  - 对于URL参数：无法识别特殊字符，故空格替换为"%20"，#替换为"%23"
  - 由于空格的一个字符变为三个字符，替换后变长，两种思路：创建新字符串和在原字符串修改。
  - 原字符串修改且空间充足时：正遍历-多空格时，部分字符会移动多次，时间复杂度太高；逆遍历-O(n)
  - 首先计算空格数得到最终字符串末尾，P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。
  - P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。
  - 从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。
  - 知识点 - str函数：
    - `str.charAt(i)`-获取i处某值
    - `str.setCharAt(i,'m')`-m赋值给i处
    - `str.length()`-获取str长度
    - `str.append("abc")`-在str新增
  - 注意：`str.charAt()`获取到的是字符型，用单引号；`str.setCharAt(int, char)`中Char的C大写

- ## 代码链接
  - [替换空格](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/05_%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.java)
  


# 6. 从尾到头打印链表
  
- ## 题目描述
  - 从尾到头反过来打印出单链表的每个结点的值。

- ## 解题思路
  ### 使用栈
  - 栈具有后进先出的特点，从第一个结点开始遍历后最后一个第一个输出，是典型的“后进先出”。
  - 思路：新建栈 -- 遍历并压栈直至尾结点为空 -- 新建容器 -- 遍历并弹栈直至栈空 -- 返回容器
  - 知识点：
    - 新建栈：`Stack<Integer> stack = new Stack<>();`
    - 压栈：`stack.add(i);`  弹栈：`stack.pop();`  栈空：`stack.isEmpty()==true;`
    - java链表：`ListNode listnode`  取值：`listNode.val;`  下一值：`listNode.next;`
    - 容器泛型之类的（不太会..）：`ArrayList<Integer> ret = new ArrayList<>();`
   - 注意：使用栈Stack要加这句：`import java.util.Stack;`

  ### 使用递归
  - 递归在本质上是一个栈结构，故可以考虑递归。
  - 先递归输出后面的结点，再输出该结点本身。
  - 思路：新建容器 -- 判断结点是否为空，空则调用本身并传入next结点，直到为空时打印，然后返回上一个函数调用并打印，直到最外层 -- 返回容器
  - 要逆序打印链表 1->2->3（3,2,1)，可以先逆序打印链表 2->3(3,2)，最后再打印第一个节点 1。
    而链表 2->3 可以看成一个新的链表，要逆序打印该链表可以继续使用求解函数，也就是在求解函数中调用自己，这就是递归函数。
  - 知识点：
    - add方法与addAll方法的区别：
      - Add方法是将传入的参数作为当前List中的一个item存储，即使传入一个List也只令当前的List增加1个元素
      - AddAll是传入一个List，将此List中的所有元素加入到当前List中，也就是当前List会增加的元素个数为传入的List的大小
      - `addAll(Collection c)`
      - `add(int index,Elelemt e)`
  
  ### 使用头插法（未实践）
  - 使用头插法可以得到一个逆序的链表。
  - 头结点和第一个节点的区别：
     - 头结点是在头插法中使用的一个额外节点，这个节点不存储值；
     - 第一个节点就是链表的第一个真正存储值的节点。

- ## 代码链接
  - [从尾到头打印链表](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/06_%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.java)
 
  
  
# 7. 重建二叉树
- ## 题目描述
  - 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。
  - 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
  - 例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

- ## 解题思路
  - 因为是树的结构，一般都是用递归来实现。
  - 用数学归纳法的思想就是，假设最后一步，就是root的左右子树都已经重建好了，那么只要考虑将root的左右子树安上去即可。
  - 根据前序遍历的性质，第一个元素必然就是root，那么下面的工作就是如何确定root的左右子树的范围。
  - 根据中序遍历的性质，root元素前面都是root的左子树，后面都是root的右子树。那么我们只要找到中序遍历中root的位置，就可以确定好左右子树的范围。
  - 正如上面所说，只需要将确定的左右子树安到root上即可。
  - 递归要注意出口，假设最后只有一个元素了，那么就要返回。  
  - 知识点：
    - `Arrays.copyOfRange(T[ ] original,int from,int to)` ：将一个原始的数组original，从下标from开始复制，复制到下标to，生成一个新的数组。注意这里包括下标from，不包括下标to。
 
 - ## 代码链接
   - [重建二叉树](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/07_%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.java)
  
  
  
# 8. 二叉树的下一个结点
- ## 题目描述
  - 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。
  - 注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。
   
- ## 解题思路
  - 若该结点存在右子树：则下一个结点为右子树最左子结点；若没有左子结点，则下一个结点即该右子树的根结点本身
  - 若该结点不存在右子树，分两种情况： 
    - 1 该结点为父结点的左子结点，则下一个结点为其父结点
    - 2 该结点为父结点的右子结点，则沿着父结点向上遍历，直到找到一个结点，它是其父结点的左子结点，则该结点的父结点是下一个结点
  - 思路：判空则返回 -- 判断该结点的右结点是否为空，并分两类情况进行讨论
  - 注意：没有右子且不是其父的左子的情况比较复杂，但是代码体现比较简单，只是循环。
  
- ## 代码链接
  - [二叉树的下一个结点](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/08_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9.java)



# 9. 用两个栈实现队列
- ## 题目描述
  - 用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。

- ## 解题思路
  - 栈“先入后出”，而队列“先入先出”，可利用两个栈的两次“先入后出”使得最终顺序为“先入先出”
    - 具体地，一个元素进入栈1之后，出栈的顺序被反转。当元素要出栈时，需要先进入2栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。
  - 只在栈1入栈（push）操作，只在栈2出栈（pop）操作。
    - 入栈即栈1入栈
    - 出栈需要先对栈2判空，若非空，直接出；若空，需要从栈1弹出后栈2入栈，直到栈1空，此时第一个进栈的在栈2top，可以弹出。
  - 思路：栈1push，栈2pop；pop先判空，都空时抛出异常；栈2非空时直接pop，栈2空时先栈1pop进栈2，再栈2pop
  - 知识点：
    - 使用栈要声明：`import java.util.Stack;`
    - 创建栈：`Stack<Integer> stackname = new Stack<Integer>();`
    - 压栈：stackname.push(val);
    - 弹栈：stackname.pop(); -- 弹栈会返回原栈顶值，可赋值给变量使用
    - 栈空：stackname.empty(); 空则true，否则false

- ## 代码链接
  - [用两个栈实现队列](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/09_%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.java)
  


# 10.1 斐波那契数列
- ## 题目描述
  - 现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n<=39
  - f(0)=0; f(1)=1; f(n)=f(n-1)+f(n-2),n>=2
  
- ## 解题思路
  - 斐波那契数列属于典型的递归，但是用递归求解的话，过多重复，时间效率低。
  - 考虑用循环实现递归，可以极大地提高时间效率。
    - 时间复杂度：O(n)
    - 第 i 项只与第 i-1 和第 i-2 项有关，因此只需要存储前两项的值就能求解第 i 项，从而将空间复杂度由 O(N) 降低为 O(1)。
    - 规定n<=39故在int范围内
  - 还有一种转换为求矩阵的乘方，思考过多不作考虑。

- ## 代码链接
  - [斐波那契数列](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/10_1_%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.java)



# 10.2 矩形覆盖
- ## 题目要求
  - 我们可以用2×1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2×1的小矩形无重叠地覆盖一个2×n的大矩形，总共有多少种方法？

- ## 解题思路
  - 被覆盖的大矩形是两行n列的（画示意图更明显，此处省略图）
  - n=1时：只有一种方法
  - n=2时：有横着覆盖和竖着覆盖两种方法
  - n>=2时：分为两种情况
    - 若第一个小矩形竖着，则剩余n-1个区域的覆盖方法记为f(n-1)
    - 若第一个小矩形横着，则它下方也应该横着填一个小矩形，则剩余n-2个区域的覆盖方法记为f(n-2)
    - 即f(n)=f(n-1)+f(n-2),n>=2
  - 综上，此问题可归结为斐波那契数列相同的问题。
  - 同上，依然是用循环来实现递归
  - 注意：首项和第二项与原斐波那契数列有不同。
  - 注意：代码初始化返回值时，要赋值，不能空着（比如int result;）会报错的。

- ## 代码链接
  - [矩阵覆盖](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/10_2_%E7%9F%A9%E9%98%B5%E8%A6%86%E7%9B%96.java)



# 10.3 跳台阶
- ## 题目描述
  - 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

- ## 解题思路
  - 当n=1时：只有1种跳法
  - 当n=2时：有2种跳法 -- 一级一级跳两次或者一次跳两级
  - 当n>=2时：分为两种情况
    - 当第一次跳一级，则跳法数等于剩余台阶的跳法f(n-1)
    - 当第一次跳两级，则跳法数等于剩余台阶的跳法f(n-2)
    - 即f(n)=f(n-1)+f(n-2),n>=2
  - 综上，跳台阶问题可以归结为斐波那契数列问题。

- ## 代码链接
  - [跳台阶](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/10_3_%E8%B7%B3%E5%8F%B0%E9%98%B6.java)



# 10.4 变态跳台阶
- ## 题目描述
  - 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

- ## 解题思路之数学推导：
  - 跳上 n-1 级台阶，可以从 n-2 级跳 1 级上去，也可以从 n-3 级跳 2 级上去...，那么
    - f(n-1) = f(n-2) + f(n-3) + ... + f(0)
  - 同样，跳上 n 级台阶，可以从 n-1 级跳 1 级上去，也可以从 n-2 级跳 2 级上去... ，那么
    - f(n) = f(n-1) + f(n-2) + ... + f(0)
  - 综上可得：f(n) - f(n-1) = f(n-1)
  - 即：f(n) = 2×f(n-1) 是等比数列，1,2，公比2可用位移运算优化
  - 用位移运算，1<<(target-1)，非正情况另考虑，从1开始到n都是符合公式的。

- ## 代码链接
  - [变态跳台阶](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/10_4_%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6.java)



# 11. 旋转数组的最小数字
- ## 题目描述
  - 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
  - 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
  - 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
  - NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

- ## 解题思路1：暴力搜索最小值
  - 虽然是面试官不愿意看到的废柴方法，但是牛客里可以ac，亲测....
  - 但是还是尽量不要这样做吧，除非没别的想法了
  
- ## 解题思路2：暴力搜索是否符合非降序
  - 在两段范围内都是非降序，当不符合这个规律时，就找到了最小数字
  
- ## 解题思路3：排序
  - 既然是找最小值，使用排序也是很常规的思路
  - 利用 Arrays 工具类里的排序函数，默认的排序规则是从小到大，排序后的数组第一个值就是最小值
  - 注意：需要import Arrays，干脆util.*
  
- ## 解题思路4：变相二分查找
  - 首先，因为有一定排序，故不能使用遍历整个数组，找出其中最小的数。(其实可以ac，亲测)
  - 因为有一定排序，故使用二分：
    - 大数组在前，小数组在后
    - 最小元素应该在大数组和小数组的交界处，且位于小数组的第一个
    - low，high分别指向数组的首尾，则low指向大数组，high指向小数组
    - 取mid=(low+high)/2
    - 若mid位于大数组，则大于等于low，最小值在mid后，故low向前移动到mid位置
    - 若mid位于小数组，则小于等于high，最小值在mid前，故high向后移动到mid位置
    - low和high不断向中间移动，最终将相邻，而high正好指向最小值，这是循环判停的条件：high-low==1，
  - 非递减，需要考虑相同数字的情况，比如数组 {1,1,1,0,1}
    - 对于不符合以上分类的情况
    - 此时无法用二分判断，故使用遍历方法暴力求解找到最小值

- ## 代码链接
  - [旋转数组的最小数字](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/11_%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.java)



# 12. 矩阵中的路径
- ## 题目描述
  - 请设计一个函数，用来判断在一个矩阵中**是否**存在一条包含某字符串所有字符的路径。
  - 路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。
  - 如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 
  - 例如 a b c e s f c s a d e e 矩阵中包含一条字符串"bccced"的路径，但是矩阵中不包含"abcb"路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。
  - 注意：传入的是一维矩阵，行数，列数，目标str

- ## 解题思路
  - 使用回溯法（backtracking）进行求解，它是一种暴力搜索方法，通过搜索所有可能的结果来求解问题。
  - 回溯法在一次搜索结束时需要进行回溯（回退），将这一次搜索过程中设置的状态进行清除，从而开始一次新的搜索过程。
  - 思路
    - 0.根据给定数组，初始化一个标志位数组，初始化为false，表示未走过，true表示已经走过，不能走第二次
    - 1.根据行数和列数，遍历数组，先找到一个与str字符串的第一个元素相匹配的矩阵元素，进入judge
    - 2.根据i和j先确定一维数组的位置，因为给定的matrix是一个一维数组
    - 3.确定递归终止条件：越界，当前找到的矩阵值不等于数组对应位置的值，已经走过的，这三类情况，都直接false，说明这条路不通
    - 4.若k，就是待判定的字符串str的索引已经判断到了最后一位，此时说明是匹配成功的
    - 5.下面就是本题的精髓，递归不断地寻找周围四个格子是否符合条件，只要有一个格子符合条件，就继续再找这个符合条件的格子的四周是否存在符合条件的格子，直到k到达末尾或者不满足递归条件就停止。
    - 6.走到这一步，说明本次是不成功的，我们要还原一下标志位数组index处的标志位，进入下一轮的判断。

- ## 代码链接
  - [矩阵中的路径](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/12_%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84.java)



# 13. 机器人的运动范围
- ## 题目描述
  - 地上有一个m行和n列的方格。
  - 一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 
  - 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。
  - 请问该机器人能够达到多少个格子？

- ## 解题思路
  - 深度优先搜索（Depth First Search，DFS）方法。
  - 回溯是深度优先搜索的一种特例，它在一次搜索过程中需要设置一些本次搜索过程的局部状态，并在本次搜索结束之后清除状态。
  - 而普通的深度优先搜索并不需要使用这些局部状态，虽然还是有可能设置一些全局状态。
  - 具体思路同上题，同时加一个位数和的限制条件
  - 注意：
    - flag是二维数组，定义还有传参的时候，别少写方括号[]
    - do{}while(); while之后的分号千万别忘写了。

- ## 代码链接
  - [机器人的运动范围](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/13_%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4.java)



# 14. 剪绳子
- ## 题目描述
  - 把一根长度为n的绳子剪成多段(大于一段)，并且使得每段的长度乘积最大（n为整数，n>1）
  - n = 2， return 1 (2 = 1 + 1)
  - n = 10， return 36 (10 = 3 + 3 + 4)

- ## 解题思路
  - ### 贪心：
    #### 每一步都做一个贪婪的选择，基于这个选择，可以得到最优解。一般需要数学方式证明贪婪选择的正确性。
    - 尽可能多剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现。
    - 如果出现了，就从已经切好长度为 3 的绳子中拿出一段与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。
    - 证明：
      - 当 n >= 5 时，3(n - 3) - n = 2n - 9 > 0，且 2(n - 2) - n = n - 4 > 0。
      - 因此在 n >= 5 的情况下，将绳子剪成一段为 2 或者 3，得到的乘积会更大。
      - 又因为 3(n - 3) - 2(n - 2) = n - 5 >= 0，所以剪成一段长度为 3 比长度为 2 得到的乘积更大。
    - 注：
      - pow() 方法用于返回第一个参数的第二个参数次方。
      - double pow(double base, double exponent) -- 返回值类型默认为double型，而题目要求的是int型，强转为int
  - ### 动态规划：
    - 分析发现符合dp的问题特征：
      - 求一个问题的最优解； 
      - 整体的问题的最优解是依赖于各个子问题的最优解； 
      - 小问题之间还有相互重叠的更小的子问题； 
      - 从上往下分析问题，从下往上求解问题；
    - 不用过多分析，将问题无脑分解为更小的问题。
    - 从小到大，依次计算所有可能解并保存在数组中，直到计算到target为止。
    - 注意：
      - i/2的略微优化没成，就暂时先这样吧..
      - dp[i]的值包含的内容（包括两个嵌套的Math.max()）需要缕清楚，别写错写漏了
  
- ## 代码链接
  - [剪绳子](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/14_%E5%89%AA%E7%BB%B3%E5%AD%90.java)



# 15. 二进制中 1 的个数
- ## 题目描述
  - 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

- ## 解题思路
  - 常规思路：
    - 右移+与1+count计数。
    - 注：与运算结果分为不为0（即1）和为0，故可放在if中作为判断条件。
    - 缺点：负数时最高位的问题。
  - 改进思路：
    - 既然右移数字不成，就左移flag1，之后和给定数字做与运算。
    - 不足：数字的二进制有多少位就需要循环多少次
  - 技巧思路：
    - n=(n-1)&n，当n不为0时，继续循环
    - 时间复杂度：O(M)，其中 M 表示 1 的个数。比上述改进思路稍快。
    - 小结论：把一个整数-1，并和自己做位与运算，相当于把最右边的1变成0.
      - 注：一个整数减去1，相当于把最右边的1变成0的同时，当1的右侧还有0，则把所有0变成1.例如，1100-1=1011. 1100&1011=1000.
  - 调用函数 Integer.bitCount()
    - 计算一个（byte,short,char,int统一按照int方法计算）int,long类型的数值在二进制下“1”的数量。
- ## 代码链接
  - [二进制中1的个数](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/15_%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.java)



# 16. 数值的整数次方
- ## 题目描述
  - 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。
  - 保证base和exponent不同时为0

- ## 解题思路
  - 乘方功能，即实现类似pow()函数的功能
    - 注：double pow(double base, double exponent) -- 返回值类型默认为double型，可根据题目要求进行强转
    - 一行代码：`return Math.pow(base,exponent);`
  - 使用公式递归
    - n=奇数时，a^n=a^(n/2) × a^(n/2);
    - n=偶数时，a^n=a^((n-1)/2) × a^((n-1)/2) × a;
    - 代码中不需要减1的操作，因为会自动取整，结果一样
  - 注意：
    - 考虑指数的特殊情况：为1时返回base，为0时返回1.
    - 考虑指数是负数的情况：设置标志，先把指数取相反数变为正数，用公式计算，最后求结果的倒数（当标志为真时）
    - 可以考虑：用右移代替除以2，用与1运算代替整除取余%，可提高运算效率。
    
- ## 代码链接
  - [数值的整数次方](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/16_%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9.java)



# 17. 打印从 1 到最大的 n 位数
- ## 题目描述
  - 输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。
  - 比如输入 3，则打印出 1、2、3 一直到最大的 3 位数即 999。

- ## 解题思路
  - 由于 n 可能会非常大，因此考虑“大数问题”，不能直接用 int 表示数字，而是用 char 数组或者字符串进行存储。
  - 如果累加，计算量大，效率不高，代码冗长；考虑把问题转换成数字排列，每一位从0-9排列一遍，即可得到结果。
  - 代码终止条件为：当位数增加到等于数组长度时，相当于已经达到最大值，可以停止了。
  - 使用回溯法得到所有的数。
    - 注意：回溯法一定要注意设置好终止条件。
  - 打印时需要考虑不能前非零数字前的0也打印出来。

- ## 代码链接
  - []()



# 18.1 在 O(1) 时间内删除链表节点




# 18.2 删除链表中重复的结点




# 19. 正则表达式匹配






20. 表示数值的字符串
21. 调整数组顺序使奇数位于偶数前面
22. 链表中倒数第 K 个结点
23. 链表中环的入口结点
24. 反转链表
25. 合并两个排序的链表
26. 树的子结构
27. 二叉树的镜像
28. 对称的二叉树
29. 顺时针打印矩阵
30. 包含 min 函数的栈
31. 栈的压入、弹出序列
32.1 从上往下打印二叉树
32.2 把二叉树打印成多行
32.3 按之字形顺序打印二叉树
33. 二叉搜索树的后序遍历序列
34. 二叉树中和为某一值的路径
35. 复杂链表的复制
36. 二叉搜索树与双向链表
37. 序列化二叉树
38. 字符串的排列
39. 数组中出现次数超过一半的数字
40. 最小的 K 个数
41.1 数据流中的中位数
41.2 字符流中第一个不重复的字符
42. 连续子数组的最大和
* [43. 从 1 到 n 整数中 1 出现的次数](#43-从-1-到-n-整数中-1-出现的次数)
* [44. 数字序列中的某一位数字](#44-数字序列中的某一位数字)
* [45. 把数组排成最小的数](#45-把数组排成最小的数)
* [46. 把数字翻译成字符串](#46-把数字翻译成字符串)
* [47. 礼物的最大价值](#47-礼物的最大价值)
* [48. 最长不含重复字符的子字符串](#48-最长不含重复字符的子字符串)



# 49. 丑数
- ## 题目描述
  - 把只包含质因子2、3和5的数称作丑数（Ugly Number）。
  - 例如6、8都是丑数，但14不是，因为它包含质因子7。
  - 习惯上我们把1当做是第一个丑数。
  - 求按从小到大的顺序的第N个丑数。

- ## 解题思路
  - 求丑数的思路：
    - 验证一个数是否是丑数：先看是否能整除2，即取模得0，若可以则整除2直至余数不为0；然后重复3和5
  - 常规思路：
    - 从1开始，依次验证各个数是否符合
    - 问题：对每个数字进行了运算，时间复杂度高
  - 改进思路：
    - 以空间换时间，创建数组保存已经找到的丑数，并在此基础上乘以因子继续找
    - 现在的思路是在丑数的基础上找新的丑数，避免了遍历每个自然数的操作
    - 具体思路：找下一个丑数，设置flag2,3,5，可从已有丑数基础上乘以因子2,3,5，取最小值，同时改变flag值
  - 注意：
    - Math.min()针对两个数，因此写为：`Math.min(next2, Math.min(next3, next5))`

- ## 代码链接
  - [丑数](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/49_%E4%B8%91%E6%95%B0.java)



# 50. 第一个只出现一次的字符位置
- ## 题目描述
  - 在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置
  - 如果没有则返回 -1（需要区分大小写）

- ## 解题思路
  - n个字符，若遍历每个字符并每次扫描整个字符串得到出现次数，时间复杂度是n^2
  - 考虑用哈希表：键设为字符，值设为出现次数，第一次遍历每个字符次数+1，第二次找到
    - 时间复杂度：O(N)，空间复杂度：O(1)
  - 可以用数组实现哈希表
    - 利用每个字母的ASCII码作hash来作为数组的index。
    - 首先用一个58长度的数组来存储每个字母出现的次数，58是因为A-Z对应的ASCII码为65-90，a-z对应的ASCII码值为97-122，而每个字母的index=int(word)-65，比如g=103-65=38，
    - 而数组中具体记录的内容是该字母出现的次数，最终遍历一遍字符串，找出第一个数组内容为1的字母就可以了，时间复杂度为O(n)
  - 注意：
    - ASCII码有256个字符，仅考虑字母（题目说明仅包含字母）
    - ASCII码中的90-96不是字母，但是为了统一减65来计算，所以要再加上6个长度，不然就要判断是否是小写字母，小写字母要减65再减6
    - （无所谓了，写成256大小的数组也可）
    - charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。返回值是一个字符。
    - (int)(charAt())将对应的字符转为int型

- ## 代码链接
  - [第一个只出现一次的字符位置](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/50_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%E4%BD%8D%E7%BD%AE.java)



* [51. 数组中的逆序对](#51-数组中的逆序对)




* [52. 两个链表的第一个公共结点](#52-两个链表的第一个公共结点)




* [53. 数字在排序数组中出现的次数](#53-数字在排序数组中出现的次数)
* [54. 二叉查找树的第 K 个结点](#54-二叉查找树的第-k-个结点)



# 55.1 二叉树的深度
- ## 问题描述
  - 输入一棵二叉树，求该树的深度。
  - 从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。
  
- ## 解题思路
  - 考虑“记录二叉树的路径”的方法比较繁琐
  - 递归的思想。分析规律可知用递归比较快。
  - 可以用三元运算符 A?B:C 将代码化简为一句代码。
  - 分析：
    - 如果只有根节点：深度为1
    - 如果只有左子树：深度为左子树的深度+1
    - 如果只有右子树：深度为右子树的深度+1
    - 如果既有左子树又有右子树：深度为左右子树的深度中的较大值+1
    - 结合图示更清晰

- ## 代码链接
  - [二叉树的深度](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/55_1_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6.java)



# 55.2 平衡二叉树
- ## 题目描述
  - 输入一棵二叉树，判断该二叉树是否是平衡二叉树。
  - 平衡二叉树左右子树高度差不超过 1。

- ## 解题思路
  - 从上到下遍历：在判断上层结点的时候，会多次重复遍历下层结点，增加了不必要的开销。
  - 从下往上遍历：子树是平衡二叉树，则返回子树的高度；发现子树不是平衡二叉树，则直接停止遍历，这样至多只对每个结点访问一次。
  - 后序遍历：左右中。
  - 注：
    - 从下到上，遍历过程中进行判断，一旦不符即可停止。
    - 计算深度时，注意max+1，加1别忘了

- ## 代码链接
  - [平衡二叉树](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/55_2_%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.java)



* [56. 数组中只出现一次的数字](#56-数组中只出现一次的数字)
* [57.1 和为 S 的两个数字](#571-和为-s-的两个数字)
* [57.2 和为 S 的连续正数序列](#572-和为-s-的连续正数序列)
* [58.1 翻转单词顺序列](#581-翻转单词顺序列)
* [58.2 左旋转字符串](#582-左旋转字符串)
* [59. 滑动窗口的最大值](#59-滑动窗口的最大值)
* [60. n 个骰子的点数](#60-n-个骰子的点数)
* [61. 扑克牌顺子](#61-扑克牌顺子)
* [62. 圆圈中最后剩下的数](#62-圆圈中最后剩下的数)
* [63. 股票的最大利润](#63-股票的最大利润)
* [64. 求 1+2+3+...+n](#64-求-123n)
* [65. 不用加减乘除做加法](#65-不用加减乘除做加法)
* [66. 构建乘积数组](#66-构建乘积数组)
* [67. 把字符串转换成整数](#67-把字符串转换成整数)
* [68. 树中两个节点的最低公共祖先](#68-树中两个节点的最低公共祖先)
