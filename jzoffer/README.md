# 剑指Offer题解目录
### 参考：[cyc大神剑指题解](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md)

#### 牛客网：[剑指offer](https://www.nowcoder.com/ta/coding-interviews)

#### 力扣中国：[剑指offer](https://leetcode-cn.com/problemset/lcof/)



<!-- GFM-TOC -->
* [2. 单例模式](#2-单例模式)
* [3. 数组中重复的数字](#3-数组中重复的数字)
* [4. 二维数组中的查找](#4-二维数组中的查找)
* [5. 替换空格](#5-替换空格)
* [6. 从尾到头打印链表](#6-从尾到头打印链表)
* [7. 重建二叉树](#7-重建二叉树)
* [8. 二叉树的下一个结点](#8-二叉树的下一个结点)
* [9. 用两个栈实现队列](#9-用两个栈实现队列)
* [10.1 斐波那契数列](#101-斐波那契数列)
* [10.2 矩形覆盖](#102-矩形覆盖)
* [10.3 跳台阶](#103-跳台阶)
* [10.4 变态跳台阶](#104-变态跳台阶)
* [11. 旋转数组的最小数字](#11-旋转数组的最小数字)
* [12. 矩阵中的路径](#12-矩阵中的路径)
* [13. 机器人的运动范围](#13-机器人的运动范围)
* [14. 剪绳子](#14-剪绳子)
* [15. 二进制中 1 的个数](#15-二进制中-1-的个数)
* [16. 数值的整数次方](#16-数值的整数次方)
* [17. 打印从 1 到最大的 n 位数](#17-打印从-1-到最大的-n-位数)
* [18.1 在 O(1) 时间内删除链表节点](#181-在-o1-时间内删除链表节点)
* [18.2 删除链表中重复的结点](#182-删除链表中重复的结点)
* [19. 正则表达式匹配](#19-正则表达式匹配)
* [20. 表示数值的字符串](#20-表示数值的字符串)
* [21. 调整数组顺序使奇数位于偶数前面](#21-调整数组顺序使奇数位于偶数前面)
* [22. 链表中倒数第 K 个结点](#22-链表中倒数第-k-个结点)
* [23. 链表中环的入口结点](#23-链表中环的入口结点)
* [24. 反转链表](#24-反转链表)
* [25. 合并两个排序的链表](#25-合并两个排序的链表)
* [26. 树的子结构](#26-树的子结构)
* [27. 二叉树的镜像](#27-二叉树的镜像)
* [28. 对称的二叉树](#28-对称的二叉树)
* [29. 顺时针打印矩阵](#29-顺时针打印矩阵)
* [30. 包含 min 函数的栈](#30-包含-min-函数的栈)
* [31. 栈的压入、弹出序列](#31-栈的压入弹出序列)
* [32.1 从上往下打印二叉树](#321-从上往下打印二叉树)
* [32.2 把二叉树打印成多行](#322-把二叉树打印成多行)
* [32.3 按之字形顺序打印二叉树](#323-按之字形顺序打印二叉树)
* [33. 二叉搜索树的后序遍历序列](#33-二叉搜索树的后序遍历序列)
* [34. 二叉树中和为某一值的路径](#34-二叉树中和为某一值的路径)
* [35. 复杂链表的复制](#35-复杂链表的复制)
* [36. 二叉搜索树与双向链表](#36-二叉搜索树与双向链表)
* [37. 序列化二叉树](#37-序列化二叉树)
* [38. 字符串的排列](#38-字符串的排列)
* [39. 数组中出现次数超过一半的数字](#39-数组中出现次数超过一半的数字)
* [40. 最小的 K 个数](#40-最小的-k-个数)
* [41.1 数据流中的中位数](#411-数据流中的中位数)
* [41.2 字符流中第一个不重复的字符](#412-字符流中第一个不重复的字符)
* [42. 连续子数组的最大和](#42-连续子数组的最大和)
* [43. 从 1 到 n 整数中 1 出现的次数](#43-从-1-到-n-整数中-1-出现的次数)
* [44. 数字序列中的某一位数字](#44-数字序列中的某一位数字)
* [45. 把数组排成最小的数](#45-把数组排成最小的数)
* [46. 把数字翻译成字符串](#46-把数字翻译成字符串)
* [47. 礼物的最大价值](#47-礼物的最大价值)
* [48. 最长不含重复字符的子字符串](#48-最长不含重复字符的子字符串)
* [49. 丑数](#49-丑数)
* [50. 第一个只出现一次的字符位置](#50-第一个只出现一次的字符位置)
* [51. 数组中的逆序对](#51-数组中的逆序对)
* [52. 两个链表的第一个公共结点](#52-两个链表的第一个公共结点)
* [53. 数字在排序数组中出现的次数](#53-数字在排序数组中出现的次数)
* [54. 二叉查找树的第 K 个结点](#54-二叉查找树的第-k-个结点)
* [55.1 二叉树的深度](#551-二叉树的深度)
* [55.2 平衡二叉树](#552-平衡二叉树)
* [56. 数组中只出现一次的数字](#56-数组中只出现一次的数字)
* [57.1 和为 S 的两个数字](#571-和为-s-的两个数字)
* [57.2 和为 S 的连续正数序列](#572-和为-s-的连续正数序列)
* [58.1 翻转单词顺序列](#581-翻转单词顺序列)
* [58.2 左旋转字符串](#582-左旋转字符串)
* [59.1 滑动窗口的最大值](#591-滑动窗口的最大值)
* [59.2 队列的最大值](592-队列的最大值)
* [60. n 个骰子的点数](#60-n-个骰子的点数)
* [61. 扑克牌顺子](#61-扑克牌顺子)
* [62. 圆圈中最后剩下的数](#62-圆圈中最后剩下的数)
* [63. 股票的最大利润](#63-股票的最大利润)
* [64. 求 1+2+3+...+n](#64-求-123n)
* [65. 不用加减乘除做加法](#65-不用加减乘除做加法)
* [66. 构建乘积数组](#66-构建乘积数组)
* [67. 把字符串转换成整数](#67-把字符串转换成整数)
* [68. 树中两个节点的最低公共祖先](#68-树中两个节点的最低公共祖先)
<!-- GFM-TOC -->



# 2. 单例模式
- ## 解题思路
  - 设计模式：解决某一类问题的行之有效的解决办法（或思想）
  - 单例模式即只生成一个实例，可以保证一个类的对象的唯一性。
  - 分析：
    - 构造函数私有：一个类只要提供了构造函数就可以产生多个对象，故私有构造函数
    - 因为不让其他程序创建对象，故自己在本类中new一个对象，并设为静态私有，好处是可控
      注：静态 -- 防止无法从静态上下文中访问非静态变量
    - 创建一个getInstance功能，对外提供访问接口，设为公共静态
  - 分为懒汉式和饿汉式。
  - 饿汉式：直接new，开发常用
  - 懒汉式：单例的延迟加载，当调用到时再new，面试多见
    - 懒汉式并发访问：加入同步机制解决安全问题，通过双重判断是否为空来减少访问锁的次数以提高效率

- ## 代码链接
  - [单例模式](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/02_%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 3. 数组中重复的数字
- ## 题目描述
  - 在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。
  - 数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。
  - 请找出数组中任意一个重复的数字。
  - 示例：Input: {2, 3, 1, 0, 2, 5}，Output: 2

- ## 解题思路
  - 思路：集合；数组交换
  - 集合：
    - 复杂度：时间O(n)，空间O(n)
    - 分析：集合是无重复的，与本题非常切合
    - 算法：定义集合；遍历数组：将数组元素存入集合，当无法存入时，返回当前元素；返回-1。
    - HashSet add:
      - `public boolean add(E e)`，add是布尔型
      - 如果此 set 中尚未包含指定元素，则添加指定元素。
      - 更确切地讲，如果此 set 没有包含满足 (e==null ? e2==null : e.equals(e2)) 的元素 e2，则向此 set 添加指定的元素 e。
      - 如果此 set 已包含该元素，则该调用不更改 set 并返回 false。
  - 数组交换：
    - 复杂度：时间O(n)，空间O(1)
    - 用数组模拟哈希表的思想
    - 如果要求时间复杂度 O(N)，空间复杂度 O(1)，则不能使用排序的方法，也不能使用额外的标记数组。
    - 对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。
    - 可以省掉额外的空间开辟，将每个位置的数交换映射到其对应的数组下标下面，当出现新的元素与其对应的下标中的数字相等时，即为重复数字
    - 用到 while 循环，原因是保证交换过来的新元素位置也要正确
    - 算法：判空；遍历数组：如果不等，判断重复，交换；返回false
      - 考虑测试用例：无效（空指针，包含0-n-1之外数字），不包含重复数字等。
      - 以数组下标i为单位遍历并比较，符合时交换，直到下标对应的数字等于下标值时，进入i+1的比较。
      - 注意：交换时用到numbers[temp]而不是numbers[numbers[i]]；交换在while循环里
      - 例如：(2, 3, 1, 0, 2, 5) ，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复
  - 注：翻了几处，都没有要求空间O(1)，所以用集合美滋滋啦
  - 注：牛客和力扣的本题参数和返回值类型不同，前一个是力扣，返回int，后一个是牛客，返回boolean
  
- ## 代码链接：
  - [数组中重复的数字](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/03_%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 4. 二维数组中的查找
- ## 题目描述
  - 给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。
  - 给定一个数，判断这个数是否在该二维数组中。

    ```html
    Consider the following matrix:
    [
      [1,   4,  7, 11, 15],
      [2,   5,  8, 12, 19],
      [3,   6,  9, 16, 22],
      [10, 13, 14, 17, 24],
      [18, 21, 23, 26, 30]
    ]

    Given target = 5, return true.
    Given target = 20, return false.
    ```

- ## 解题思路
  - 思路：暴力法；线性查找。
  - 暴力法：忽略存在的顺序，直接暴力查找；时间复杂度高。
    - 复杂度：时间O(mn)，空间O(1)  -- m 为行数，n 为 列数。
  - 线性查找：
    - 复杂度：时间O(m+n)，空间O(1)  -- m 为行数，n 为 列数。
    - 关键：站在右上角看。这个矩阵其实就像是一个Binary Search Tree。
    - 分析：
      - 分析复杂问题：从一个具体的例子入手
      - 可以发现：该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。
      - 考虑从右上角或者左下角开始，可以避免可能选取区域重叠。
      - 右上角：左侧为小于，下侧为大于。若小，下移；若大，左移。
      - 测试用例考虑：有目标；没有目标（大于max，小于min，介于但不存在）；空指针；行列数非正
      - 空指针即地址为null，行列数非正，这两个需要排除。而没有目标中各种情况都属于找不到，返回false即可，无需特意判断。
    - 算法本质： 
      - 每轮 i 或 j 移动后，相当于生成了“消去一行（列）的新矩阵”， 索引(i,j) 指向新矩阵的左下角元素（标志数）
      - 因此可重复使用以上性质消去行（列）。
    - 算法：判空(如果定义了范围，可省略)；定义右上角行列索引值；遍历数组：范围内，大则左移，小则下移，否则返回true；最后返回false。
  
 - ## 代码链接：
   - [二维数组中的查找](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/04_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 5. 替换空格
- ## 题目描述
  - 将一个字符串中的空格替换成 "%20"。
  - 示例：Input: "A B"；Output: "A%20B"

- ## 解题思路
  - 思路：库函数；新建字符串；原字符串修改。
  - 分析：
    - 对于URL参数：无法识别特殊字符，故空格替换为"%20"，#替换为"%23"
    - 由于空格的一个字符变为三个字符，替换后变长，两种思路：创建新字符串和在原字符串修改。
  - 库函数：
    - 算法：直接返回replace后的字符串s。
    - 用String的函数：`replace(CharSequence target, CharSequence replacement)`
      - 使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。
    - 但是解算法题用库函数显得投机取巧。
  - 新建字符串：
    - 复杂度：时间O(n), 空间O(n)
    - 算法：
      - 初始化一个可变字符串 StringBuilder ，记为 res ；
      - 将字符串s转为字符数组chars；
      - 遍历字符数组中的每个字符，并添加到res字符串：
        - 当 c 为空格时：向 res 后添加字符串 "%20"；
        - 当 c 不为空格时：向 res 后添加字符 c ；
      - 将 res 转化为 String 类型并返回。
    - 注：如果要求不能开辟额外空间时，这种方法就行不通了。
  - 原字符串修改：
    - 复杂度：时间O(n), 空间O(k) -- k是空格数，空间复杂度小一点
    - 分析：
      - 原字符串修改且空间充足时：正遍历-多空格时，部分字符会移动多次，时间复杂度太高；逆遍历-O(n)
      - 首先计算空格数得到最终字符串末尾，P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。
      - P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。
      - 从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。
    - 算法：
      - 定义指针p1指向原有字符串的末尾：p1从末尾遍历原字符串；
      - 遍历字符串，每一个空格，添加两个空格到原字符串；
      - 定义指针p2指向增加两倍空格数之后的字符串的末尾：p2从末尾更新字符串，并添加`%20`到字符串中；
      - 循环：直到 -- 原字符串遍历完成(`p1>=0`) 或 更新后字符串追上原字符串(`p2>p1`)
        - 判断是否是空格
      - 返回toString()。
    - 注：
      - 当题目定义好的参数类型是StringBuilder时，可以用这种方法。如果是String，就不好用了，直接开辟新空间。
      - 本方法太别扭了，为了省一点空间，走了很多弯路。不如重新开辟空间后操作了。
  - 字符串知识点：
    - `str.charAt(i)`-获取i处某值
    - `str.setCharAt(i,'m')`-m赋值给i处 注：本方法是StringBuilder的方法
    - `str.length()`-获取str长度
    - `str.append("abc")`-在str新增
  - 注意：`str.charAt()`获取到的是字符型，用单引号；`str.setCharAt(int, char)`中Char的C大写

- ## 代码链接
  - [替换空格](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/05_%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.java)
  
<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 6. 从尾到头打印链表
- ## 题目描述
  - 从尾到头反过来打印出单链表的每个结点的值。

- ## 解题思路
  - ### 使用栈
    - 栈具有后进先出的特点，从第一个结点开始遍历后最后一个第一个输出，是典型的“后进先出”。
      - 注：返回值可以是int[]，也可以是ArrayList<>，最后定义为不同的容器即可。
    - 算法：新建栈；遍历链表并压栈直至尾结点为空；新建容器；遍历并弹栈直至栈空；返回容器。
    - 知识点：
      - 新建栈：`Stack<Integer> stack = new Stack<>();`
      - 压栈：`stack.add(i);`  弹栈：`stack.pop();`  栈空：`stack.isEmpty()==true;` 栈长度：`stack.size();`
      - java链表：`ListNode listnode`  取值：`listNode.val;`  下一值：`listNode.next;`
      - 容器：`ArrayList<Integer> ret = new ArrayList<>();`或者`int[] res = new int[stack.size()];`
     - 注意：使用栈Stack要加这句：`import java.util.Stack;`
  - ### 使用递归
    - 递归在本质上是一个栈结构，故可以考虑递归。
    - 先递归输出后面的结点，再输出该结点本身。
    - 思路：新建容器 -- 判断结点是否为空，空则调用本身并传入next结点，直到为空时打印，然后返回上一个函数调用并打印，直到最外层 -- 返回容器
    - 要逆序打印链表 1->2->3（3,2,1)，可以先逆序打印链表 2->3(3,2)，最后再打印第一个节点 1。
      而链表 2->3 可以看成一个新的链表，要逆序打印该链表可以继续使用求解函数，也就是在求解函数中调用自己，这就是递归函数。
    - 知识点：
      - add方法与addAll方法的区别：
        - Add方法是将传入的参数作为当前List中的一个item存储，即使传入一个List也只令当前的List增加1个元素
        - AddAll是传入一个List，将此List中的所有元素加入到当前List中，也就是当前List会增加的元素个数为传入的List的大小
        - `addAll(Collection c)`
        - `add(int index,Elelemt e)`
  - ### 使用头插法（未实践）
    - 使用头插法可以得到一个逆序的链表。
    - 头结点和第一个节点的区别：
       - 头结点是在头插法中使用的一个额外节点，这个节点不存储值；
       - 第一个节点就是链表的第一个真正存储值的节点。

- ## 代码链接
  - [从尾到头打印链表](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/06_%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.java)
 
<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->

  

# 7. 重建二叉树
- ## 题目描述
  - 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。
  - 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
  - 例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

- ## 解题思路
  - 因为是树的结构，一般都是用递归来实现。
  - 用数学归纳法的思想就是，假设最后一步，就是root的左右子树都已经重建好了，那么只要考虑将root的左右子树安上去即可。
  - 根据前序遍历的性质，第一个元素必然就是root，那么下面的工作就是如何确定root的左右子树的范围。
  - 根据中序遍历的性质，root元素前面都是root的左子树，后面都是root的右子树。那么我们只要找到中序遍历中root的位置，就可以确定好左右子树的范围。
  - 正如上面所说，只需要将确定的左右子树安到root上即可。
  - 递归要注意出口，假设最后只有一个元素了，那么就要返回。  
  - 知识点：
    - `Arrays.copyOfRange(T[ ] original,int from,int to)` ：将一个原始的数组original，从下标from开始复制，复制到下标to，生成一个新的数组。注意这里包括下标from，不包括下标to。
 
 - ## 代码链接
   - [重建二叉树](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/07_%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.java)
  
<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


  
# 8. 二叉树的下一个结点
- ## 题目描述
  - 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。
  - 注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。
   
- ## 解题思路
  - 若该结点存在右子树：则下一个结点为右子树最左子结点；若没有左子结点，则下一个结点即该右子树的根结点本身
  - 若该结点不存在右子树，分两种情况： 
    - 1 该结点为父结点的左子结点，则下一个结点为其父结点
    - 2 该结点为父结点的右子结点，则沿着父结点向上遍历，直到找到一个结点，它是其父结点的左子结点，则该结点的父结点是下一个结点
  - 思路：判空则返回 -- 判断该结点的右结点是否为空，并分两类情况进行讨论
  - 注意：没有右子且不是其父的左子的情况比较复杂，但是代码体现比较简单，只是循环。
  
- ## 代码链接
  - [二叉树的下一个结点](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/08_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 9. 用两个栈实现队列
- ## 题目描述
  - 用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。

- ## 解题思路
  - 栈“先入后出”，而队列“先入先出”，可利用两个栈的两次“先入后出”使得最终顺序为“先入先出”
    - 具体地，一个元素进入栈1之后，出栈的顺序被反转。当元素要出栈时，需要先进入2栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。
  - 只在栈1入栈（push）操作，只在栈2出栈（pop）操作。
    - 入栈：即栈1入栈
    - 出栈：需要先对栈2判空，若非空，直接出；若空，需要从栈1弹出后栈2入栈，直到栈1空，此时第一个进栈的在栈2top，可以弹出；若全空，抛出异常或指定值。
  - 算法：
    - 声明；
    - new栈对象：栈1push，栈2pop；
    - 压栈：栈1直接压栈；
    - 弹栈：先判空，都空时抛出异常；否则，栈2空时先栈1pop进栈2。之后统一补一句栈2弹栈并返回pop值；
  - 知识点：
    - 使用栈要声明：`import java.util.Stack;`
    - 创建栈：`Stack<Integer> stackname = new Stack<Integer>();`
    - 压栈：stackname.push(val);
    - 弹栈：stackname.pop(); -- 弹栈会返回原栈顶值，可赋值给变量使用
    - 栈空：stackname.empty(); 空则true，否则false(注：isEmpty()也可以)

- ## 代码链接
  - [用两个栈实现队列](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/09_%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.java)
  
<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 10.1 斐波那契数列
- ## 题目描述
  - 现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n<=39
  - f(0)=0; f(1)=1; f(n)=f(n-1)+f(n-2),n>=2
  
- ## 解题思路
  - 斐波那契数列属于典型的递归，但是用递归求解的话，过多重复，时间效率低。
  - 考虑用循环实现递归，可以极大地提高时间效率。
    - 时间复杂度：O(n)
    - 第 i 项只与第 i-1 和第 i-2 项有关，因此只需要存储前两项的值就能求解第 i 项，从而将空间复杂度由 O(N) 降低为 O(1)。
    - 规定n<=39故在int范围内
  - 还有一种转换为求矩阵的乘方，思考过多不作考虑。

- ## 代码链接
  - [斐波那契数列](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/10_1_%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 10.2 矩形覆盖
- ## 题目要求
  - 我们可以用2×1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2×1的小矩形无重叠地覆盖一个2×n的大矩形，总共有多少种方法？

- ## 解题思路
  - 被覆盖的大矩形是两行n列的（画示意图更明显，此处省略图）
  - n=1时：只有一种方法
  - n=2时：有横着覆盖和竖着覆盖两种方法
  - n>=2时：分为两种情况
    - 若第一个小矩形竖着，则剩余n-1个区域的覆盖方法记为f(n-1)
    - 若第一个小矩形横着，则它下方也应该横着填一个小矩形，则剩余n-2个区域的覆盖方法记为f(n-2)
    - 即f(n)=f(n-1)+f(n-2),n>=2
  - 综上，此问题可归结为斐波那契数列相同的问题。
  - 同上，依然是用循环来实现递归
  - 注意：首项和第二项与原斐波那契数列有不同。
  - 注意：代码初始化返回值时，要赋值，不能空着（比如int result;）会报错的。

- ## 代码链接
  - [矩阵覆盖](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/10_2_%E7%9F%A9%E9%98%B5%E8%A6%86%E7%9B%96.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 10.3 跳台阶
- ## 题目描述
  - 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

- ## 解题思路
  - 当n=1时：只有1种跳法
  - 当n=2时：有2种跳法 -- 一级一级跳两次或者一次跳两级
  - 当n>=2时：分为两种情况
    - 当第一次跳一级，则跳法数等于剩余台阶的跳法f(n-1)
    - 当第一次跳两级，则跳法数等于剩余台阶的跳法f(n-2)
    - 即f(n)=f(n-1)+f(n-2),n>=2
  - 综上，跳台阶问题可以归结为斐波那契数列问题。

- ## 代码链接
  - [跳台阶](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/10_3_%E8%B7%B3%E5%8F%B0%E9%98%B6.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 10.4 变态跳台阶
- ## 题目描述
  - 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

- ## 解题思路之数学推导：
  - 跳上 n-1 级台阶，可以从 n-2 级跳 1 级上去，也可以从 n-3 级跳 2 级上去...，那么
    - f(n-1) = f(n-2) + f(n-3) + ... + f(0)
  - 同样，跳上 n 级台阶，可以从 n-1 级跳 1 级上去，也可以从 n-2 级跳 2 级上去... ，那么
    - f(n) = f(n-1) + f(n-2) + ... + f(0)
  - 综上可得：f(n) - f(n-1) = f(n-1)
  - 即：f(n) = 2×f(n-1) 是等比数列，1,2，公比2可用位移运算优化
  - 用位移运算，1<<(target-1)，非正情况另考虑，从1开始到n都是符合公式的。

- ## 代码链接
  - [变态跳台阶](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/10_4_%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 11. 旋转数组的最小数字
- ## 题目描述
  - 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
  - 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
  - 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
  - NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

- ## 解题思路1：暴力搜索最小值
  - 虽然是面试官不愿意看到的废柴方法，但是牛客里可以ac，亲测....
  - 但是还是尽量不要这样做吧，除非没别的想法了
  
- ## 解题思路2：暴力搜索是否符合非降序
  - 在两段范围内都是非降序，当不符合这个规律时，就找到了最小数字
  
- ## 解题思路3：排序
  - 既然是找最小值，使用排序也是很常规的思路
  - 利用 Arrays 工具类里的排序函数，默认的排序规则是从小到大，排序后的数组第一个值就是最小值
  - 注意：需要import Arrays，干脆util.*
  - 排序的时间复杂度是O(nlogn)，比暴力法O(n)更慢了。
  
- ## 解题思路4：变相二分查找 -- 二分+暴力
  - 首先，因为有一定排序，故不能使用遍历整个数组，找出其中最小的数。(其实可以ac，亲测)
  - 因为有一定排序，故使用二分：
    - 大数组在前，小数组在后：大数组中的所有元素均大于等于小数组中的所有元素
    - 最小元素应该在大数组和小数组的交界处，且位于小数组的第一个
    - low，high分别指向数组的首尾，则low指向大数组，high指向小数组
    - 取mid=(low+high)/2
    - 若mid位于大数组，则大于等于low，最小值在mid后，故low向前移动到mid位置
    - 若mid位于小数组，则小于等于high，最小值在mid前，故high向后移动到mid位置
    - low和high不断向中间移动，最终将相邻，而high正好指向最小值，这是循环判停的条件：high-low==1，
  - 非递减，需要考虑相同数字的情况，比如数组 {1,1,1,0,1}
    - 对于不符合以上分类的情况
    - 此时无法用二分判断，故使用遍历方法暴力求解找到最小值
  
- ## 解题思路5：二分
  - 遇到重复数字但不用暴力法的方法
  - 算法：
    - 定义双指针分别指向数组的头i和尾j；
    - 循环：当i<j时
      - 二分为mid
      - `nums[mid]>nums[j]`时：说明mid位于大数组，而最小值会在[mid+1，j]内，因此更新`i=mid+1;`
      - `nums[mid]<nums[j]`时：说明mid位于小数组，而最小值会在[i,mid]内，因此更新`j=mid;`
      - `nums[mid]==nums[j]`时：`j--;`
        - 若mid位于小数组中，则表明小数组中从mid到j的所有元素相等，因此j--会抛弃一个重复元素，因此最小值仍在[i,j]；
        - 若mid位于大数组中，而j位于小数组，则`min <= numbers[j] == numbers[m]`
          - 若`mix < numbers[j]`，则j的左侧有更小的元素，因此j--后最小值仍在[i,j]中；
          - 若`numbers[x] == numbers[j]`，
    - 当i=j时，返回`numbers[i]`
 - 注意：
   - `nums[mid]==nums[j]`时：`j--;`的合理性：
     - 若mid位于小数组中，则表明小数组中从mid到j的所有元素相等，因此j--会抛弃一个重复元素，因此最小值仍在[i,j]；
       - 例如：[1, | 0,1,1,1]。
     - 若mid位于大数组中，而j位于小数组，则`min <= numbers[j] == numbers[m]`
       - 若`mix < numbers[j]`，则j的左侧有更小的元素，因此j--后最小值仍在[i,j]中。例如：[1,1,1, | 0,1]。
       - 若`min == numbers[j]`，分情况讨论均符合，大概是最小值有多个的情况，j--以后，仍然可以从剩余最小值中找到。
   - 是否可以用 numbers[m] 和 numbers[i] 比较做代替？
     - 不可以。因为做比较的目的是判断 m 在哪个排序数组中。
     - 但在 numbers[m] > numbers[i]情况下，无法判断 m 在哪个排序数组中。
     - 本质是因为 j 初始值肯定在右排序数组中； i 初始值无法确定在哪个排序数组中。

- ### 注：
  - 本题没有判空，大概是考点不在此处？
  - 考点1：整个数组旋转的情况，即顺序数组，整体旋转后，仍然是顺序数组；
  - 考点2：存在重复数字的情况，例如[0,1,1,1,1]旋转后得到[1,0,1,1,1]或[1,1,1,0,1]

- ## 代码链接
  - [旋转数组的最小数字](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/11_%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 12. 矩阵中的路径
- ## 题目描述
  - 请设计一个函数，用来判断在一个矩阵中**是否**存在一条包含某字符串所有字符的路径。
  - 路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。
  - 如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 
  - 例如 a b c e s f c s a d e e 矩阵中包含一条字符串"bccced"的路径，但是矩阵中不包含"abcb"路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。
  - 注意：传入的是一维矩阵，行数，列数，目标str

- ## 解题思路
  - 使用回溯法（backtracking）进行求解，它是一种暴力搜索方法，通过搜索所有可能的结果来求解问题。
  - 回溯法在一次搜索结束时需要进行回溯（回退），将这一次搜索过程中设置的状态进行清除，从而开始一次新的搜索过程。
  - 思路
    - 0.根据给定数组，初始化一个标志位数组，初始化为false，表示未走过，true表示已经走过，不能走第二次
    - 1.根据行数和列数，遍历数组，先找到一个与str字符串的第一个元素相匹配的矩阵元素，进入judge
    - 2.根据i和j先确定一维数组的位置，因为给定的matrix是一个一维数组
    - 3.确定递归终止条件：越界，当前找到的矩阵值不等于数组对应位置的值，已经走过的，这三类情况，都直接false，说明这条路不通
    - 4.若k，就是待判定的字符串str的索引已经判断到了最后一位，此时说明是匹配成功的
    - 5.下面就是本题的精髓，递归不断地寻找周围四个格子是否符合条件，只要有一个格子符合条件，就继续再找这个符合条件的格子的四周是否存在符合条件的格子，直到k到达末尾或者不满足递归条件就停止。
    - 6.走到这一步，说明本次是不成功的，我们要还原一下标志位数组index处的标志位，进入下一轮的判断。

- ## 代码链接
  - [矩阵中的路径](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/12_%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 13. 机器人的运动范围
- ## 题目描述
  - 地上有一个m行和n列的方格。
  - 一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 
  - 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。
  - 请问该机器人能够达到多少个格子？

- ## 解题思路
  - 深度优先搜索（Depth First Search，DFS）方法。
  - 回溯是深度优先搜索的一种特例，它在一次搜索过程中需要设置一些本次搜索过程的局部状态，并在本次搜索结束之后清除状态。
  - 而普通的深度优先搜索并不需要使用这些局部状态，虽然还是有可能设置一些全局状态。
  - 具体思路同上题，同时加一个位数和的限制条件
  - 注意：
    - flag是二维数组，定义还有传参的时候，别少写方括号[]
    - do{}while(); while之后的分号千万别忘写了。

- ## 代码链接
  - [机器人的运动范围](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/13_%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 14. 剪绳子
- ## 题目描述
  - 把一根长度为n的绳子剪成多段(大于一段)，并且使得每段的长度乘积最大（n为整数，n>1）
  - n = 2， return 1 (2 = 1 + 1)
  - n = 10， return 36 (10 = 3 + 3 + 4)

- ## 解题思路
  - ### 贪心：
    #### 每一步都做一个贪婪的选择，基于这个选择，可以得到最优解。一般需要数学方式证明贪婪选择的正确性。
    - 尽可能多剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现。
    - 如果出现了，就从已经切好长度为 3 的绳子中拿出一段与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。
    - 证明：
      - 当 n >= 5 时，3(n - 3) - n = 2n - 9 > 0，且 2(n - 2) - n = n - 4 > 0。
      - 因此在 n >= 5 的情况下，将绳子剪成一段为 2 或者 3，得到的乘积会更大。
      - 又因为 3(n - 3) - 2(n - 2) = n - 5 >= 0，所以剪成一段长度为 3 比长度为 2 得到的乘积更大。
    - 注：
      - pow() 方法用于返回第一个参数的第二个参数次方。
      - double pow(double base, double exponent) -- 返回值类型默认为double型，而题目要求的是int型，强转为int
  - ### 动态规划：
    - 分析发现符合dp的问题特征：
      - 求一个问题的最优解； 
      - 整体的问题的最优解是依赖于各个子问题的最优解； 
      - 小问题之间还有相互重叠的更小的子问题； 
      - 从上往下分析问题，从下往上求解问题；
    - 不用过多分析，将问题无脑分解为更小的问题。
    - 从小到大，依次计算所有可能解并保存在数组中，直到计算到target为止。
    - 注意：
      - i/2的略微优化没成，就暂时先这样吧..
      - dp[i]的值包含的内容（包括两个嵌套的Math.max()）需要缕清楚，别写错写漏了
  
- ## 代码链接
  - [剪绳子](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/14_%E5%89%AA%E7%BB%B3%E5%AD%90.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 15. 二进制中 1 的个数
- ## 题目描述
  - 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

- ## 解题思路
  - 常规思路：
    - 右移+与1+count计数。
    - 注：与运算结果分为不为0（即1）和为0，故可放在if中作为判断条件。
    - 缺点：负数时最高位的问题。
  - 改进思路：
    - 既然右移数字不成，就左移flag1，之后和给定数字做与运算。
    - 不足：数字的二进制有多少位就需要循环多少次
  - 技巧思路：
    - n=(n-1)&n，当n不为0时，继续循环
    - 时间复杂度：O(M)，其中 M 表示 1 的个数。比上述改进思路稍快。
    - 小结论：把一个整数-1，并和自己做位与运算，相当于把最右边的1变成0.
      - 注：一个整数减去1，相当于把最右边的1变成0的同时，当1的右侧还有0，则把所有0变成1.例如，1100-1=1011. 1100&1011=1000.
  - 调用函数 Integer.bitCount()
    - 计算一个（byte,short,char,int统一按照int方法计算）int,long类型的数值在二进制下“1”的数量。
- ## 代码链接
  - [二进制中1的个数](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/15_%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 16. 数值的整数次方
- ## 题目描述
  - 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。
  - 保证base和exponent不同时为0

- ## 解题思路
  - 乘方功能，即实现类似pow()函数的功能
    - 注：double pow(double base, double exponent) -- 返回值类型默认为double型，可根据题目要求进行强转
    - 一行代码：`return Math.pow(base,exponent);`
  - 使用公式递归
    - n=奇数时，a^n=a^(n/2) × a^(n/2);
    - n=偶数时，a^n=a^((n-1)/2) × a^((n-1)/2) × a;
    - 代码中不需要减1的操作，因为会自动取整，结果一样
  - 注意：
    - 考虑指数的特殊情况：为1时返回base，为0时返回1.
    - 考虑指数是负数的情况：设置标志，先把指数取相反数变为正数，用公式计算，最后求结果的倒数（当标志为真时）
    - 可以考虑：用右移代替除以2，用与1运算代替整除取余%，可提高运算效率。
    
- ## 代码链接
  - [数值的整数次方](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/16_%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 17. 打印从 1 到最大的 n 位数
- ## 题目描述
  - 输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。
  - 比如输入 3，则打印出 1、2、3 一直到最大的 3 位数即 999。

- ## 解题思路
  - 由于 n 可能会非常大，因此考虑“大数问题”，不能直接用 int 表示数字，而是用 char 数组或者字符串进行存储。
  - 如果累加，计算量大，效率不高，代码冗长；考虑把问题转换成数字排列，每一位从0-9排列一遍，即可得到结果。
  - 代码终止条件为：当位数增加到等于数组长度时，相当于已经达到最大值，可以停止了。
  - 使用回溯法得到所有的数。
    - 注意：回溯法一定要注意设置好终止条件。
  - 打印时需要考虑不能前非零数字前的0也打印出来。

- ## 代码链接
  - []()

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 18.1 在 O(1) 时间内删除链表节点


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 18.2 删除链表中重复的结点


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 19. 正则表达式匹配



<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->




# 20. 表示数值的字符串



<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 21. 调整数组顺序使奇数位于偶数前面



<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 22. 链表中倒数第 K 个结点


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 23. 链表中环的入口结点


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 24. 反转链表
- ## 题目描述
  - 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。
  - 示例: 输入: 1->2->3->4->5->NULL，输出: 5->4->3->2->1->NULL
  - 限制：0 <= 节点个数 <= 5000

- ## 解题思路
  - 思路：迭代；递归
    - 注：配合图示理解效果更佳。
    - 注意：链表要特别注意结点存储的顺序，防止把链子断了。
  - 迭代：
    - 复杂度：时间O(n)，空间O(1)
    - 分析：用双指针，实现每两个链表结点之间反转，以达到整体反转链表的目的。
      - 其实用到三个指针，因为在两个结点反转的时候，需要把cur存起来，防止丢失next信息使得链表断开。
    - 算法：
      - 定义双指针：当前指针cur指向当前结点，前指针pre指向当前结点的前一个结点；
      - 循环：当cur不指向null时遍历链表
        - 定义临时结点tmp，将cur的next结点信息存在tmp中；
        - 将cur的下个结点指向pre，完成反转；
        - 将pre和cur往后移动一个结点：pre赋值为cur，cur赋值为tmp（此时，pre与cur直接断开了，但是下个循环就会连起来）；
        - 注：循环到最后，cur会赋值为尾结点指向的null，这时pre是最后一个不为空的结点，并且和cur不连接，可以作为返回值。
      - 返回结果pre。
    - 注：本方法自带判空，也可以处理单个结点的链表。
  - 递归：
    - 复杂度：时间O(n)，空间O(n)
    - 分析：
      - 递归的两个条件：
        - 终止条件是当前节点或者下一个节点==null
        - 在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 递归函数那句：`head.next.next = head;`
        - 不好理解，其实就是 head 的下一个节点指向head：相当于head与head.next和head形成了一个环。
      - 递归函数中每次返回的 cur 其实只最后一个节点，在递归函数内部，改变的是当前节点的指向。
    - 算法：
      - 判空：当head为空，或者仅有一个结点时，返回head本身；
      - 递归：结点cur赋值为head.next的反转链表结果，这句会一直dfs到末尾，然后开始返回；
        - 把head看做一个结点，把剩余结点并且已经调用过反转函数的返回值看做cur。
      - 形成环：将head.next的下一个结点赋值为head，即将head.next连接到head；
      - 切断head与head.next的连接；
      - 最后返回cur：cur是尾结点。
    
- ## 代码链接：
  - [反转链表](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/24_反转链表.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 25. 合并两个排序的链表
- ## 题目描述
  - 输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。
  - 示例1：输入：1->2->4, 1->3->4；输出：1->1->2->3->4->4
  - 限制：0 <= 链表长度 <= 1000

- ## 解题思路
  - 思路：递归；迭代
  - 递归：
    - 边界：当任一链表为null时，直接返回剩余链表（即返回非空链表）
      - 注：这里包括当两链表都是null的情况，因为仍然会返回其一。
    - 比较：将两个链表中头部较小的一个，与剩下元素的 merge 操作结果合并，最终返回此链表
      - 当list1[0]<list2[0]时：list1[0] + merge(list1[1:], list2)，并返回list1
      - 否则（包含等于情况）：list2[0] + merge( list1l, list2[1:])，并返回list2
    - 递归的复杂度分析：
      - 时间复杂度：O(m+n)
      - 空间复杂度：O(m+n)
  - 迭代
    - 顺序迭代的思路
    - 设定一个哨兵节点 "prehead" （以便在最后比较容易地返回合并后的链表）
    - 维护一个 prev 指针，并调整它的 next 指针
    - 重复以下过程，直到 l1 或者 l2 指向了 null ：
      - 如果 l1 当前位置的值小于等于 l2 ，把 l1 的值接在 prev 节点的后面，同时将 l1 指针往后移一个。
      - 否则，对 l2 做同样的操作。
      - 不管将哪一个元素接在了后面，都把 prev 向后移一个元素。
    - 最后加一步对于空链表的分析，并返回prehead
    - 迭代的复杂度分析：
      - 时间复杂度：O(m+n)
      - 空间复杂度：O(1)
  - 链表相关使用：
    - 链表结点：ListNode l1, ListNode l2 -- 头结点的位置
    - 判空：直接结点名与null比较 `l2 == null;`
    - 结点对应的值：`l1.val` -- 结点l1对应的值
    - 下一个结点：`l1.next` -- 结点1的下一个结点
    - 新建一个哨兵结点保存整个组合链表的地址，最后prehea.next方便返回最终值：`ListNode prehead = new ListNode(-1);`
      - `ListNode list=new ListNode()` ：初始化一个空节点，无值,不提倡此种写法。
      - `ListNode list=new ListNode(0)`：初始化一个节点值为0的空节点，最常用最正规写法
      - `ListNode list=null`：为空，什么都没有，一般不这么写；
      - 注：参数为结点值

- ## 代码链接：
  - [合并两个排序的链表](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/25_合并两个排序的链表.java)
  
<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 26. 树的子结构


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 27. 二叉树的镜像


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 28. 对称的二叉树


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 29. 顺时针打印矩阵


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 30. 包含 min 函数的栈


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 31. 栈的压入、弹出序列


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 32.1 从上往下打印二叉树


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 32.2 把二叉树打印成多行


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 32.3 按之字形顺序打印二叉树


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 33. 二叉搜索树的后序遍历序列


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 34. 二叉树中和为某一值的路径


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 35. 复杂链表的复制


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 36. 二叉搜索树与双向链表


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 37. 序列化二叉树


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 38. 字符串的排列


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 39. 数组中出现次数超过一半的数字
- ## 题目描述
  - 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。
  - 你可以假设数组是非空的，并且给定的数组总是存在多数元素。
  - 示例: 输入: [1, 2, 3, 2, 2, 2, 5, 4, 2], 输出: 2。
  - 限制: 1 <= 数组长度 <= 50000

- ## 解题思路
  - 思路：暴力法；哈希表法；排序；分治；投票..
  - 暴力法：
    - 复杂度：时间O(n^2)，空间O(1)
    - 暴力算法遍历整个数组，然后用另一重循环统计每个数字出现的次数。将出现次数比其他数字加起来出现次数还多的元素返回。
    - 算法：初始化n/2；双层循环：外层控制比较基准，内层统计与基准相同的个数，并在内层结束后与n/2比较；最后return任一int型，比如-1.
    - 不足：时间复杂度过高
  - 哈希表：
    - 复杂度：时间O(n)，空间O(n)
    - 使用哈希表来存储每个元素，然后用一个循环在线性时间内遍历 nums ，然后我们只需要返回有最大值的键。
    - 算法：
      - 新建哈希表；
      - 新建max值和次数的变量；
      - 遍历数组：第一次出现时count赋值为1，否则在哈希表中对应count基础上+1，每次判断count范围并更新max两个变量；
      - 返回max值。
    - HashMap知识点：
      - `getOrDefault(Object key, V defaultValue)` : 如果存在key返回对应的value，否则返回defaultValue
  - 排序：
    - 复杂度：时间O(nlogn)，空间O(1)
    - 如果所有数字被单调递增或者单调递减的顺序排了序，那么众数的下标为n/2
    - 算法：对数组排序；返回排序后的n/2索引对应的元素
  - 摩尔投票法：
    - 复杂度：时间O(n)，空间O(1)
    - 把众数记为 +1，把其他数记为 −1 ，将它们全部加起来，显然和大于 0 ，从结果本身我们可以看出众数比其他数多。
    - 算法：
      - 定义比较基准flag=nums[0]和计数器count=1；
      - 遍历数组：与基准相同+1，不同-1，且变为0时，更新基准为下一个索引对应的元素；
        - 循环体中，先判决count是否为0，后判空nums[j]是否等于flag，一前一后用if-else连接；
        - 否则，赋值flag和计数器count会冲突，每次更新一次count即可。      
      - 返回最后计数器不为0的基准。
  - 注：后三种的时间复杂度都是近似n，但是哈希表法明显比最后两种慢很多。 
   
- ## 代码链接:
  - [数组中出现次数超过一半的数字](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/39_数组中出现次数超过一半的数字.java)
  
<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 40. 最小的 K 个数

- 镜像问题：<leetcode-215-数组中的第K个最大元素-medium>



- 相关知识点：
      - `Arrays.copyOfRange(arrName, start, end)`: 返回左闭右开索引值范围内的数组片段。
      
      
<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 41.1 数据流中的中位数


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 41.2 字符流中第一个不重复的字符


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 42. 连续子数组的最大和
- ## 题目描述
  - 输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。
  - 要求时间复杂度为O(n)。
  - 示例1: 输入: nums = [-2,1,-3,4,-1,2,1,-5,4], 输出: 6
     - 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
  - 提示：1 <= arr.length <= 10^5, -100 <= arr[i] <= 100

- ## 解题思路
  - 思路：暴力法；动态规划；贪心；分治
  - 暴力法：
    - 复杂度：时间O(N^2)，空间O(1)
    - 寻找所有的可能子序和，并求最大值
    - 首先定义并初始化max为数组第一个元素
    - 按照一定规律遍历数组，比如从i开始遍历到末尾，不断取和，比较并取max，然后i++
    - 两层循环：外循环控制开始的i值，内循环控制在i索引开始，形成的子序列
  - 贪心：
    - 复杂度：时间O(n)，空间O(1)
    - 分析：从左向右遍历，一个个数累加；当sum<0，重新开始找子序列
      - 所求最大值max可由if判断语句比较得到，也可由Math.max(i,j)直接求得
      - sum初始化为0，小于0的sum说明累加后比初始值更小了
      - "重新找"指的是：sum归0， 并从下一个元素起，重新累加
    - 算法：
      - 如果题目没有给定非空的范围，第一步判空；
      - 定义最大值max为数组第一个元素，定义子序列和sum为0；
      - 遍历数组：从0到length（左闭右开）
        - 求和：将nums[i]累加到sum；
        - 更新max的值为max和sum中最大的一个；
        - 判断sum与0：如果sum<0，则设置sum=0，重新开始计算子序列和；
      - 返回结果max。
  - 动态规划：
    - 复杂度：时间O(n), 空间O(n)，可优化到O(1)
      - 只用到dp数组中的前一项，因此可以用int代替一维数组，对空间复杂度优化
    - 分析：
      - dp[i]: nums中，以nums[i]结尾的最大子序和
      - dp[i]=max(dp[i-1]+nums[i], nums[i]);
      - 如果加上nums[i]之后的和，比nums[i]本身更小了，说明从nums[i]开始的子序列必然大于从前的和，因此重新开始计算。
    - 算法：
      - 初始化dp数组和max，dp[i]是指以nums[i]结尾的最大子序和;
      - 遍历数组：求dp[i]，并更新max为max和dp[i]中的最大值；
      - 返回结果变量max。
  - 分治：
    - 复杂度：时间O(nlogn)，空间O(logn)
    - 取数组的中心点为中心，那么最大子序列要么在中心左，要么在右，要么跨中心
    - 分三种情况进行考虑
    - 跨中心的情况，又可以分治中心点左侧和右侧的最大子序列问题
    - 注：对比以上思路，分治的思路过于复杂，不详细分析了。
  - 注：
    - 类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值`max=Integer.MIN_VALUE;`
    - Integer是java.lang包下的，自动导入不用再手写import
    - Math是java.lang包下的，不用再手写import
    - 本题可以定义max为数组第一个元素，因为只是累加计算
    
- ## 代码链接：
  - [连续子数组的最大和](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/42_连续子数组的最大和.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 43. 从 1 到 n 整数中 1 出现的次数


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 44. 数字序列中的某一位数字


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 45. 把数组排成最小的数


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 46. 把数字翻译成字符串


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 47. 礼物的最大价值


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->


# 48. 最长不含重复字符的子字符串



<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 49. 丑数
- ## 题目描述
  - 把只包含质因子2、3和5的数称作丑数（Ugly Number）。
  - 例如6、8都是丑数，但14不是，因为它包含质因子7。
  - 习惯上我们把1当做是第一个丑数。
  - 求按从小到大的顺序的第N个丑数。

- ## 解题思路
  - 求丑数的思路：
    - 验证一个数是否是丑数：先看是否能整除2，即取模得0，若可以则整除2直至余数不为0；然后重复3和5
  - 常规思路：
    - 从1开始，依次验证各个数是否符合
    - 问题：对每个数字进行了运算，时间复杂度高
  - 改进思路：
    - 以空间换时间，创建数组保存已经找到的丑数，并在此基础上乘以因子继续找
    - 现在的思路是在丑数的基础上找新的丑数，避免了遍历每个自然数的操作
    - 具体思路：找下一个丑数，设置flag2,3,5，可从已有丑数基础上乘以因子2,3,5，取最小值，同时改变flag值
  - 注意：
    - Math.min()针对两个数，因此写为：`Math.min(next2, Math.min(next3, next5))`

- ## 代码链接
  - [丑数](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/49_%E4%B8%91%E6%95%B0.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 50. 第一个只出现一次的字符位置
- ## 题目描述
  - 在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。
  - 示例: s = "abaccdeff"，返回 "b"；s = "" ，返回 " "
  - 限制：0 <= s 的长度 <= 50000

- ## 解题思路
  - 思路：暴力法；哈希表法。
    - 注：参考<leetcode-136题：只出现一次的数字>，还可以用异或。
  - 暴力法：
    - n个字符，若遍历每个字符并每次扫描整个字符串得到出现次数，时间复杂度是n^2
  - 哈希表：
    - 键设为字符，值设为出现次数，第一次遍历每个字符次数+1，第二次找到
    - 时间复杂度：O(N)，空间复杂度：O(1)
    - 进一步地：可以用数组实现哈希表
    - 利用每个字母的ASCII码作hash来作为数组的index。
      - 用一个58长度的数组来存储每个字母出现的次数；
      - 58是因为A-Z对应的ASCII码为65-90，a-z对应的ASCII码值为97-122，而每个字母的index=int(word)-65，比如g=103-65=38。
    - 数组中具体记录的内容是该字母出现的次数，最终遍历一遍字符串，找出第一个数组内容为1的字母就可以了，时间复杂度为O(n)
    - 算法：
      - 定义数组；
      - 第一次遍历字符串：将字母转为int型，并减去65，作为key值，即索引值；或者直接获取字符并减去A(A==65)；
      - 第二次遍历字符串：如果对应值是1则返回对应的字符；（注意：是遍历字符串，不是遍历数组）
      - 如果循环结束后没有符合条件的，则返回空串（注意空串：单引号中间需要打空格）。
      - 注意返回值类型：char型，因此注意用单引号，特别是空串。
      - 注：不用判空，空串的情况包含在循环判断中了，只是开辟数组空间有点浪费。
  - 注意：
    - ASCII码有256个字符，仅考虑字母（题目说明仅包含字母）
    - ASCII码中的90-96不是字母，但是为了统一减65来计算，所以要再加上6个长度，不然就要判断是否是小写字母，小写字母要减65再减6
    - （无所谓了，写成256大小的数组也可）
    - charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。返回值是一个字符。
    - (int)(charAt())将对应的字符转为int型
  - 异或：
    - 如果是数组数组不是字符串的话，可以考虑这种思路。
    - 位运算，求异，即找不同，相同为0，不同为1。且：0和0为0，0和1为1，而1和1为0.
    - 交换律：a ^ b ^ c <=> a ^ c ^ b
    - 任何数与0异或为任何数 0 ^ n => n -- 与0运算时，有1即为1，否则为0.
    - 相同的数异或为0: n ^ n => 0
    - 示例：var a = [2,3,2,4,4]，`2 ^ 3 ^ 2 ^ 4 ^ 4` 等价于 `2 ^ 2 ^ 4 ^ 4 ^ 3 => 0 ^ 0 ^3 => 3`

- ## 代码链接
  - [第一个只出现一次的字符位置](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/50_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%E4%BD%8D%E7%BD%AE.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 51. 数组中的逆序对


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 52. 两个链表的第一个公共结点
- ## 题目描述
  - 编写一个程序，找到两个单链表相交的起始节点。
  - 注意：
    - 如果两个链表没有交点，返回 null.
    - 在返回结果后，两个链表仍须保持原有的结构。
    - 可假定整个链表结构中没有循环。
    - 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。

- ## 解题思路
  - 思路：暴力法；哈希表法；双指针法
  - 注：本题同LeetCode160题-easy。
  - 方法一: 暴力法
    - 对链表A中的每一个结点 ai ，遍历整个链表 B 并检查链表 B 中是否存在结点和 ai 相同。
    - 复杂度分析：时间O(mn)，空间O(1)。
  - 方法二: 哈希表法 
    - 遍历链表 A 并将每个结点的地址/引用存储在哈希表中。然后检查链表 B 中的每一个结点 bi 是否在哈希表中。若在，则 bi 为相交结点。
    - 复杂度分析：时间O(m+n), 空间 O(m) 或 O(n)。
  - 方法三：双指针法 
    - 复杂度：时间O(m+n)，空间O(1)。
    - 思路：链表A：a+c, 链表B : b+c. a+c+b+c = b+c+a+c 。则会在第二个c起点相遇。若不相交，a+b = b+a 。因此相遇处是NULL（尾）
    - 算法：判空；新建结点；循环：两结点移动，直到相等。
    - 注：没有公共时，最后都指向null，此时相等，退出循环。因此不会死循环。
    - 代码使用了三目运算符，很巧妙。
      - 注意：三目运算符，如果pa或pb为null，则指向headA或headB，不是pb或pa！！！
  - 注：剑指原书提供了一种栈从尾到头比较，最后一个相同结点即为所求的方法。

- ## 代码链接:
  - [两个链表的第一个公共结点](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/52_两个链表的第一个公共结点.java)
  
<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 53. 数字在排序数组中出现的次数


<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->




# 54. 二叉查找树的第 K 个结点

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->





# 55.1 二叉树的深度
- ## 问题描述
  - 输入一棵二叉树，求该树的深度。
  - 从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。
  
- ## 解题思路
  - 考虑“记录二叉树的路径”的方法比较繁琐
  - 递归的思想。分析规律可知用递归比较快。
  - 可以用三元运算符 A?B:C 将代码化简为一句代码。
  - 分析：
    - 如果只有根节点：深度为1
    - 如果只有左子树：深度为左子树的深度+1
    - 如果只有右子树：深度为右子树的深度+1
    - 如果既有左子树又有右子树：深度为左右子树的深度中的较大值+1
    - 结合图示更清晰

- ## 代码链接
  - [二叉树的深度](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/55_1_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 55.2 平衡二叉树
- ## 题目描述
  - 给定一个二叉树，判断它是否是高度平衡的二叉树。
  - 本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。
  - 示例 1: 给定二叉树 [3,9,20,null,null,15,7]，返回 true 。
  - 示例 2: 给定二叉树 [1,2,2,3,3,null,null,4,4]，返回 false 。

- ## 解题思路
  - 思路：dfs -- 自顶向下，自底向上
  - 平衡二叉树（Balanced Binary Tree）具有以下性质：
    - 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1
    - 并且左右两个子树都是一棵平衡二叉树。
    - 注：子树也是平衡树在题目中没有说，但是具有此性质，判断时需要判断左右子树也平衡才行
  - 自顶向下（暴力法）：
    - 复杂度：时间O(nlogn)，空间O(n)
    - 算法：判空返回真；调用height函数判断子树高度差<2,以及调用本体函数判断左右子树是否平衡
    - height函数：判空返回-1，否则返回1+max(root.left的高度,root.right的高度)
      - 注：-1对应叶节点(两子树为-1，再+1为0，即一个结点深度为0)，最大子树高度+1是指加上子树到根结点这层
    - 注意：
      - 减法：要取绝对值，否则可能是负数 `Math.abs()`
  - 自底向上（提前阻断）：
    - 复杂度：时间O(n)，空间O(n)
    - 思路是对二叉树做先序遍历，从底至顶返回子树最大高度，若判定某子树不是平衡树则 “剪枝” ，直接向上返回。
    - 方法一计算 height 存在大量冗余。每次调用 height 时，要同时计算其子树高度。但是自底向上计算，每个子树的高度只会计算一次。可以递归先计算当前节点的子节点高度，然后再通过子节点高度判断当前节点是否平衡，从而消除冗余。
    - 算法：
      - 使用与方法一中定义的 height 方法。逻辑相反，首先判断子树是否平衡，然后比较子树高度判断父节点是否平衡。
      - 算法如下：检查子树是否平衡。如果平衡，则使用它们的高度判断父节点是否平衡，并计算父节点的高度。
      - 当发现不是平衡树时，后面的高度计算都没有意义了，因此一路返回-1，避免后续多余计算。
  - 区别：
    - 自底向上会在递归过程中加入判断，如果出现不符合情况直接阻断；
    - 自顶向下则是无脑递归，中间不进行判断。
  - 注意：root为空时，符合平衡树条件。
        
- ## 代码链接:
  - [平衡二叉树](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/55_2_%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 56. 数组中只出现一次的数字
- ## 题目描述
  - 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

- ## 解题思路


- ## 代码链接
  - []()

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->





# 57.1 和为 S 的两个数字
- ## 题目描述
  - 输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S
  - 如果有多对数字的和等于S，输出两个数的乘积最小的。

- ## 解题思路
  - 使用双指针，一个指针指向元素较小的值，一个指针指向元素较大的值。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。
    - 如果两个指针指向元素的和 sum == target，那么得到要求的结果；
    - 如果 sum > target，移动较大的元素，使 sum 变小一些；
    - 如果 sum < target，移动较小的元素，使 sum 变大一些。
  - a+b=sum,a和b越远乘积越小，而一头一尾两个指针往内靠近的方法找到的就是乘积最小的情况
  - 注意牛客题目默认用了ArrayList：
    - 实现了List的接口，实现了可变大小的数组，随机访问和遍历元素时，提供更好的性能。
    - 该类也是非同步的,在多线程的情况下不要使用。
    - ArrayList 增长当前长度的50%，插入删除效率低。
    - 往list添加元素：list.add(array[index]); -- list.add(x);

- ## 代码链接
  - [和为S的两个数字](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/57_1_%E5%92%8C%E4%B8%BAS%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->




# 57.2 和为 S 的连续正数序列
- ## 题目描述
  - 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。
  - 现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!
  - 输出描述:
    - 输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序
    - 例如：sum=15时，[1,2,3,4,5], [4,5,6], [7,8]

- ## 解题思路
  - 参考上一题的思路：双指针技术
    - 相当于有一个窗口，窗口的左右两边就是两个指针，根据窗口内值之和来确定窗口的位置和宽度。
    - 虽然双指针或者所谓的滑动窗口技巧还是蛮常见的，但是这一题还真想不到这个思路。
  - 基本步骤：
    - 初始化两个指针big和small，并在自然数上移动两个指针（循环），直到小指针追上大指针。
    - 设置窗口内的和cur，由于是等差数列，cur可由（a1+an）n/2的等差数列求和公式求得。
    - 当cur<sum时，可以增大big指针，增加窗口内的数值，以此增大cur的值
    - 当cur>sum时，可以增大small指针，减少窗口内的数值，以此减小cur的值
    - 当cur=sum时，循环将窗口内的序列添加到list内，并big++来继续寻找符合的序列。
    - 当small追上big时，表示不再有符合条件的序列了。跳出循环。
  - 注意：
    - 本题默认`public ArrayList<ArrayList<Integer> > FindContinuousSequence(int sum)`，即元素为ArrayList的ArrayList
    - ArrayList<Integer>: list.add(i);
    - ArrayList<ArrayList<Integer>>: result.add(list);

- ## 代码链接
  - [和为S的连续正数序列](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/57_2_%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 58.1 翻转单词顺序列
- ## 题目描述
  - 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？
  - 说明：LeetCode相关题目<151题-medium>中对本题进行了修改，加入对空格的处理，如下：
    - 无空格字符构成一个单词。
    - 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
    - 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。

- ## 解题思路
  - 思路：两次翻转(字符角度)；一次翻转(字符串角度)
  - 注：本题按照对空格处理和不对空格处理，分别整理代码。
  - 分析：
    - 两次翻转：从字符数组的角度，一次翻转所有字母，一次翻转每个单词。每个单词以空格分隔。
    - 一次翻转：从字符串数组的角度，从后遍历字符串数组，并添加到可变字符串，判断后添加一个空格。
    - 翻转：即依次交换收尾，然后夹逼。
    - 可以将翻转功能定义为private函数然后直接调用，提高代码复用性。
    - 多空格：`String[] s1=s.trim().split(" +");` -- 加上+以后，可以剪去字符串之间的多个空格，只保留非空格字符。  
  - 算法1：两次翻转
    - 定义翻转指定索引值的字符串的函数并定义为私有；
    - 首先处理空格：剪去所有空格后，将字符串数组重新用一个空格连起来；
    - 将字符串转为字符数组；
    - 定义双指针：大指针遍历并找空格，小指针为要翻转单词的首个索引；
    - 遍历：翻转每个单词；
    - 翻转整个字符串；
    - 返回：新建字符串，并将字符数组传入。
  - 算法2：一次翻转
    - 首先处理空格：剪去所有空格后，将字符串数组重新用一个空格连起来；
    - 定义可变字符串StringBuilder；
    - 从后遍历字符串数组：如果不是第一个元素，则额外添加空格，否则，只添加元素本身；
    - 将可变字符串转为String类型，并返回。
    - 注：简单多了，但是用了很多库函数吧。

- ## 代码链接
  - [翻转单词顺序列](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/58_1_%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 58.2 左旋转字符串
- ## 题目描述
  - 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。
  - 请定义一个函数实现字符串左旋转操作的功能。
  - 比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。
  - 示例 1：
    - 输入: s = "abcdefg", k = 2
    - 输出: "cdefgab"
  - 示例 2：
    - 输入: s = "lrloseumgh", k = 6
    - 输出: "umghlrlose"
  - 限制：1 <= k < s.length <= 10000

- ## 解题思路
  - 思路：三次翻转
    - 具体地，先将 "abc" 和 "XYZdef" 分别翻转，得到 "cbafedZYX"，然后再把整个字符串翻转得到 "XYZdefabc"
  - 注意：仍然是先转成字符数组进行操作，最后再转成String返回
  - 算法：
    - 定义翻转函数；
    - 边界值判断；（如果题目规定边界值，可简化或省略）
    - 将字符串转为字符数组；
    - 整体翻转以及分别翻转两段字符串；
    - 重新构建字符串并返回。
  - 注意：
    - return Arrays.toString(chs); //返回值："[f, g, a, b, c, d, e]"，不符合格式
    - 翻转时注意先整体翻转还是后整体翻转，先后顺序不同，则两端字符串的翻转范围也不一样。
  - 直接用库函数substring：注意是左闭右开的。
  
- ## 代码链接
  - [左旋转字符串](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/58_2_%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 59.1 滑动窗口的最大值
- ## 题目描述
  - 给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
  - 返回滑动窗口中的最大值。

- ## 解题思路
  - 同LeetCode239题
  - 思路：暴力法；双向队列；动态规划
  - ### 暴力法：
    - 复杂度：时间O(nk)，空间O(n-k+1)，n是数组元素个数
    - 遍历每个滑动窗口，找到每个窗口的最大值。
    - 一共有 N - k + 1 个滑动窗口，每个有 k 个元素，于是算法的时间复杂度为 O(Nk)，表现较差。
    - 算法：
      - 定义数组元素个数n
      - 判空：`n*k==0`，意味着n和k中存在0，此时，新建长度为0的数组并返回
        - 注：测试用例`输入：[] 0; 输出：[]`，因此判空不能返回null，需要返回新建长度为0的数组
      - 定义结果数组output，数组长度为滑动窗口个数 `n-k+1`
      - 两层循环：外层控制起始，内层控制小窗口内的遍历
        - 定义最大值max，遍历本窗口内的所有数字并更新max，然后将max作为output[i]存入结果数组
      - 返回结果数组
  - ### 双向队列
    - 复杂度：时间O(n)，空间O(n)
    - 存储双向队列的索引，以优化时间复杂度
      - 队首存储每个窗口的最大值，队尾存储可能成为最大值的其他元素（当最大值滑出后）
    - 先遍历第一个窗口，找出最大值；然后从第二个窗口开始遍历，以每个窗口最右端为基准，遍历至最后一个元素
    - 清理双向队列:
      - 只保留当前滑动窗口中有的元素的索引。
      - 移除比当前元素小的所有元素，它们不可能是最大的。
    - 算法：
      - 定义数组元素个数n；
      - 判空：`n*k==0`；
      - 边界值：`k=1`时返回原数组；
      - 新建数组双端队列deq：`ArrayDeque<Integer> deq = new ArrayDeque<Integer>();`；
      - 定义窗口最大值对应的索引max_index；
      - 首先：遍历第一个窗口，清理队首队尾，将元素添加到队列last，并找出最大值；
      - 定义输出数组output，并将第一个元素初始化为max_index对应的元素；
      - 其次：以每个窗口的最右端为基准，从第二个窗口开始，遍历至数组末尾最后一个元素
        - 首先清理队首first：判断 -- 当队列不为空，且队首等于本窗口最左侧的左侧元素时，移除首位（i-k是已经滑出本窗口的最近索引）；
        - 其次清理队尾last：循环（可能存在多个不符的队尾元素） -- 当队列不为空，且当前元素大于队尾时，移除队尾元素；
          - 这里：如果i索引值大于已有队尾，会在这一步移除，因此，下一步直接添加到队尾即可，包含了两种情况
        - 将当前元素的索引添加到队列（作为在最大值滑出窗口后，可能成为最大值的元素，放入队尾）
        - 最后将队首索引值对应的数组元素赋值给第i个元素
      - 返回结果数组output
      - 注：
        - 存入队列的是索引值，不是数组元素值；
        - 赋值给结果数组output的是队首索引值对应的数组元素，不是直接将队首元素存入结果数组；
        - 清理队首队尾重复代码，可以封装到一个函数中，这里就全写在同一个函数中了；

- ## 代码链接
  - [滑动窗口的最大值](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/59_1_滑动窗口的最大值.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 59.2 队列的最大值
- ## 题目描述


- ## 解题思路


- ## 代码链接
  - [队列的最大值]()

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->




# 60. n 个骰子的点数
- ## 题目描述


- ## 解题思路


- ## 代码链接
  - []()

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 61. 扑克牌顺子
- ## 题目描述


- ## 解题思路


- ## 代码链接
  - []()

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 62. 圆圈中最后剩下的数
- ## 题目描述


- ## 解题思路


- ## 代码链接
  - []()

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->




# 63. 股票的最大利润
- ## 题目描述
  - 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
  - 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。
  - 注意你不能在买入股票前卖出股票。
  - 限制：0 <= 数组长度 <= 10^5
  - 示例 1: 输入: [7,1,5,3,6,4]，输出: 5
    - 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
    - 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
  - 示例 2: 输入: [7,6,4,3,1]，输出: 0
    - 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0

- ## 解题思路
  - 思路：暴力法；一次遍历
  - 暴力法：
    - 复杂度：时间O(n^2)，空间O(1)
    - max初始化为0(至少为0)；
    - 两次遍历：外层控制开始位置，内层比较从开始位置往后的值，并不断更新减去开始结点所得的最大值。
    - 最终返回max。
  - 一次遍历：
    - 复杂度：时间O(n)，空间O(1)
    - 思路：找到最小的谷之后的最大的峰
    - 维持两个变量 - minprice 和 maxprofit，它们分别对应迄今为止所得到的最小的谷值和最大的利润（卖出价格与最低价格之间的最大差值）。
    - 算法：定义两个最值并初始化；遍历：先小后大 - 当[i]值更小时，更新min，否则，比较[i]-min与max的大小并更新max；返回max。

- ## 代码链接
  - [股票的最大利润](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/63_股票的最大利润.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 64. 求1+2+3+...+n
- ## 题目描述
  - 求1+2+3+...+n
  - 要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

- ## 解题思路
  - 思路：递归，短路与
  - 分析：
    - 求前n项和：等差数列求和公式有乘除；逐项累加用到循环；
    - 递归：不能用循环的情况下，只能用递归来实现循环的过程；
    - &&：短路可以用来做判断，前一个成立则做后一个，前一个不成立时，后一个不再做。
    - 综：利用短路 && 来实现 if 的功能；利用递归来实现循环while的功能
  - 算法： 
    - 借助一个不需要返回的布尔型值来实现这个与运算递归过程。
    - 从n开始往前递归，在最开始的地方0不操作并返回值：
    - 当n==0时，(n>0)&&((sum+=Sum_Solution(n-1))>0)只执行前面的判断，为false，然后直接返回0；
    - 当n>0时，执行sum+=Sum_Solution(n-1)，实现递归计算Sum_Solution(n)。
  - 注意：双与连接的都是布尔型变量，可以在进行计算的`sum+=..`部分加一个`>0`之类的判断。
  - 思路拓展：同样的道理，用双或||也是可以的，详见代码

- ## 代码链接
  - [求1+2+3+...+n](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/64_%E6%B1%821%2B2%2B3%2B...%2Bn.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 65. 不用加减乘除做加法
- ## 题目描述
  - 写一个函数，求两个整数之和，要求在函数体内不得使用加减乘除四则运算符号。

- ## 解题思路
  - 首先看十进制是如何做的： 5+7=12，三步走
    - 第一步：相加各位的值，不算进位，得到2。
    - 第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。
    - 第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。
  - 用三步走的方式计算二进制值相加： 5-101，7-111 
    - 第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。
    - 第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&111)<<1。
    - 第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&1010)<<1。
    - 继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。
  - 综上，使用异或和左移进行加法运算，在进位相加时（遇加法可调用本函数）递归，重复以上两步
  - 算法：
    - 不进位相加：0+0,1+1得0,而1+0,0+1得1，这与“异或”运算的结果相同，即不同时得1，反之得0.
    - 进位：0+0,1+0,0+1都不进位，只有1+1进位，这与“与运算”的结果相同，且进位在高一位，因此左移1位；
    - 将第一步的“不进位相加”结果与第二步的“进位并左移”结果相加：相加又可以调用本体函数，构成循环；
    - 重复，直到不产生进位：只有存在进位时，才需要继续做加法；若没有进位，则循环停止。
    - 然而事实是：循环停止的条件是，当两个数中有一个数变为0时，返回另一个数
  - 关键要找到这个规律
    - 两个数异或：相当于每一位相加，而不考虑进位；
    - 两个数相与，并左移一位：相当于求得进位；
    - 将上述两步的结果相加，相加则递归
    
- ## 代码链接
  - [不用加减乘除做加法](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/65_%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 66. 构建乘积数组
- ## 题目描述
  - 给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1]
  - 其中B中的元素B[i]=A[0]×A[1]×...×A[i-1]×A[i+1]×...×A[n-1]。
  - 不能使用除法。

- ## 解题思路
  - B[i]的值可以看作对角线为1、其余每行为A[i]的矩阵中每行的乘积。
  - 下三角用连乘可以很容求得，上三角，从下向上也是连乘。
  - 因此可以先算下三角中的连乘，即先算出B[i]中的一部分，然后倒过来按上三角中的分布规律，把另一部分也乘进去。
  - 规律：下三角从上到下递归，上三角从下到上递归。注意循环的起点。
  - 配合矩阵图食用效果更佳。

- ## 代码链接
  - [构建乘积数组](https://github.com/anliux/PracticePool/blob/master/jzoffer/src/65_%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 67. 把字符串转换成整数
- ## 题目描述
  - 将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0
  - 输入描述: 输入一个字符串,包括数字字母符号,可以为空
  - 输出描述: 如果是合法的数值表达则返回该数字，否则返回0
  - 示例：
    - 输入：+2147483647     1a33
    - 输出：2147483647      0

- ## 解题思路


- ## 代码链接
  - []()

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->



# 68. 树中两个节点的最低公共祖先
- ## 题目描述


- ## 解题思路


- ## 代码链接
  - []()

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->

