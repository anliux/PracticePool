//198-打家劫舍
//思路：动态规划



//动态规划：0ms，击败100%的用户
/*
  - 设f(n)是长度为n的数组对应的结果，通过列出前几项来找规律：
    - n=1时，f(1) = arr[0]
    - n=2时，f(2) = max(arr[0], arr[1])
    - n=3时，f(3) = max( f(1) + arr[2], f(2) )
    - n=3的解释：选第三个时，必然不能选第二个，即在n=1最优解的基础上加第三个；或者不选第三个，仍然用第二份的最优解。最后在两个值中取max
    - 同理，f(n) = max( f(n-2)+arr[n-1], f(n-1)), 其中arr[n-2]表示第n个元素
  - f(n)可以存储在数组中，但是考虑到每次只需要用到前两项，因此可以用变量更新的方法，节约空间。
  - 算法：定义变量表示前两项并初始化为0；循环遍历整个数组：公式求f(n)，并更新前两项的值；返回最终结果。
    - 注：初始化前两项时，不能直接定义arr[0]和arr[1]，因为没有判断就直接用，可能数组角标越界异常。
    - 表示前两项的变量dp1和dp2初始化为0，因为dp1的值在后面用不到了，因此只把dp2的值暂存在tmp中，计算后将值赋值作为新的dp1
*/
class Solution {
    public int rob(int[] nums) {
        //定义变量表示前两项并初始化
        int dp1 = 0;
        int dp2 = 0;

        //循环遍历数组
        for(int i=0; i<nums.length; i++){
            int res = Math.max(dp1 + nums[i], dp2);
            dp1 = dp2;
            dp2 = res;
        }

        //返回结果：最终结果存储在dp2中
        return dp2;
    }
}
