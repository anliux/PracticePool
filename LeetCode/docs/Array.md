# 数组
- 内含题目：220

# 目录
<!-- GFM-TOC -->
* [1. 两数之和](#1-两数之和)
* [26. 删除排序数组中的重复项](#26-删除排序数组中的重复项)
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
<!-- GFM-TOC -->



# 1. 两数之和
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
    - 假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
  - ### 解题思路
    - 1. 暴力法：思路简单，双层循环时间复杂度高 O(n^2), O(1)
    - 2. 哈希表：用空间换时间，降低时间复杂度 O(n), O(n)
    - 哈希表有两种思路：
      - 一种是先保存到表，后进行匹配
      - 一种是在保存到表的同时进行匹配
- ## 代码链接：
  - [两数之和](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0001-two-sum.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 26. 删除排序数组中的重复项
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
    - 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
  - 解题思路
    - 双指针
    - 双指针具体操作：
      - 数组完成排序后，放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。
        - i，j是数组索引值
        - 注：j负责遍历整个数组（循环），i负责控制新数组的长度（返回值）
      - 只要 nums[i] = nums[j]，就增加 j 以跳过重复项（j是快指针）；
        - 仅j增加，没有其他操作，可作为循环体中if判断的不成立情况，这时，每次循环仅j自增
      - 当 nums[j] != nums[i] 时，跳过重复项的运行已经结束；
        - 这种情况下，有后续操作，可作为循环体中if判断成立的情况，并把后续操作放在if语句中
      - 把 nums[j] 的值复制到 nums[i + 1]；
      - 然后递增 i，再次重复相同的过程，直到 j 到达数组的末尾为止。
      - 遍历结束后返回慢指针 i+1
    
- ## 代码链接：
  - [删除排序数组中的重复项](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0026-remove-duplicates-from-sorted-array.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->




### END
