# 数组
- 内含题目：220

# 目录
<!-- GFM-TOC -->
* [1. 两数之和](#1-两数之和)
* [11. 盛最多水的容器](#11-盛最多水的容器)
* [26. 删除排序数组中的重复项](#26-删除排序数组中的重复项)
* [27. 移除元素](#27-移除元素)
* [35. 搜索插入位置](#35-搜索插入位置)
* [53. 最大子序和](#53-最大子序和)
* [66. 加一](#66-加一)
* [88. 合并两个有序数组](#88-合并两个有序数组)
* [118. 杨辉三角](#118-杨辉三角)
* [119. 杨辉三角II](#119-杨辉三角ii)
* [121. 买卖股票的最佳时机](#121-买卖股票的最佳时机)
* [122. 买卖股票的最佳时机II](#122-买卖股票的最佳时机ii)
* [167. 两数之和II-输入有序数组](#167-两数之和ii-输入有序数组)
* [169. 多数元素](#169-多数元素)
* [189. 旋转数组](#189-旋转数组)
* [](#)
* [](#)
* [](#)
* [](#)
* [](#)
* [](#)
<!-- GFM-TOC -->



# 1. 两数之和
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
    - 假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
  - ### 解题思路
    - 1. 暴力法：思路简单，双层循环时间复杂度高 O(n^2), O(1)
    - 2. 哈希表：用空间换时间，降低时间复杂度 O(n), O(n)
    - 哈希表有两种思路：
      - 一种是先保存到表，后进行匹配
      - 一种是在保存到表的同时进行匹配
- ## 代码链接：
  - [两数之和](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0001-two-sum.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 11. 盛最多水的容器
- ## 简述：（[medium](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium.md)）
  - ### 题目描述
    - 给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
    - 说明：你不能倾斜容器，且 n 的值至少为 2。
    - 示例: 输入: [1,8,6,2,5,4,8,3,7]，输出: 49
  - ### 解题思路
    - 思路：暴力法；双指针法
    - 暴力法：
      - 复杂度：时间O(n^2)，空间O(1)
      - 简单地考虑每对可能出现的线段组合并找出这些情况之下的最大面积
      - 算法：定义最大面积max；两层循环：外层控制起始基准，内层控制从基准到末尾的所有可能情况，计算并更新最大值；返回结果max。
    - 双指针法：
      - 复杂度：时间O(n)，空间O(1)
      - 关键：两线段之间形成的区域总是会受到其中较短那条长度的限制。此外，两线段距离越远，得到的面积就越大。
      - 在由线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾。
      - 使用变量 maxarea 来持续存储到目前为止所获得的最大面积。 在每一步中，我们会找出指针所指向的两条线段形成的区域，更新 maxarea，并将指向较短线段的指针向较长线段那端移动一步。
      - 算法：
        - 定义双指针left和right，以及面积最大值max并初始化；
        - 循环直到两指针交错：计算当前指针构成的面积，并对max更新，然后移动较小的指针；
        - 最后返回结果max。

- ## 代码链接：
  - [盛最多水的容器](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0011-container-with-most-water.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 26. 删除排序数组中的重复项
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
    - 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
  - ### 解题思路
    - 双指针
    - 双指针具体操作：
      - 数组完成排序后，放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。
        - i，j是数组索引值
        - 注：j负责遍历整个数组（循环），i负责控制新数组的长度（返回值）
      - 只要 nums[i] = nums[j]，就增加 j 以跳过重复项（j是快指针）；
        - 仅j增加，没有其他操作，可作为循环体中if判断的不成立情况，这时，每次循环仅j自增
      - 当 nums[j] != nums[i] 时，跳过重复项的运行已经结束；
        - 这种情况下，有后续操作，可作为循环体中if判断成立的情况，并把后续操作放在if语句中
      - 把 nums[j] 的值复制到 nums[i + 1]；
      - 然后递增 i，再次重复相同的过程，直到 j 到达数组的末尾为止。
      - 遍历结束后返回慢指针 i+1
    
- ## 代码链接：
  - [删除排序数组中的重复项](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0026-remove-duplicates-from-sorted-array.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 27. 移除元素
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个数组 nums 和一个值 val，原地移除所有数值等于 val 的元素，返回移除后数组的新长度。
    - 不要使用额外的数组空间，必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
    - 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
  - ### 解题思路
    - 双指针（分为常规双指针和不需要移动）
    - 双指针具体操作：
      - 保留两个指针 i 和 j，其中 i 是慢指针，j 是快指针。
      - 当 nums[j] 与给定的值相等时，递增 j 以跳过该元素。
      - 只要 nums[j] != val，就复制 nums[j] 到 nums[i] ，并同时递增两个索引。
      - 重复这一过程，直到 j 到达数组的末尾，该数组的新长度为 i。
    - 当要删除元素很少时的双指针：
      - 注：这里的双指针不是快慢指针，是首尾指针，一前一后逼近
      - 若val只占1或2个，且在首、尾等位置时，为了避免不必要的操作，对原来双指针方法进行改进
      - 当遇到 nums[i] = valnums[i]=val 时，可以将当前元素与最后一个元素进行交换，并释放最后一个元素。
        - 这实际上使数组的大小减少了 1。
      - 请注意，被交换的最后一个元素可能是想要移除的值。但是不要担心，在下一次迭代中，仍然会检查这个元素

- ## 代码链接：
  - [移除元素](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0027-remove-element.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 35. 搜索插入位置
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。
    - 如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
  - ### 解题思路
    - 思路：暴力法；二分查找
    - 暴力法：
      - 遍历并比较，直到`nums[i] < target`不再成立
    - 二分：
      - 常规二分查找的写法会超时....
    - 内置函数二分查找：
      - 使用`Arrays.binarySearch(nums, target)`并在找不到时返回-a-1
      - 用时0ms...

- ## 代码链接：
  - [搜索插入位置](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0035-search-insert-position.java)


<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 53. 最大子序和
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
    - 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6
      - 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
    - 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。
  - ### 解题思路
    - 思路：暴力法；动态规划；贪心；分治
    - 暴力法：
      - 复杂度：时间O(N^2)，空间O(1)
      - 寻找所有的可能子序和，并求最大值
      - 首先定义并初始化max为数组第一个元素
      - 按照一定规律遍历数组，比如从i开始遍历到末尾，不断取和，比较并取max，然后i++
      - 两层循环：外循环控制开始的i值，内循环控制在i索引开始，形成的子序列
    - 贪心：
      - 复杂度：时间O(n)，空间O(1)
      - 从左向右遍历，一个个数累加；当sum<0，重新开始找子序列
        - 所求最大值max可由if判断语句比较得到，也可由Math.max(i,j)直接求得
        - sum初始化为0，小于0的sum说明累加后比初始值更小了
        - "重新找"指的是：sum归0， 并从下一个元素起，重新累加
    - 动态规划：
      - 复杂度：时间O(n), 空间O(n)，可优化到O(1)
        - 只用到dp数组中的前一项，因此可以用int代替一维数组，对空间复杂度优化
      - dp[i]: nums中，以nums[i]结尾的最大子序和
      - dp[i]=max(dp[i-1]+nums[i], nums[i]);
    - 分治：
      - 复杂度：时间O(nlogn)，空间O(logn)
      - 取数组的中心点为中心，那么最大子序列要么在中心左，要么在右，要么跨中心
      - 分三种情况进行考虑
      - 跨中心的情况，又可以分治中心点左侧和右侧的最大子序列问题
      - 注：对比以上思路，分治的思路过于复杂，不详细分析了。
    - 注：
      - 类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值`max=Integer.MIN_VALUE;`
      - Integer是java.lang包下的，自动导入不用再手写import
      - Math是java.lang包下的，不用再手写import
      - 本题可以定义max为数组第一个元素，因为只是累加计算
 
- ## 代码链接：
  - [最大子序和](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0053-maximum-subarray.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 66. 加一
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。
    - 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
    - 你可以假设除了整数 0 之外，这个整数不会以零开头。
  - ### 解题思路
    - 思路：其实是数学问题，即+1，存在一个“进位”与否的问题
    - 关键：取余后判断是否为0，若为0，则有进位，继续循环；否则，直接返回数组
    - 从末尾开始遍历至索引值为0，遍历到的digits[i]+1后取余，然后判断；
    - 若循环结束后还没有返回，则可能是多个

- ## 代码链接：
  - [加一](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0066-plus-one.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 88. 合并两个有序数组
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。
  - ### 解题思路
    - 思路：暴力法；双指针从前遍历；双指针从后遍历
    - 暴力法
      - 先复制数组2到数组1，后排序
      - 复杂度：时间O((m+n)log(m+n))，空间O(1)
    - 双指针从前往后：
      - 先把数组1存起来，然后选值存入数组1，最后如果仍有剩余，直接存入
      - 复杂度：时间O(n)，空间O(n)
    - 双指针从后往前：
      - 改进：优化了空间复杂度，不用另外存数组1
      - 复杂度：时间O(n)，空间O(1)
    - 注意
      - 数组是引用型数据变量，操作即改变本体，不需要return，结果保存在数组1中即可  
      - 本身不难，但要特别注意临界值
  
- ## 代码链接：
  - [合并两个有序数组](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0088-merge-sorted-array.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 118. 杨辉三角
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。
    - 在杨辉三角中，每个数是它左上方和右上方的数的和。每行生成方式为：首尾补1，其余位置为上一行两数相加。
  - ### 解题思路
    - 思路：动态规划
    - “左上方和右上方的数的和”放在数组中即为正上方和斜前方，即上一行i-1和i的位置
    - 复杂度：时间O(n)，空间O(n)
    - 首先，生成整个 triangle 列表，三角形的每一行都以子列表的形式存储。
    - 然后，检查行数为 0 的特殊情况（直接返回triangle），否则返回 [1] （[1]只有一个元素，赋值为1）。
    - 循环遍历：
      - 外循环：控制行数，本行遍历结束后记得把本行结果添加到triangle
      - 内循环：控制每行的元素
    - 最后返回所得triangle

- ## 代码链接
  - [杨辉三角](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0118-pascals-triangle.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 119. 杨辉三角II
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。
    - 示例: 输入: 3，输出: [1,3,3,1]
    - 进阶：你可以优化你的算法到 O(k) 空间复杂度吗？
  - ### 解题思路
    - 思路：动态规划；公式法(略)
    - 本题与118题的区别：118是生成所有，本体是生成最大行
    - 优化1:仅保留前一行即可，即二维List改为一维List
    - 优化2:倒着遍历可以节约空间，只定义一个List即可。否则需要定义一个pre的List，和一个cur的List
    - 非负索引k：不需要考虑0，直接从1开始算起
    - 算法：新建一维List；添加第0行元素1；循环：外层行数，内层倒着遍历并set()重置原有元素；返回一维List。
    - 注意：根据示例，3对应[1,3,3,1]，即从第0行开始算起；不同于118题，根据示例，是从第1行开始算起的。
    - 注意：重置用set(); 获取List已有元素用get() -- `cur.set(j, cur.get(j - 1) + cur.get(j));`
    
- ## 代码链接
  - [杨辉三角II](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0119-pascals-triangle-ii.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->  
 
  
  
# 121. 买卖股票的最佳时机
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
    - 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。
    - 注意你不能在买入股票前卖出股票。
  - ### 解题思路
    - 思路：暴力法；一次遍历
    - 暴力法：
      - 复杂度：时间O(n^2)，空间O(1)
      - max初始化为0(至少为0)；
      - 两次遍历：外层控制开始位置，内层比较从开始位置往后的值，并不断更新减去开始结点所得的最大值。
      - 最终返回max。
    - 一次遍历：
      - 复杂度：时间O(n)，空间O(1)
      - 思路：找到最小的谷之后的最大的峰
      - 维持两个变量 - minprice 和 maxprofit，它们分别对应迄今为止所得到的最小的谷值和最大的利润（卖出价格与最低价格之间的最大差值）。
      - 算法：定义两个最值并初始化；遍历：先小后大 - 当[i]值更小时，更新min，否则，比较[i]-min与max的大小并更新max；返回max。

- ## 代码链接
  - [买卖股票的最佳时机](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0121-best-time-to-buy-and-sell-stock.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->  
  


# 122. 买卖股票的最佳时机II
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
    - 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
    - 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
  - ### 解题思路
    - 思路：暴力法；贪心；
    - 暴力法：（dfs递归）
      - 复杂度：时间O(n^n)，空间O(1)
      - 两层遍历，外层控制开始位置，内层验证所有情况并找到最值。（计算与所有可能的交易组合相对应的利润，并找出它们中的最大利润）
      - 定义calculate函数，传入数组和起始位置参数，并在符合条件时递归调用本体
      - 注：参考官方题解写了一份代码，最后意料之中的超时了。超时也是错误，迷惑行为大赏....PS本篇官方题解就是屎
    - 贪心：
      - 复杂度：时间O(n)，空间O(1)
      - 股票买卖策略：
        - 单独交易日：设今天价格 p1 、明天价格 p2 ，则今天买入、明天卖出可赚取金额 p2−p1 (负值代表亏损）。
        - 连续上涨交易日：设此上涨交易日股票价格分别为 p1,p2,...,pn ，则第一天买最后一天卖收益最大，即 pn−p1 ；等价于每天都买卖，即 pn−p1=(p2−p1)+(p3−p2)+...+(pn−pn−1)。
        - 连续下降交易日：则不买卖收益最大，即不会亏钱。
      - 算法流程：
        - 遍历整个股票交易日价格列表 price，策略是所有上涨交易日都买卖（赚到所有利润），所有下降交易日都不买卖（永不亏钱）。
        - 设 tmp 为第 i-1 日买入与第 i 日卖出赚取的利润，即 tmp = prices[i] - prices[i - 1]；
        - 当该天利润为正 tmp > 0，则将利润加入总利润 profit；当利润为 0 或为负，则直接跳过；
        - 遍历完成后，返回总利润 profit。
      - 这篇写得很清晰，比云里雾里的官方题解好多了。  

- ## 代码链接
  - [买卖股票的最佳时机II](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0122-best-time-to-buy-and-sell-stock-ii.java)  
  
<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->  
  


# 167. 两数之和II-输入有序数组
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个 已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。
    - 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。
    - 说明:
      - 返回的下标值（index1 和 index2）不是从零开始的。
      - 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
  - ### 解题思路
    - 分析：与1题的区别：数组是有序的。
      - 注：1题的解题思路包括暴力法；哈希表（两次哈希表；一次哈希表）
    - 思路：双指针与二分查找的结合
    - 使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。
      - 如果两个指针指向元素的和 sum==target，那么得到要求的结果；
      - 如果 sum>target，移动较大的元素，使 sum 变小一些；
      - 如果 sum<target，移动较小的元素，使 sum 变大一些。
    - 复杂度：时间O(N)，空间O(1)。
    - 算法：判空；定义两变量作为左右指针并初始化；循环直到(a<b)不再成立：比较sum与target并移动指针；最后返回null。
      - 循环条件(a<b)：题目要求index1必须小于index2
      - 找到时返回数组的索引值要+1：题目要求返回的下标值（index1 和 index2）不是从零开始的，是从1开始的。

- ## 代码链接:
  - [相交链表](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0167-two-sum-ii-input-array-is-sorted.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->  



# 169. 多数元素
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。
    - 你可以假设数组是非空的，并且给定的数组总是存在多数元素。
  - ### 解题思路
    - 思路：暴力法；哈希表法；排序；分治；投票..
    - 暴力法：
      - 复杂度：时间O(n^2)，空间O(1)
      - 暴力算法遍历整个数组，然后用另一重循环统计每个数字出现的次数。将出现次数比其他数字加起来出现次数还多的元素返回。
      - 算法：初始化n/2；双层循环：外层控制比较基准，内层统计与基准相同的个数，并在内层结束后与n/2比较；最后return任一int型，比如-1.
      - 不足：时间复杂度过高
    - 哈希表：
      - 复杂度：时间O(n)，空间O(n)
      - 使用哈希表来存储每个元素，然后用一个循环在线性时间内遍历 nums ，然后我们只需要返回有最大值的键。
      - 算法：
        - 新建哈希表；
        - 新建max值和次数的变量；
        - 遍历数组：第一次出现时count赋值为1，否则在哈希表中对应count基础上+1，每次判断count范围并更新max两个变量；
        - 返回max值。
      - HashMap知识点：
        - `getOrDefault(Object key, V defaultValue)` : 如果存在key返回对应的value，否则返回defaultValue
    - 排序：
      - 复杂度：时间O(nlogn)，空间O(1)
      - 如果所有数字被单调递增或者单调递减的顺序排了序，那么众数的下标为n/2
      - 算法：对数组排序；返回排序后的n/2索引对应的元素
    - 摩尔投票法：
      - 复杂度：时间O(n)，空间O(1)
      - 把众数记为 +1，把其他数记为 −1 ，将它们全部加起来，显然和大于 0 ，从结果本身我们可以看出众数比其他数多。
      - 算法：
        - 定义比较基准flag=nums[0]和计数器count=1；
        - 遍历数组：与基准相同+1，不同-1，且变为0时，更新基准为下一个索引对应的元素；
        - 返回最后计数器不为0的基准。
    
- ## 代码链接:
  - [多数元素](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0169-majority-element.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->  



# 189. 旋转数组
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。
    - 说明: 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题；要求使用空间复杂度为 O(1) 的 原地 算法。
  - ### 解题思路
    - 思路：暴力法；额外数组；环状替换；反转。
    - 暴力法：
      - 复杂度：时间O(n*k)，空间O(1) -- k是移动的位置数
      - 思路：
        - 不使用额外空间时，需要把被占用的位置的数字存起来，并且需要时时更新（不是数组），之后将变量与要存放的数字交换；
        - 用循环实现，每次移动一步，一共移动k次。因此两层循环：外层控制k，内层控制遍历整个数组。
        - 内层循环中进行交换操作：将之前存起来的元素放在此刻的位置，将此刻位置的元素存起来。
      - 算法：定义两个变量；两层循环：外层控制k，把末尾元素存起来，内层控制遍历数组，内层循环中进行交换。
    - 额外数组：
      - 复杂度：时间O(n)，空间O(n)
      - 分析：用一个额外的数组来将每个元素放到正确的位置上，原本数组里下标为 i 的把它放到 `(i+k)%数组长度` 的位置。然后把新的数组拷贝到原数组中。
      - `(i+k)%数组长度`: 
        - 未超过数组长度的，结果为i+k；
        - 整除取余的部分是针对i+k超过数组长度时，相当于(i+k)分为n倍数组长度再加余数，n倍铺满整个数组，余数即从头开始
      - 算法：定义辅助数组；一次遍历：以正确位置顺序将数据存入辅助数组；二次遍历：将辅助数组的数据按照位置移动到原数组。
    - 环状替换：
      - 复杂度：时间O(n)，空间O(1)
      - 分析: 
        - 直接把每一个数字放到它最后的位置，把被替换的数字保存在变量 temp 里面。
        - 然后，将被替换数字（temp）放到它正确的位置，并继续这个过程 n 次， n 是数组的长度。因为需要将数组里所有的元素都移动。
        - 特殊情况：如果 n%k==0，其中 k=k%n （因为如果 k 大于 n ，移动 k 次实际上相当于移动 k%n 次）。
        - 这种情况下，会在没有遍历所有数字的情况下回到出发数字。此时，从下一个数字开始再重复相同的过程。
      - 算法：
        - 对移动距离k进行处理（针对k>n的情况），并初始化计数器count；
        - 两层循环：外层为保证当n%k==0时，从下一个数字开始重复，实际是每个位置只走一次，时间复杂度仍然是n
        - 外层控制：环状的开始，从首位开始循环，start++，因为一共要移动n次，循环条件是计数器不再满足count<nums.length时结束；
        - 外层每次定义并维护两个指针：发射点cur和接收点next，并将start位置的元素存入临时变量pre，pre相当于弹道；
        - 内层循环：初始化next，交换pre与next位置的元素，并更新旧的接收点next为新的发射点cur，并且此时子弹已经进入弹道pre了，同时count++
        - 内层循环的循环条件：start!=cur，即当发射点又回到本次环状的起始位置start时，说明这一轮已经到头了，此时结束循环。
      - 注：本方法太烧脑了，毕竟代码是写给人类看的...
    - 反转：
      - 复杂度：时间O(n)，空间O(1)
      - 分析：首先将所有元素反转。然后反转前 k 个元素，再反转后面 n−k 个元素，就能得到想要的结果。
      - 注：本方法是基于`反转数组`的方法，是剑指offer中对旋转数组问题的解决思路。
      - 算法：定义反转函数reverse；本体函数中，先对k进行取余处理；然后反转整个数组；然后反转前k个；最后反转剩余数组。
      - 反转数组：双指针，一头一尾，交换头尾，然后更新两个指针使其向中间靠。当left指针不再小于right指针时，停止循环。  

- ## 代码链接:
  - [旋转数组](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0189-rotate-array.java) 
  
<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->  




### END
