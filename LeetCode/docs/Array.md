# 数组
- 内含题目：220

# 目录
<!-- GFM-TOC -->
* [1. 两数之和](#1-两数之和)
* [26. 删除排序数组中的重复项](#26-删除排序数组中的重复项)
* [27. 移除元素](#27-移除元素)
* [35. 搜索插入位置](#35-搜索插入位置)
* [53. 最大子序和](#53-最大子序和)
* [66. 加一](#66-加一)
* [88. 合并两个有序数组](#88-合并两个有序数组)
* [118. 杨辉三角](#118-杨辉三角)
* [119. 杨辉三角II](#119-杨辉三角ii)
* [121. 买卖股票的最佳时机](#121-买卖股票的最佳时机)
* [122. 买卖股票的最佳时机II](#122-买卖股票的最佳时机ii)
* []()
<!-- GFM-TOC -->



# 1. 两数之和
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
    - 假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
  - ### 解题思路
    - 1. 暴力法：思路简单，双层循环时间复杂度高 O(n^2), O(1)
    - 2. 哈希表：用空间换时间，降低时间复杂度 O(n), O(n)
    - 哈希表有两种思路：
      - 一种是先保存到表，后进行匹配
      - 一种是在保存到表的同时进行匹配
- ## 代码链接：
  - [两数之和](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0001-two-sum.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 26. 删除排序数组中的重复项
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
    - 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
  - ### 解题思路
    - 双指针
    - 双指针具体操作：
      - 数组完成排序后，放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。
        - i，j是数组索引值
        - 注：j负责遍历整个数组（循环），i负责控制新数组的长度（返回值）
      - 只要 nums[i] = nums[j]，就增加 j 以跳过重复项（j是快指针）；
        - 仅j增加，没有其他操作，可作为循环体中if判断的不成立情况，这时，每次循环仅j自增
      - 当 nums[j] != nums[i] 时，跳过重复项的运行已经结束；
        - 这种情况下，有后续操作，可作为循环体中if判断成立的情况，并把后续操作放在if语句中
      - 把 nums[j] 的值复制到 nums[i + 1]；
      - 然后递增 i，再次重复相同的过程，直到 j 到达数组的末尾为止。
      - 遍历结束后返回慢指针 i+1
    
- ## 代码链接：
  - [删除排序数组中的重复项](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0026-remove-duplicates-from-sorted-array.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 27. 移除元素
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个数组 nums 和一个值 val，原地移除所有数值等于 val 的元素，返回移除后数组的新长度。
    - 不要使用额外的数组空间，必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
    - 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
  - ### 解题思路
    - 双指针（分为常规双指针和不需要移动）
    - 双指针具体操作：
      - 保留两个指针 i 和 j，其中 i 是慢指针，j 是快指针。
      - 当 nums[j] 与给定的值相等时，递增 j 以跳过该元素。
      - 只要 nums[j] != val，就复制 nums[j] 到 nums[i] ，并同时递增两个索引。
      - 重复这一过程，直到 j 到达数组的末尾，该数组的新长度为 i。
    - 当要删除元素很少时的双指针：
      - 注：这里的双指针不是快慢指针，是首尾指针，一前一后逼近
      - 若val只占1或2个，且在首、尾等位置时，为了避免不必要的操作，对原来双指针方法进行改进
      - 当遇到 nums[i] = valnums[i]=val 时，可以将当前元素与最后一个元素进行交换，并释放最后一个元素。
        - 这实际上使数组的大小减少了 1。
      - 请注意，被交换的最后一个元素可能是想要移除的值。但是不要担心，在下一次迭代中，仍然会检查这个元素

- ## 代码链接：
  - [移除元素](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0027-remove-element.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 35. 搜索插入位置
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。
    - 如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
  - ### 解题思路
    - 思路：暴力法；二分查找
    - 暴力法：
      - 遍历并比较，直到`nums[i] < target`不再成立
    - 二分：
      - 常规二分查找的写法会超时....
    - 内置函数二分查找：
      - 使用`Arrays.binarySearch(nums, target)`并在找不到时返回-a-1
      - 用时0ms...

- ## 代码链接：
  - [搜索插入位置](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0035-search-insert-position.java)


<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 53. 最大子序和
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
    - 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6
      - 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
    - 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。
  - ### 解题思路
    - 思路：暴力法；动态规划；贪心；分治
    - 暴力法：
      - 复杂度：时间O(N^2)，空间O(1)
      - 寻找所有的可能子序和，并求最大值
      - 首先定义并初始化max为数组第一个元素
      - 按照一定规律遍历数组，比如从i开始遍历到末尾，不断取和，比较并取max，然后i++
      - 两层循环：外循环控制开始的i值，内循环控制在i索引开始，形成的子序列
    - 贪心：
      - 复杂度：时间O(n)，空间O(1)
      - 从左向右遍历，一个个数累加；当sum<0，重新开始找子序列
        - 所求最大值max可由if判断语句比较得到，也可由Math.max(i,j)直接求得
        - sum初始化为0，小于0的sum说明累加后比初始值更小了
        - "重新找"指的是：sum归0， 并从下一个元素起，重新累加
    - 动态规划：
      - 复杂度：时间O(n), 空间O(n)，可优化到O(1)
        - 只用到dp数组中的前一项，因此可以用int代替一维数组，对空间复杂度优化
      - dp[i]: nums中，以nums[i]结尾的最大子序和
      - dp[i]=max(dp[i-1]+nums[i], nums[i]);
    - 分治：
      - 复杂度：时间O(nlogn)，空间O(logn)
      - 取数组的中心点为中心，那么最大子序列要么在中心左，要么在右，要么跨中心
      - 分三种情况进行考虑
      - 跨中心的情况，又可以分治中心点左侧和右侧的最大子序列问题
      - 注：对比以上思路，分治的思路过于复杂，不详细分析了。
    - 注：
      - 类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值`max=Integer.MIN_VALUE;`
      - Integer是java.lang包下的，自动导入不用再手写import
      - Math是java.lang包下的，不用再手写import
      - 本题可以定义max为数组第一个元素，因为只是累加计算
 
- ## 代码链接：
  - [最大子序和](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0053-maximum-subarray.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 66. 加一
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。
    - 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
    - 你可以假设除了整数 0 之外，这个整数不会以零开头。
  - ### 解题思路
    - 思路：其实是数学问题，即+1，存在一个“进位”与否的问题
    - 关键：取余后判断是否为0，若为0，则有进位，继续循环；否则，直接返回数组
    - 从末尾开始遍历至索引值为0，遍历到的digits[i]+1后取余，然后判断；
    - 若循环结束后还没有返回，则可能是多个

- ## 代码链接：
  - [加一](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0066-plus-one.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 88. 合并两个有序数组
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。
  - ### 解题思路
    - 思路：暴力法；双指针从前遍历；双指针从后遍历
    - 暴力法
      - 先复制数组2到数组1，后排序
      - 复杂度：时间O((m+n)log(m+n))，空间O(1)
    - 双指针从前往后：
      - 先把数组1存起来，然后选值存入数组1，最后如果仍有剩余，直接存入
      - 复杂度：时间O(n)，空间O(n)
    - 双指针从后往前：
      - 改进：优化了空间复杂度，不用另外存数组1
      - 复杂度：时间O(n)，空间O(1)
    - 注意
      - 数组是引用型数据变量，操作即改变本体，不需要return，结果保存在数组1中即可  
      - 本身不难，但要特别注意临界值
  
- ## 代码链接：
  - [合并两个有序数组](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0088-merge-sorted-array.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 118. 杨辉三角
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。
    - 在杨辉三角中，每个数是它左上方和右上方的数的和。每行生成方式为：首尾补1，其余位置为上一行两数相加。
  - ### 解题思路
    - 思路：动态规划
    - “左上方和右上方的数的和”放在数组中即为正上方和斜前方，即上一行i-1和i的位置
    - 复杂度：时间O(n)，空间O(n)
    - 首先，生成整个 triangle 列表，三角形的每一行都以子列表的形式存储。
    - 然后，检查行数为 0 的特殊情况（直接返回triangle），否则返回 [1] （[1]只有一个元素，赋值为1）。
    - 循环遍历：
      - 外循环：控制行数，本行遍历结束后记得把本行结果添加到triangle
      - 内循环：控制每行的元素
    - 最后返回所得triangle

- ## 代码链接
  - [杨辉三角](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0118-pascals-triangle.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 119. 杨辉三角II
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。
    - 示例: 输入: 3，输出: [1,3,3,1]
    - 进阶：你可以优化你的算法到 O(k) 空间复杂度吗？
  - ### 解题思路
    - 思路：动态规划；公式法(略)
    - 本题与118题的区别：118是生成所有，本体是生成最大行
    - 优化1:仅保留前一行即可，即二维List改为一维List
    - 优化2:倒着遍历可以节约空间，只定义一个List即可。否则需要定义一个pre的List，和一个cur的List
    - 非负索引k：不需要考虑0，直接从1开始算起
    - 算法：新建一维List；添加第0行元素1；循环：外层行数，内层倒着遍历并set()重置原有元素；返回一维List。
    - 注意：根据示例，3对应[1,3,3,1]，即从第0行开始算起；不同于118题，根据示例，是从第1行开始算起的。
    - 注意：重置用set(); 获取List已有元素用get() -- `cur.set(j, cur.get(j - 1) + cur.get(j));`
    
- ## 代码链接
  - [杨辉三角II](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0119-pascals-triangle-ii.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->  
 
  
  
# 121. 买卖股票的最佳时机
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
    - 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。
    - 注意你不能在买入股票前卖出股票。
  - ### 解题思路
    - 思路：暴力法；一次遍历
    - 暴力法：
      - 复杂度：时间O(n^2)，空间O(1)
      - max初始化为0(至少为0)；
      - 两次遍历：外层控制开始位置，内层比较从开始位置往后的值，并不断更新减去开始结点所得的最大值。
      - 最终返回max。
    - 一次遍历：
      - 复杂度：时间O(n)，空间O(1)
      - 思路：找到最小的谷之后的最大的峰
      - 维持两个变量 - minprice 和 maxprofit，它们分别对应迄今为止所得到的最小的谷值和最大的利润（卖出价格与最低价格之间的最大差值）。
      - 算法：定义两个最值并初始化；遍历：先小后大 - 当[i]值更小时，更新min，否则，比较[i]-min与max的大小并更新max；返回max。

- ## 代码链接
  - [买卖股票的最佳时机](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0121-best-time-to-buy-and-sell-stock.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->  
  


# 122. 买卖股票的最佳时机II
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
    - 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
    - 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
  - ### 解题思路
    - 思路：暴力法；贪心；
    - 暴力法：（dfs递归）
      - 复杂度：时间O(n^n)，空间O(1)
      - 两层遍历，外层控制开始位置，内层验证所有情况并找到最值。（计算与所有可能的交易组合相对应的利润，并找出它们中的最大利润）
      - 定义calculate函数，传入数组和起始位置参数，并在符合条件时递归调用本体
      - 注：参考官方题解写了一份代码，最后意料之中的超时了。超时也是错误，迷惑行为大赏....PS本篇官方题解就是屎
    - 贪心：
      - 复杂度：时间O(n)，空间O(1)
      - 股票买卖策略：
        - 单独交易日：设今天价格 p1 、明天价格 p2 ，则今天买入、明天卖出可赚取金额 p2−p1 (负值代表亏损）。
        - 连续上涨交易日：设此上涨交易日股票价格分别为 p1,p2,...,pn ，则第一天买最后一天卖收益最大，即 pn−p1 ；等价于每天都买卖，即 pn−p1=(p2−p1)+(p3−p2)+...+(pn−pn−1)。
        - 连续下降交易日：则不买卖收益最大，即不会亏钱。
      - 算法流程：
        - 遍历整个股票交易日价格列表 price，策略是所有上涨交易日都买卖（赚到所有利润），所有下降交易日都不买卖（永不亏钱）。
        - 设 tmp 为第 i-1 日买入与第 i 日卖出赚取的利润，即 tmp = prices[i] - prices[i - 1]；
        - 当该天利润为正 tmp > 0，则将利润加入总利润 profit；当利润为 0 或为负，则直接跳过；
        - 遍历完成后，返回总利润 profit。
      - 这篇写得很清晰，比云里雾里的官方题解好多了。  

- ## 代码链接
  - [买卖股票的最佳时机II](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0122-best-time-to-buy-and-sell-stock-ii.java)  
  
<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->  
  



### END
