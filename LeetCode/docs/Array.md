# 数组
- 内含题目：220

# 目录
<!-- GFM-TOC -->
* [1. 两数之和](#1-两数之和)
* [11. 盛最多水的容器](#11-盛最多水的容器)
* [15. 三数之和](#15-三数之和)
* [16. 最接近的三数之和](#16-最接近的三数之和)
* [26. 删除排序数组中的重复项](#26-删除排序数组中的重复项)
* [27. 移除元素](#27-移除元素)
* [34. 在排序数组中查找元素的第一个和最后一个位置](#34-在排序数组中查找元素的第一个和最后一个位置)
* [35. 搜索插入位置](#35-搜索插入位置)
* [39. 组合总和](#39-组合总和)
* [53. 最大子序和](#53-最大子序和)
* [54. 螺旋矩阵](#54-螺旋矩阵)
* [66. 加一](#66-加一)
* [88. 合并两个有序数组](#88-合并两个有序数组)
* [118. 杨辉三角](#118-杨辉三角)
* [119. 杨辉三角II](#119-杨辉三角ii)
* [121. 买卖股票的最佳时机](#121-买卖股票的最佳时机)
* [153. 寻找旋转排序数组中的最小值](#153-寻找旋转排序数组中的最小值)
* [154. 寻找旋转排序数组中的最小值II](#154-寻找旋转排序数组中的最小值ii)
* [167. 两数之和II-输入有序数组](#167-两数之和ii-输入有序数组)
* [169. 多数元素](#169-多数元素)
* [189. 旋转数组](#189-旋转数组)
* [](#)
* [](#)
* [](#)
* [509. 斐波那契数](#509-斐波那契数)
* [](#)
* [914. 卡牌分组](#914-卡牌分组)
* [1013. 将数组分成和相等的三个部分](#1013-将数组分成和相等的三个部分)
<!-- GFM-TOC -->



# 1. 两数之和
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
    - 假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
  - ### 解题思路
    - 1. 暴力法：思路简单，双层循环时间复杂度高 O(n^2), O(1)
    - 2. 哈希表：用空间换时间，降低时间复杂度 O(n), O(n)
    - 哈希表有两种思路：
      - 一种是先保存到表，后进行匹配
      - 一种是在保存到表的同时进行匹配
- ## 代码链接：
  - [两数之和](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0001-two-sum.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 11. 盛最多水的容器
- ## 简述：（[medium](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium.md)）
  - ### 题目描述
    - 给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
    - 说明：你不能倾斜容器，且 n 的值至少为 2。
    - 示例: 输入: [1,8,6,2,5,4,8,3,7]，输出: 49
  - ### 解题思路
    - 思路：暴力法；双指针法
    - 暴力法：
      - 复杂度：时间O(n^2)，空间O(1)
      - 简单地考虑每对可能出现的线段组合并找出这些情况之下的最大面积
      - 算法：定义最大面积max；两层循环：外层控制起始基准，内层控制从基准到末尾的所有可能情况，计算并更新最大值；返回结果max。
    - 双指针法：
      - 复杂度：时间O(n)，空间O(1)
      - 关键：两线段之间形成的区域总是会受到其中较短那条长度的限制。此外，两线段距离越远，得到的面积就越大。
      - 在由线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾。
      - 使用变量 maxarea 来持续存储到目前为止所获得的最大面积。 在每一步中，我们会找出指针所指向的两条线段形成的区域，更新 maxarea，并将指向较短线段的指针向较长线段那端移动一步。
      - 算法：
        - 定义双指针left和right，以及面积最大值max并初始化；
        - 循环直到两指针交错：计算当前指针构成的面积，并对max更新，然后移动较小的指针；
        - 最后返回结果max。

- ## 代码链接：
  - [盛最多水的容器](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0011-container-with-most-water.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 15. 三数之和
- ## 简述：（[medium](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium.md)）
  - ### 题目描述
    - 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。
    - 注意：答案中不可以包含重复的三元组。
    - 示例：给定数组 nums = [-1, 0, 1, 2, -1, -4]，
    - 满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2] ]
  - ### 解题思路
    - 思路：双指针
    - 分析：
      - 题目要求返回值类型 `List<List<Integer>>`：新建变量ans存储结果 `List<List<Integer>> ans = new ArrayList();`
      - 题目要求“三个数”之和：判空 -- 数组为空或者数组长度小于3时返回ans（空）
      - 首先排序：排序后就可以用双指针逼近结果 `Arrays.sort(nums);`
      - 因为是三个数，因此需要三个指针：本题设置一个基准i，然后将i+1和nums.length-1作为双指针，然后这两个指针逼近
      - 外循环：遍历基准，从0开始，到数组末尾为止，循环体中首先排除各种不符合的情况，然后移动指针查找符合的元素 
        - 不符合1：基准大于0时必然不符，nums[i]>0则break；
        - 不符合2：基准重复的去重，在i>0的情况下，nums[i]==nums[i-1]时会导致重复，continue继续循环；
        - 定义左右指针；
        - 内循环：以nums[i]为基准移动指针，直到左右指针相遇（相等或交错即停止）
          - 定义sum为基准与左右指针的和
          - 对所得sum的正负进行判断
          - sum为正时，偏大，right指针减小；sum为负时，偏小，left指针增大；
          - sum为0时：添加到结果ans，对左右指针的下一个值判断并去重，之后移动指针
      - 返回结果ans。
    - 算法：
      - 定义二维List；
      - 边界值判断：判空和判断数组长度小于3；
      - 排序得到有序数组；
      - 循环：外循环控制基准，内循环控制某个基准的双指针遍历数组
        - 边界值判断：基准大于0；基准去重；
        - 定义左右指针；
        - 内循环：求sum；根据sum的正负情况分别移动指针 -- 注意sum为0时指针去重；
      - 返回结果。
    - ArrayList知识点
      - 新建：`List<List<Integer>> ans = new ArrayList();`
      - 添加：`ans.add(Arrays.asList(nums[i],nums[L],nums[R]));` -- 不需要new
      - Arrays的方法 `asList(T... a)`：返回一个受指定数组支持的固定大小的列表。
    
- ## 代码链接：
  - [三数之和](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0015-3sum.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 16. 最接近的三数之和
- ## 简述：（[medium](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium.md)）
  - ### 题目描述
    - 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。
    - 找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。
    - 例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.
    - 与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).
  - ### 解题思路
    - 思路：双指针
    - 注：本题同上一题15题非常相似，用形似的步骤求解即可
    - 算法：边界值；排序；两层循环遍历；返回结果。没要求，因此不用去重。
      - 边界值：假设必存在答案的话，此步可省略（否则也不知道该return什么）；
      - 数组排序：调用`Arrays.sort(nums)`; 用nlogn的时间复杂度；
      - 定义结果res，并初始化为数组中的前三个元素之和，否则容易出现定义过大或过小的问题；
      - 两层循环：外层控制基准，内层控制双指针遍历数组
        - 定义左右指针
        - 内循环：求基准+左右指针对应元素的和；更新res；根据sum与target比较情况移动指针；
      - 返回结果res。

- ## 代码链接：
  - [最接近的三数之和](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0016-3sum-closest.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 26. 删除排序数组中的重复项
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
    - 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
  - ### 解题思路
    - 双指针
    - 双指针具体操作：
      - 数组完成排序后，放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。
        - i，j是数组索引值
        - 注：j负责遍历整个数组（循环），i负责控制新数组的长度（返回值）
      - 只要 nums[i] = nums[j]，就增加 j 以跳过重复项（j是快指针）；
        - 仅j增加，没有其他操作，可作为循环体中if判断的不成立情况，这时，每次循环仅j自增
      - 当 nums[j] != nums[i] 时，跳过重复项的运行已经结束；
        - 这种情况下，有后续操作，可作为循环体中if判断成立的情况，并把后续操作放在if语句中
      - 把 nums[j] 的值复制到 nums[i + 1]；
      - 然后递增 i，再次重复相同的过程，直到 j 到达数组的末尾为止。
      - 遍历结束后返回慢指针 i+1
    
- ## 代码链接：
  - [删除排序数组中的重复项](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0026-remove-duplicates-from-sorted-array.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 27. 移除元素
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个数组 nums 和一个值 val，原地移除所有数值等于 val 的元素，返回移除后数组的新长度。
    - 不要使用额外的数组空间，必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
    - 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
  - ### 解题思路
    - 双指针（分为常规双指针和不需要移动）
    - 双指针具体操作：
      - 保留两个指针 i 和 j，其中 i 是慢指针，j 是快指针。
      - 当 nums[j] 与给定的值相等时，递增 j 以跳过该元素。
      - 只要 nums[j] != val，就复制 nums[j] 到 nums[i] ，并同时递增两个索引。
      - 重复这一过程，直到 j 到达数组的末尾，该数组的新长度为 i。
    - 当要删除元素很少时的双指针：
      - 注：这里的双指针不是快慢指针，是首尾指针，一前一后逼近
      - 若val只占1或2个，且在首、尾等位置时，为了避免不必要的操作，对原来双指针方法进行改进
      - 当遇到 nums[i] = valnums[i]=val 时，可以将当前元素与最后一个元素进行交换，并释放最后一个元素。
        - 这实际上使数组的大小减少了 1。
      - 请注意，被交换的最后一个元素可能是想要移除的值。但是不要担心，在下一次迭代中，仍然会检查这个元素

- ## 代码链接：
  - [移除元素](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0027-remove-element.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 34. 在排序数组中查找元素的第一个和最后一个位置
- ## 简述：（[medium](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium.md)）
  - ### 题目描述
    - 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
    - 你的算法时间复杂度必须是 O(log n) 级别。
    - 如果数组中不存在目标值，返回 [-1, -1]。
    - 示例 1:
      - 输入: nums = [5,7,7,8,8,10], target = 8
      - 输出: [3,4]
    - 示例 2:
      - 输入: nums = [5,7,7,8,8,10], target = 6
      - 输出: [-1,-1]
  - ### 解题思路
    - 参考：剑指-53.1-在排序数组中查找数字的思路
    - 思路：二分查找
    - 复杂度：时间O(logn), 空间O(1)
    - 分析：
      - 排序数组中的搜索问题，首先想到 二分法 解决。
        - 但可能只找到target其中之一，若向前向后遍历来找所有target，则时间复杂度变为暴力遍历相同的O(n)。
      - 排序数组 nums 中的所有数字 target 形成一个窗口，记窗口的 左 / 右边界 索引分别为 left 和 right ，分别对应窗口左边 / 右边的首个元素。
      - 本题要求统计数字 target 的出现次数，可转化为：使用二分法分别找到 左边界 left 和 右边界 right ，易得数字 target 的数量为 right−left+1 
        - 分别用二分求左右边界，则时间复杂度仍为O(logn)。
    - 算法：
      - 初始化边界指针为数组的左右端点；
      - 两次二分；
        - 不等时，同二分处理；
        - nums[mid]与target相等时：
          - 右边界：在mid对应元素的右侧，因此小指针更新为mid+1；
          - 左边界：在mid对应元素的左侧，因此大指针更新为mid-1；
          - 注：这种区别可以通过<=的等于号，并配合if-else实现。
      - 判空：根据左右边界值索引求长度，若为0，则target不存在，返回{-1,-1}
      - 新建数组，并将最终的左右边界索引传入后返回；
      - 注：target不存在的情况会返回0，符合预期结果。
    - 改进：两次二分的代码可以封装起来，然后进行调用，并直接返回差值。
      - 数组 nums 中元素都为整数，因此可以分别二分查找 target 和 target−1 的右边界，将两结果相减并返回即可。
      - 未尝试：如果target-1对应的值不存在或存在多个，需要考虑的东西很多。  
  
- ## 代码链接：
  - [在排序数组中查找元素的第一个和最后一个位置](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0034-find-first-and-last-position-of-element-in-sorted-array.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 35. 搜索插入位置
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。
    - 如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
  - ### 解题思路
    - 思路：暴力法；二分查找
    - 暴力法：
      - 遍历并比较，直到`nums[i] < target`不再成立
    - 二分：
      - 常规二分查找的写法会超时....
    - 内置函数二分查找：
      - 使用`Arrays.binarySearch(nums, target)`并在找不到时返回-a-1
      - 用时0ms...

- ## 代码链接：
  - [搜索插入位置](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0035-search-insert-position.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 39. 组合总和
- ## 简述：（[medium](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium.md)）
  - ### 题目描述
    - 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
    - candidates 中的数字可以无限制重复被选取。
    - 说明：
      - 所有数字（包括 target）都是正整数。
      - 解集不能包含重复的组合。  
    - 示例 1:
      - 输入: candidates = [2,3,6,7], target = 7,
      - 所求解集为: [  [7],  [2,2,3]  ]
    - 示例 2:
      - 输入: candidates = [2,3,5], target = 8,
      - 所求解集为: [ [2,2,2,2],  [2,3,3],  [3,5]  ]
  - ### 解题思路
    - 思路：回溯法+深度优先遍历
    - 分析：
      - 根据示例 1：输入: candidates = [2,3,6,7]，target = 7。
        - 候选数组里有 2 ，如果找到了 7 - 2 = 5 的所有组合，再在之前加上 2 ，就是 7 的所有组合；
        - 同理考虑 3，如果找到了 7 - 3 = 4 的所有组合，再在之前加上 3 ，就是 7 的所有组合，依次这样找下去；
        - 根据图示，得到路径[[2, 2, 3], [2, 3, 2], [3, 2, 2], [7]]，而示例中的解集只有 [[7], [2, 2, 3]]；
        - 重复的原因是在较深层的结点值考虑了之前考虑过的元素，因此我们需要设置“下一轮搜索的起点”即可（这里可能没有说清楚，已经尽力了）。
      - 图示分析：
        - ![0039-1](https://raw.githubusercontent.com/anliux/PracticePool/master/LeetCode/images/0039-1.png)
        - ![0039-2](https://raw.githubusercontent.com/anliux/PracticePool/master/LeetCode/images/0039-2.png)
      - 去重复
        - 在搜索的时候，需要设置搜索起点的下标 begin ，由于一个数可以使用多次，下一层的结点从这个搜索起点开始搜索；
        - 在搜索起点 begin 之前的数因为以前的分支搜索过了，所以一定会产生重复。
      - 剪枝提速
        - 如果一个数位搜索起点都不能搜索到结果，那么比它还大的数肯定搜索不到结果，基于这个想法，我们可以对输入数组进行排序，以减少搜索的分支；
        - 排序是为了提高搜索速度，非必要；
        - 搜索问题一般复杂度较高，能剪枝就尽量需要剪枝。
        - 把候选数组排个序，遇到一个较大的数，如果以这个数为起点都搜索不到结果，后面的数就更搜索不到结果了。
    - 算法：
      - 主体函数+调用函数
      - 主体函数：新建二维结果数组res；对给定数组排序；调用dfs函数；返回结果数组res。
      - 调用函数：
        - 参数列表：给定数组candidates，除存入path元素之外的剩余目标值rest，开始位置索引值begin，本路径path，最终结果res
        - 首先：判断rest是否等于0，等于是即为找到一组，将结果存入res，并返回；
        - 循环遍历给定数组：首先判断rest是否小于数组元素，小于则break；然后将数组元素添加到path的后面之后调用dfs深度遍历；之后回溯，将path的last元素去掉重新遍历。
    - 知识点：
      - ArrayDeque：双向队列接口
        - addFirst(E e)：将指定元素插入此双端队列的开头。
        - addLast(E e)：将指定元素插入此双端队列的末尾。
        - removeLast()：获取并移除此双端队列的最后一个元素。
      - ArrayList：数组
        - 构造函数：ArrayList(Collection<? extends E> c)：
          - 构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。
        - add(E e)：将指定的元素添加到此列表的尾部。
      
- ## 代码链接：
  - [组合总和](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0039-combination-sum.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 53. 最大子序和
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
    - 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6
      - 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
    - 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。
  - ### 解题思路
    - 思路：暴力法；动态规划；贪心；分治
    - 暴力法：
      - 复杂度：时间O(N^2)，空间O(1)
      - 寻找所有的可能子序和，并求最大值
      - 首先定义并初始化max为数组第一个元素
      - 按照一定规律遍历数组，比如从i开始遍历到末尾，不断取和，比较并取max，然后i++
      - 两层循环：外循环控制开始的i值，内循环控制在i索引开始，形成的子序列
    - 贪心：
      - 复杂度：时间O(n)，空间O(1)
      - 从左向右遍历，一个个数累加；当sum<0，重新开始找子序列
        - 所求最大值max可由if判断语句比较得到，也可由Math.max(i,j)直接求得
        - sum初始化为0，小于0的sum说明累加后比初始值更小了
        - "重新找"指的是：sum归0， 并从下一个元素起，重新累加
    - 动态规划：
      - 复杂度：时间O(n), 空间O(n)，可优化到O(1)
        - 只用到dp数组中的前一项，因此可以用int代替一维数组，对空间复杂度优化
      - dp[i]: nums中，以nums[i]结尾的最大子序和
      - dp[i]=max(dp[i-1]+nums[i], nums[i]);
    - 分治：
      - 复杂度：时间O(nlogn)，空间O(logn)
      - 取数组的中心点为中心，那么最大子序列要么在中心左，要么在右，要么跨中心
      - 分三种情况进行考虑
      - 跨中心的情况，又可以分治中心点左侧和右侧的最大子序列问题
      - 注：对比以上思路，分治的思路过于复杂，不详细分析了。
    - 注：
      - 类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值`max=Integer.MIN_VALUE;`
      - Integer是java.lang包下的，自动导入不用再手写import
      - Math是java.lang包下的，不用再手写import
      - 本题可以定义max为数组第一个元素，因为只是累加计算
 
- ## 代码链接：
  - [最大子序和](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0053-maximum-subarray.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 54. 螺旋矩阵
- ## 简述：（[medium](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium.md)）
  - ### 题目描述
    - 给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。
    - 示例 1:
      - 输入: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ]
      - 输出: [1,2,3,6,9,8,7,4,5]
    - 示例 2:
      - 输入: [  [1, 2, 3, 4],  [5, 6, 7, 8],  [9,10,11,12] ]
      - 输出: [1,2,3,4,8,12,11,10,9,5,6,7]
  - ### 解题思路
    - 思路：模拟，设定边界
    - 分析：
      - 判空：当数组长度为0时，返回new int[0]; -- 注：本题规定了取值范围，因此判空可以省略。
      - 顺时针打印矩阵的顺序是 “从左向右、从上向下、从右向左、从下向上” 循环。
      - 因此，考虑设定矩阵的“左、上、右、下”四个边界，模拟以上矩阵遍历顺序。
    - 算法：
      - 复杂度：时间O(mn), 空间O(1) -- m、n为矩阵的行列数。
      - 判空：当数组长度为0时，return new ArrayList<>()；
      - 初始化四个边界，以及结果数组的索引值；
      - 初始化结果数组list；
      - 循环：死循环，跳出控制在循环体内。
        - 按照“从左向右、从上向下、从右向左、从下向上” 的顺序遍历，同时更新各个指标的值。
        - 用for循环完成一条边的遍历：注意循环起始位置是某一边界值；
        - 每次遍历完一条边之后，都要进行判断，当边界交错时，break跳出循环。
      - 返回结果数组list。
    - 注意：
      - 1. 与剑指offer29题的区别：本题返回值类型是List
      - 2. 如果用List，不用index，则if判断中，同时进行边界值更新时++--在前。

- ## 代码链接：
  - [螺旋矩阵](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0054-spiral-matrix.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 66. 加一
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。
    - 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
    - 你可以假设除了整数 0 之外，这个整数不会以零开头。
  - ### 解题思路
    - 思路：其实是数学问题，即+1，存在一个“进位”与否的问题
    - 关键：取余后判断是否为0，若为0，则有进位，继续循环；否则，直接返回数组
    - 从末尾开始遍历至索引值为0，遍历到的digits[i]+1后取余，然后判断；
    - 若循环结束后还没有返回，则可能是多个

- ## 代码链接：
  - [加一](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0066-plus-one.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 88. 合并两个有序数组
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。
  - ### 解题思路
    - 思路：暴力法；双指针从前遍历；双指针从后遍历
    - 暴力法
      - 先复制数组2到数组1，后排序
      - 复杂度：时间O((m+n)log(m+n))，空间O(1)
    - 双指针从前往后：
      - 先把数组1存起来，然后选值存入数组1，最后如果仍有剩余，直接存入
      - 复杂度：时间O(n)，空间O(n)
    - 双指针从后往前：
      - 改进：优化了空间复杂度，不用另外存数组1
      - 复杂度：时间O(n)，空间O(1)
    - 注意
      - 数组是引用型数据变量，操作即改变本体，不需要return，结果保存在数组1中即可  
      - 本身不难，但要特别注意临界值
  
- ## 代码链接：
  - [合并两个有序数组](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0088-merge-sorted-array.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 118. 杨辉三角
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。
    - 在杨辉三角中，每个数是它左上方和右上方的数的和。每行生成方式为：首尾补1，其余位置为上一行两数相加。
  - ### 解题思路
    - 思路：动态规划
    - “左上方和右上方的数的和”放在数组中即为正上方和斜前方，即上一行i-1和i的位置
    - 复杂度：时间O(n)，空间O(n)
    - 首先，生成整个 triangle 列表，三角形的每一行都以子列表的形式存储。
    - 然后，检查行数为 0 的特殊情况（直接返回triangle），否则返回 [1] （[1]只有一个元素，赋值为1）。
    - 循环遍历：
      - 外循环：控制行数，本行遍历结束后记得把本行结果添加到triangle
      - 内循环：控制每行的元素
    - 最后返回所得triangle

- ## 代码链接
  - [杨辉三角](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0118-pascals-triangle.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 119. 杨辉三角II
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。
    - 示例: 输入: 3，输出: [1,3,3,1]
    - 进阶：你可以优化你的算法到 O(k) 空间复杂度吗？
  - ### 解题思路
    - 思路：动态规划；公式法(略)
    - 本题与118题的区别：118是生成所有，本体是生成最大行
    - 优化1:仅保留前一行即可，即二维List改为一维List
    - 优化2:倒着遍历可以节约空间，只定义一个List即可。否则需要定义一个pre的List，和一个cur的List
    - 非负索引k：不需要考虑0，直接从1开始算起
    - 算法：新建一维List；添加第0行元素1；循环：外层行数，内层倒着遍历并set()重置原有元素；返回一维List。
    - 注意：根据示例，3对应[1,3,3,1]，即从第0行开始算起；不同于118题，根据示例，是从第1行开始算起的。
    - 注意：重置用set(); 获取List已有元素用get() -- `cur.set(j, cur.get(j - 1) + cur.get(j));`
    
- ## 代码链接
  - [杨辉三角II](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0119-pascals-triangle-ii.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->  
 
  
  
# 121. 买卖股票的最佳时机
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
    - 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。
    - 注意你不能在买入股票前卖出股票。
  - ### 解题思路
    - 思路：暴力法；一次遍历；动态规划
    - 暴力法：
      - 复杂度：时间O(n^2)，空间O(1)
      - 注意设定：max初始化为0(至少为0)；
      - 思路：两次遍历
        - 外层控制开始位置，内层从开始位置依次向后，并不断更新减去外层的开始结点所得的最大值。
        - 最终返回max。
    - 一次遍历：
      - 关键：挨个对比，每次循环加入下一个元素到最值对比行列中
      - 复杂度：时间O(n)，空间O(1)
      - 思路：找到最小的谷之后的最大的峰
        - 维持两个变量：minprice 和 maxprofit
        - 它们分别对应迄今为止所得到的最小的谷值和最大的利润（卖出价格与最低价格之间的最大差值）。
        - 注意：差值应最小为0，因此初始化为0后进行遍历计算比较
      - 算法：
        - 判空：数组为空或长度<2时，return 0;
        - 定义两个最值：当前最小值min和最大差值max, 并初始化；
        - 遍历：从i=1开始，先小后大 
          - 每次更新min：当[i]值更小时，更新min
          - else：对比当前元素与min的差值与max，比较[i]-min与max的大小，并更新max；
            - 注意：else即当前元素更小，为min，则不可能与min(为0了)的差值更大
        - 返回max。
      - 注意：
        - min：初始化是第一个元素，循环中从第二个元素开始；
        - max：初始化应为0，而不是[1]-[0], 防止出现负数
        - 当没有判空时：初始化要用到Integer的最值 
          - 即：`int min = Integer.MAX_VALUE;`
    - 动态规划
      - 大佬的思路，总体类似“一次遍历”中的解法

- ## 代码链接
  - [买卖股票的最佳时机](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0121-best-time-to-buy-and-sell-stock.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->  
  


# 153. 寻找旋转排序数组中的最小值
- ## 简述：（[medium2](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium2.md)）
  - ### 题目描述
    - 假设按照升序排序的数组在预先未知的某个点上进行了旋转。
      - 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2])。
    - 请找出其中最小的元素。
    - 你可以假设数组中不存在重复元素。
    - 示例 1: 输入: [3,4,5,1,2], 输出: 1
    - 示例 2: 输入: [4,5,6,7,0,1,2], 输出: 0
  - ### 解题思路
    - 思路：暴力法；排序；二分。
    - 注：
      - 本题与<154-hard>的区别：本题规定不存在重复元素，154题可能存在重复元素。
      - 本题java解法貌似不需要判空，毕竟如果空，也不知道返回什么来表示。抛出异常？
    - ### 暴力法：
      - 复杂度：时间O(n)，空间O(1)
      - 算法：定义最小值；遍历数组并更新最小值；返回最小值。
    - ### 排序：
      - 复杂度：时间O(nlogn)，空间O(1)
      - 算法：Arrays.sort()排序；返回索引为0的元素。
      - 注：这种方法代码两行，但是时间复杂度高于暴力法。
    - ### 二分：
      - 复杂度：时间O(logn)，空间O(1)
      - 利用好“升序数组”这一特性，使用类似二分查找的方法，用双指针遍历数组
        - 注：因为不存在重复元素，因此不要考虑某两个元素相等的情况。
      - 算法：
        - 定义双指针；
        - 左右指针不相等时遍历数组：取mid，比较mid对应元素与right对应元素，mid大则left=mid+1，mid小则right=mid；
        - 返回left对应元素(right也行，因为最后两个指针相等了)。
    
- ## 代码链接：
  - [寻找旋转排序数组中的最小值](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0153-find-minimum-in-rotated-sorted-array.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 154. 寻找旋转排序数组中的最小值II
- ## 简述：（[hard](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/hard.md)）
  - ### 题目描述
    - 假设按照升序排序的数组在预先未知的某个点上进行了旋转。
      - 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2]。
    - 请找出其中最小的元素。
    - 注意数组中可能存在重复的元素。
    - 示例 1：输入: [1,3,5], 输出: 1;
    - 示例 2：输入: [2,2,2,0,1], 输出: 0
    - 说明：这道题是 寻找旋转排序数组中的最小值 的延伸题目。允许重复会影响算法的时间复杂度吗？会如何影响，为什么？
  - ### 解题思路
    - 思路：暴力法；排序；二分。
    - 注：
      - 本题与<153-medium>的区别：本题规定可能存在重复元素，153题规定不存在重复元素。
      - 153题与本题：暴力法和排序没有区别，二分需要在判断时注意处理重复元素。
      - 本题java解法貌似不需要判空，毕竟如果空，也不知道返回什么来表示。抛出异常？
    - ### 暴力法：
      - 复杂度：时间O(n)，空间O(1)
      - 算法：定义最小值；遍历数组并更新最小值；返回最小值。
    - ### 排序：
      - 复杂度：时间O(nlogn)，空间O(1)
      - 算法：Arrays.sort()排序；返回索引为0的元素。
      - 注：这种方法代码两行，但是时间复杂度高于暴力法。
    - ### 二分：
      - 复杂度：时间O(logn)，空间O(1)
      - 利用好“升序数组”这一特性，使用类似二分查找的方法，用双指针遍历数组
        - 注：因为可能存在重复元素，因此需要考虑某两个元素相等的情况。
      - 注意：比较的是mid与right，如果用left指针，可能出问题。
      - 算法：
        - 定义双指针；
        - 左右指针不相等时遍历数组：取mid，比较mid对应元素与right对应元素，mid大则left=mid+1，mid小则right=mid；
          - 注意：如果mid与right对应元素相等，则right--；（分类讨论各种情况可以验证抛弃right后min仍然在left到right范围内）。
        - 返回left对应元素(right也行，因为最后两个指针相等了)。

- ## 代码链接：
  - [寻找旋转排序数组中的最小值II](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0154-find-minimum-in-rotated-sorted-array-ii.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 167. 两数之和II-输入有序数组
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个 已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。
    - 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。
    - 说明:
      - 返回的下标值（index1 和 index2）不是从零开始的。
      - 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
  - ### 解题思路
    - 分析：与1题的区别：数组是有序的。
      - 注：1题的解题思路包括暴力法；哈希表（两次哈希表；一次哈希表）
    - 思路：双指针与二分查找的结合
    - 使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。
      - 如果两个指针指向元素的和 sum==target，那么得到要求的结果；
      - 如果 sum>target，移动较大的元素，使 sum 变小一些；
      - 如果 sum<target，移动较小的元素，使 sum 变大一些。
    - 复杂度：时间O(N)，空间O(1)。
    - 算法：判空；定义两变量作为左右指针并初始化；循环直到(a<b)不再成立：比较sum与target并移动指针；最后返回null。
      - 循环条件(a<b)：题目要求index1必须小于index2
      - 找到时返回数组的索引值要+1：题目要求返回的下标值（index1 和 index2）不是从零开始的，是从1开始的。

- ## 代码链接:
  - [相交链表](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0167-two-sum-ii-input-array-is-sorted.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->  



# 169. 多数元素
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。
    - 你可以假设数组是非空的，并且给定的数组总是存在多数元素。
  - ### 解题思路
    - 思路：暴力法；哈希表法；排序；分治；投票..
    - 暴力法：
      - 复杂度：时间O(n^2)，空间O(1)
      - 暴力算法遍历整个数组，然后用另一重循环统计每个数字出现的次数。将出现次数比其他数字加起来出现次数还多的元素返回。
      - 算法：初始化n/2；双层循环：外层控制比较基准，内层统计与基准相同的个数，并在内层结束后与n/2比较；最后return任一int型，比如-1.
      - 不足：时间复杂度过高
    - 哈希表：
      - 复杂度：时间O(n)，空间O(n)
      - 使用哈希表来存储每个元素，然后用一个循环在线性时间内遍历 nums ，然后我们只需要返回有最大值的键。
      - 算法：
        - 新建哈希表；
        - 新建max值和次数的变量；
        - 遍历数组：第一次出现时count赋值为1，否则在哈希表中对应count基础上+1，每次判断count范围并更新max两个变量；
        - 返回max值。
      - HashMap知识点：
        - `getOrDefault(Object key, V defaultValue)` : 如果存在key返回对应的value，否则返回defaultValue
    - 排序：
      - 复杂度：时间O(nlogn)，空间O(1)
      - 如果所有数字被单调递增或者单调递减的顺序排了序，那么众数的下标为n/2
      - 算法：对数组排序；返回排序后的n/2索引对应的元素
    - 摩尔投票法：
      - 复杂度：时间O(n)，空间O(1)
      - 把众数记为 +1，把其他数记为 −1 ，将它们全部加起来，显然和大于 0 ，从结果本身我们可以看出众数比其他数多。
      - 算法：
        - 定义比较基准flag=nums[0]和计数器count=1；
        - 遍历数组：与基准相同+1，不同-1，且变为0时，更新基准为下一个索引对应的元素；
        - 返回最后计数器不为0的基准。
    
- ## 代码链接:
  - [多数元素](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0169-majority-element.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->  



# 189. 旋转数组
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。
    - 说明: 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题；要求使用空间复杂度为 O(1) 的 原地 算法。
  - ### 解题思路
    - 思路：暴力法；额外数组；环状替换；反转。
    - 暴力法：
      - 复杂度：时间O(n*k)，空间O(1) -- k是移动的位置数
      - 思路：
        - 不使用额外空间时，需要把被占用的位置的数字存起来，并且需要时时更新（不是数组），之后将变量与要存放的数字交换；
        - 用循环实现，每次移动一步，一共移动k次。因此两层循环：外层控制k，内层控制遍历整个数组。
        - 内层循环中进行交换操作：将之前存起来的元素放在此刻的位置，将此刻位置的元素存起来。
      - 算法：定义两个变量；两层循环：外层控制k，把末尾元素存起来，内层控制遍历数组，内层循环中进行交换。
    - 额外数组：
      - 复杂度：时间O(n)，空间O(n)
      - 分析：用一个额外的数组来将每个元素放到正确的位置上，原本数组里下标为 i 的把它放到 `(i+k)%数组长度` 的位置。然后把新的数组拷贝到原数组中。
      - `(i+k)%数组长度`: 
        - 未超过数组长度的，结果为i+k；
        - 整除取余的部分是针对i+k超过数组长度时，相当于(i+k)分为n倍数组长度再加余数，n倍铺满整个数组，余数即从头开始
      - 算法：定义辅助数组；一次遍历：以正确位置顺序将数据存入辅助数组；二次遍历：将辅助数组的数据按照位置移动到原数组。
    - 环状替换：
      - 复杂度：时间O(n)，空间O(1)
      - 分析: 
        - 直接把每一个数字放到它最后的位置，把被替换的数字保存在变量 temp 里面。
        - 然后，将被替换数字（temp）放到它正确的位置，并继续这个过程 n 次， n 是数组的长度。因为需要将数组里所有的元素都移动。
        - 特殊情况：如果 n%k==0，其中 k=k%n （因为如果 k 大于 n ，移动 k 次实际上相当于移动 k%n 次）。
        - 这种情况下，会在没有遍历所有数字的情况下回到出发数字。此时，从下一个数字开始再重复相同的过程。
      - 算法：
        - 对移动距离k进行处理（针对k>n的情况），并初始化计数器count；
        - 两层循环：外层为保证当n%k==0时，从下一个数字开始重复，实际是每个位置只走一次，时间复杂度仍然是n
        - 外层控制：环状的开始，从首位开始循环，start++，因为一共要移动n次，循环条件是计数器不再满足count<nums.length时结束；
        - 外层每次定义并维护两个指针：发射点cur和接收点next，并将start位置的元素存入临时变量pre，pre相当于弹道；
        - 内层循环：初始化next，交换pre与next位置的元素，并更新旧的接收点next为新的发射点cur，并且此时子弹已经进入弹道pre了，同时count++
        - 内层循环的循环条件：start!=cur，即当发射点又回到本次环状的起始位置start时，说明这一轮已经到头了，此时结束循环。
      - 注：本方法太烧脑了，毕竟代码是写给人类看的...
    - 反转：
      - 复杂度：时间O(n)，空间O(1)
      - 分析：首先将所有元素反转。然后反转前 k 个元素，再反转后面 n−k 个元素，就能得到想要的结果。
      - 注：本方法是基于`反转数组`的方法，是剑指offer中对旋转数组问题的解决思路。
      - 算法：定义反转函数reverse；本体函数中，先对k进行取余处理；然后反转整个数组；然后反转前k个；最后反转剩余数组。
      - 反转数组：双指针，一头一尾，交换头尾，然后更新两个指针使其向中间靠。当left指针不再小于right指针时，停止循环。  

- ## 代码链接:
  - [旋转数组](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0189-rotate-array.java) 
  
<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->  



# 509. 斐波那契数
- ## 简述：（[easy3](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy3.md)）
  - ### 题目描述
    - 斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
    - F(0) = 0,   F(1) = 1,   F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
    - 给定 N，计算 F(N)。
    - 示例 1：输入：2, 输出：1, 解释：F(2) = F(1) + F(0) = 1 + 0 = 1.
    - 示例 2：输入：3, 输出：2, 解释：F(3) = F(2) + F(1) = 1 + 1 = 2.
    - 示例 3：输入：4, 输出：3, 解释：F(4) = F(3) + F(2) = 2 + 1 = 3.
    - 提示: 0 ≤ N ≤ 30
  - ### 解题思路
    - 思路：递归
    - 本题类似 <70题-爬楼梯>
    - 注意点：爬楼梯与斐波那契数的前几项不同，注意边界值判断
      - 爬楼梯：1，1，2，... f(0)=1, f(1)=1, f(2)= 2,..
      - 斐波那契数列：0，1，1，2，... f(0)=0, f(1)=1, f(2)=1, f(3)=2,...

- ## 代码链接：
  - [斐波那契数](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0509-fibonacci-number.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 914. 卡牌分组
- ## 简述：（[easy5](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy5.md)）
  - ### 题目描述
    - 给定一副牌，每张牌上都写着一个整数。
    - 此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：
      - 每组都有 X 张牌。
      - 组内所有的牌上都写着相同的整数。
      - 仅当你可选的 X >= 2 时返回 true。
    - 示例 1：
      - 输入：[1,2,3,4,4,3,2,1]，输出：true
      - 解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]
    - 示例 2：
      - 输入：[1,1,1,2,2,2,3,3]，输出：false
      - 解释：没有满足要求的分组。
    - 示例 3：
      - 输入：[1]，输出：false
      - 解释：没有满足要求的分组。
    - 示例 4：
      - 输入：[1,1]，输出：true
      - 解释：可行的分组是 [1,1]
    - 示例 5：
      - 输入：[1,1,2,2,2,2]，输出：true
      - 解释：可行的分组是 [1,1]，[2,2]，[2,2]
    - 提示：1 <= deck.length <= 10000，0 <= deck[i] < 10000
  - ### 解题思路
    - 思路：暴力法；最大公约数法。
      - 注：最大公约数法参考<leetcode-1071-字符串的最大公因子-easy>
    - 暴力法：
      - 复杂度：时间O(n^2)，空间O(n)
      - 分析：
        - 从 2 开始，从小到大枚举 X。
        - 由于每一组都有 X 张牌，那么 X 必须是卡牌总数 N 的约数。
        - 其次，对于写着数字 i 的牌，如果有 count i  张，那么 X 也必须是 count i 的约数，即：`count i modX==0`
        - 所以对于每一个 X，先判断 X 是否为 N 的约数，然后遍历所有牌中存在的数字 i，看它们对应牌的数量 count i  是否满足上述要求。
        - 如果都满足等式，则 X 为符合条件的解，否则需要继续令 X 增大，枚举下一个数字。
      - 算法：
        - 第一步：计数。
        - 定义数组长度N：即卡牌总数；
        - 模拟哈希表统计每个数字的出现次数：定义长10000的数组count，然后遍历数组deck并将元素值作为count数组索引值并自增1；
        - 第二步：统计数字个数。
        - 定义数组列表values，遍历count数组，并将count数组中所有大于0的元素添加到values数组列表；或依然用普通数组存储即可；
        - 第三步：遍历并判断。
        - 两层循环：外循环控制从2开始枚举的X(包括等于N)，内循环控制两个指标的取余，不符合时继续增加枚举，均符合时返回true，枚举到卡牌数N结束。
        - 注意：这里为了内循环控制外循环，给外循环做了标记，即for()前面的search表示外循环。
    - 最大公约数法：
      - 复杂度：时间O(NlogC)，空间O(N)
      - 分析：
        - 每种数字的卡牌张数必须是X的倍数（只有这样才能每X张牌分为1组，且每组牌的数字都相同), 且X>1。
        - 由此，本题转换成了求: 每种卡牌张数的最大公约数。
        - 只要求出所有 count i 最大公约数 g，判断 g 是否大于等于 2 即可，如果大于等于 2，则满足条件，否则不满足。
        - 最大公约数：辗转相除法，将除数和余数作为参数递归，直到余数为0时返回除数的值即为所求。
      - 算法：
        - 定义求最大公约数gcd的函数：将除数和余数作为新参数传入，并递归，直到余数为0，这时返回除数。
        - 首先定义计数数组，遍历原数组并求出每个数字出现的次数，并存入计数数组中；
        - 定义公约数变量g：
          - 注意：初始化为-1，并且在计数数组元素大于0时赋值，是为了绕过0，避免所有公约数都被计算为0，又保证了获取的是计数数组中的元素。
        - 遍历计数数组，并计算大于0的元素与公约数g的最大公约数；
        - 最后，判断g是否大于等于2，符合则返回true，否则返回false。
      
- ## 代码链接：
  - [卡牌分组](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0914-x-of-a-kind-in-a-deck-of-cards.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 1013. 将数组分成和相等的三个部分
- ## 简述：（[easy6](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy6.md)）
  - ### 题目描述
    - 给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。
    - 形式上，如果可以找出索引 i+1 < j 且满足 (A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1]) 就可以将数组三等分。
    - 示例 1：
      - 输入：[0,2,1,-6,6,-7,9,1,2,0,1], 输出：true
      - 解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1
    - 示例 2：
      - 输入：[0,2,1,-6,6,7,9,-1,2,0,1], 输出：false
    - 示例 3：
      - 输入：[3,3,6,5,-2,2,5,1,-9,4], 输出：true
      - 解释：3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4
    - 提示：3 <= A.length <= 50000, -10^4 <= A[i] <= 10^4
  - ### 解题思路
    - 思路：寻找切分点
    - 复杂度：时间O(n)，空间O(1)
    - 分析：
      - 首选算A的累加和能否被3整除，不可以那分不了3等分。
      - 遍历并累加，当达到第一个三分之一结点时，即为i（贪心），当达到第一个三分之二结点时，即为j。
      - 注：返回值是布尔型，即只要得到是否存在即可，不需要找出i和j的值。
      - 其他思路：双指针前后向中间逼近，不用考虑中间那段怎么分，只要左右两段累加和等于3等分的数值，中间剩的那段也就找到了。
    - 算法：
      - 遍历数组并求和sum，然后计算sum是否可以被3整除，不能则false，否则继续以下步骤；
      - 将sum更新为sum整除3的结果作为sum累加的target；
      - 定义当前和curSum，以及计数器count；
      - 循环：到`i<length-1`是精髓
        - 累加到curSum；
        - 判断：当curSum等于sum时，计数器+1，并将curSum置0，紧接着判断计数器是否为2，为2即可返回true；
      - 否则，循环结束后还没有return时，证明找不到，返回false。
      - 注：因为题目规定了数组长度取值范围，因此没有判空。
    - 注意测试用例`[1,-1,1,-1]`，因此循环时需要保证最后一个数组非空，即循环时，到`i<length-1`。
  
- ## 代码链接：
  - [将数组分成和相等的三个部分](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/1013-partition-array-into-three-parts-with-equal-sum.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->




### END
