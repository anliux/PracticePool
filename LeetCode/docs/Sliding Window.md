# 滑动窗口
- 内含题目：24

# 目录
<!-- GFM-TOC -->
* [3. 无重复字符的最长子串](#3-无重复字符的最长子串)
* [](#)
* [239. 滑动窗口最大值](#239-滑动窗口最大值)
* [](#)
* [](#)
* [](#)
<!-- GFM-TOC -->



# 3. 无重复字符的最长子串
- ## 简述：（[medium](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium.md)）
  - ### 题目描述
    - 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
    - 请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
  - ### 解题思路
      - 思路：暴力法；滑动窗口。
    - 暴力法：
      - 复杂度：O(n^3)，O(min(m,n)) -- 字符串 n 的大小以及字符集/字母 m 的大小。
      - 分析：
        - 假设有一个函数 boolean allUnique(String substring) ，如果子字符串中的字符都是唯一的，它会返回 true，否则会返回 false。
        - 遍历给定字符串 s 的所有可能的子字符串并调用函数 allUnique。 如果事实证明返回值为 true，那么将会更新无重复字符子串的最大长度的答案。
        - 为了枚举给定字符串的所有子字符串，需要枚举它们开始和结束的索引。假设开始和结束的索引分别为 i 和 j。那么有 0≤i<j≤n（这里的结束索引 j 是按惯例排除的）。因此，使用 i 从 0 到 n−1 以及 j 从 i+1 到 n 这两个嵌套的循环，我们可以枚举出 s 的所有子字符串。
        - 要检查一个字符串是否有重复字符，使用集合。
        - 遍历字符串中的所有字符，并将它们逐个放入 set 中。在放置一个字符之前，检查该集合是否已经包含它。如果包含，返回 false。循环结束后，返回 true。
      - 算法：
        - 定义判断左闭右开区间内是否符合各个字符唯一的函数allUnique；
        - 主函数内定义结果变量res并初始化为0；
        - 两层循环：外循环定义起始基准，内循环定义基准起到末尾的所有子串，并调用allUnique函数判断，为真时与res比较并将res更新为其中的最大值；
        - 返回res。
    - 滑动窗口
      - 复杂度：O(n)，O(min(m,n)) -- 字符串 n 的大小以及字符集/字母 m 的大小。
      - 滑动窗口是数组/字符串问题中常用的抽象概念。 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 i到j（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 i-j左闭右开 向右滑动 1 个元素，则它将变为 i+1到j+1（左闭，右开）。
      - 分析：
        - 使用 HashSet 将字符存储在当前窗口  i到j 左闭右开（最初 j=i）中。 然后我们向右侧滑动索引 j，如果它不在 HashSet 中，我们会继续滑动 j。直到 s[j] 已经存在于 HashSet 中。此时，我们找到的没有重复字符的最长子字符串将会以索引 i 开头。如果我们对所有的 i 这样做，就可以得到答案。
        - 优化：使用哈希map，如果 s[j] 在 i到j左闭右开 范围内有与 j' 重复的字符，我们不需要逐渐增加 i ，直接跳过 [i，j′] 范围内的所有元素，并将 i 变为 j′+1。
        - HashMap：记录char的位置+1，便于窗口start位置的滑动
      - 算法：
        - 定义一个 map 存储 (k, v)，其中 key 值为字符，value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复
        - 定义不重复子串的开始位置为 start，结束位置为 end
        - 随着 end 不断遍历向后，会遇到与 [start, end] 区间内字符相同的情况，此时将字符作为 key 值，获取其 value 值，并更新 start，此时 [start, end] 区间内不存在重复字符
        - 无论是否更新 start，都会更新其 map 数据结构和结果 ans。

- ## 代码链接：
  - [无重复字符的最长子串](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0003-longest-substring-without-repeating-characters.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->





# 239. 滑动窗口最大值
- ## 简述：（[hard2](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/hard2.md)）
  - ### 题目描述
    - 给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
    - 返回滑动窗口中的最大值。
    - 示例: 输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3, 输出: [3,3,5,5,6,7] 
    - 提示：你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。
    - 进阶：你能在线性时间复杂度内解决此题吗？
  - ### 解题思路
    - 思路：暴力法；双向队列；动态规划
    - ### 暴力法：
      - 复杂度：时间O(nk)，空间O(n-k+1)，n是数组元素个数
      - 遍历每个滑动窗口，找到每个窗口的最大值。
      - 一共有 N - k + 1 个滑动窗口，每个有 k 个元素，于是算法的时间复杂度为 O(Nk)，表现较差。
      - 算法：
        - 定义数组元素个数n
        - 判空：`n*k==0`，意味着n和k中存在0，此时，新建长度为0的数组并返回
          - 注：测试用例`输入：[] 0; 输出：[]`，因此判空不能返回null，需要返回新建长度为0的数组
        - 定义结果数组output，数组长度为滑动窗口个数 `n-k+1`
        - 两层循环：外层控制起始，内层控制小窗口内的遍历
          - 定义最大值max，遍历本窗口内的所有数字并更新max，然后将max作为output[i]存入结果数组
        - 返回结果数组
    - ### 双向队列
      - 复杂度：时间O(n)，空间O(n)
      - 存储双向队列的索引，以优化时间复杂度
        - 队首存储每个窗口的最大值，队尾存储可能成为最大值的其他元素（当最大值滑出后）
      - 先遍历第一个窗口，找出最大值；然后从第二个窗口开始遍历，以每个窗口最右端为基准，遍历至最后一个元素
      - 清理双向队列:
        - 只保留当前滑动窗口中有的元素的索引。
        - 移除比当前元素小的所有元素，它们不可能是最大的。
      - 算法：
        - 定义数组元素个数n；
        - 判空：`n*k==0`；
        - 边界值：`k=1`时返回原数组；
        - 新建数组双端队列deq：`ArrayDeque<Integer> deq = new ArrayDeque<Integer>();`；
        - 定义窗口最大值对应的索引max_index；
        - 首先：遍历第一个窗口，清理队首队尾，将元素添加到队列last，并找出最大值；
        - 定义输出数组output，并将第一个元素初始化为max_index对应的元素；
        - 其次：以每个窗口的最右端为基准，从第二个窗口开始，遍历至数组末尾最后一个元素
          - 首先清理队首first：判断 -- 当队列不为空，且队首等于本窗口最左侧的左侧元素时，移除首位（i-k是已经滑出本窗口的最近索引）；
          - 其次清理队尾last：循环（可能存在多个不符的队尾元素） -- 当队列不为空，且当前元素大于队尾时，移除队尾元素；
            - 这里：如果i索引值大于已有队尾，会在这一步移除，因此，下一步直接添加到队尾即可，包含了两种情况
          - 将当前元素的索引添加到队列（作为在最大值滑出窗口后，可能成为最大值的元素，放入队尾）
          - 最后将队首索引值对应的数组元素赋值给第i个元素
        - 返回结果数组output
        - 注：
          - 存入队列的是索引值，不是数组元素值；
          - 赋值给结果数组output的是队首索引值对应的数组元素，不是直接将队首元素存入结果数组；
          - 清理队首队尾重复代码，可以封装到一个函数中，这里就全写在同一个函数中了；
      
- ## 代码链接：
  - [滑动窗口最大值](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0239-sliding-window-maximum.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->






### END
