# 链表
- 内含题目：37

# 目录
<!-- GFM-TOC -->
* [2. 两数相加](#2-两数相加)
* []()
* []()
* []()
* [21. 合并两个有序链表](#21-合并两个有序链表)
* [83. 删除排序链表中的重复元素](#83-删除排序链表中的重复元素)
* [141. 环形链表](#141-环形链表)
* [160. 相交链表](#160-相交链表)
* []()
* [206. 反转链表](#206-反转链表)
<!-- GFM-TOC -->



# 2. 两数相加
- ## 简述：（[medium](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium.md)）
  - ### 题目描述
    - 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。
    - 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
    - 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
    - 示例：输入：(2 -> 4 -> 3) + (5 -> 6 -> 4), 输出：7 -> 0 -> 8, 原因：342 + 465 = 807
  - ### 解题思路
    - 思路：模拟初等数学的加法运算
    - 分析：
      - 非空链表按照逆序，同初等数学加法计算从低位到高位，根据示例，结果也是逆序，最后不用反转；
      - 进位：两个数字相加（考虑到进位）可能出现的最大和为 9+9+1=19 ，使用变量carry来跟踪进位，并将carry带入下一次迭代；
      - 结果返回一个额外的链表，因此定义一个链表res来存储每一位，最后返回res.next
      - 边界情况：两链表长度不同；一链表为空；两链表最后一位仍然有进位..等等。
    - 算法：
      - 定义res链表结点并初始化，定义三个结点p，q，cur追踪两链表的移动和res链表的当前位置，定义进位carry
      - 循环直到两链表均为空:
        - 定义变量存储当前结点对应的值val，存储前需要判断当前结点是否为null，为空时返回0，可以用三目运算符；
        - 定义sum和将上述变量和进位carry的和，并整除计算进位carry；
        - 将整除取余结果存入新建结点并赋值给cur.next，然后将cur向后移动；
        - 判断p，q结点是否为空，不为空时p，q结点向后移动。
      - 循环结束后，判断最高位是否仍有进位，即carry是否大于0
      - 返回res.next链表
    - 链表知识点：
      - 新建链表结点：`ListNode dummyHead = new ListNode(0);`
    
- ## 代码链接：
  - [两数相加](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0002-add-two-numbers.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 21. 合并两个有序链表
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 将两个有序链表合并为一个新的有序链表并返回。
    - 新链表是通过 拼接 给定的两个链表的所有节点组成的。  
  - ### 解题思路
    -  思路：递归；迭代
    - 递归：
      - 边界：当任一链表为null时，直接返回剩余链表（即返回非空链表）
        - 注：这里包括当两链表都是null的情况，因为仍然会返回其一。
      - 比较：将两个链表中头部较小的一个，与剩下元素的 merge 操作结果合并，最终返回此链表
        - 当list1[0]<list2[0]时：list1[0] + merge(list1[1:], list2)，并返回list1
        - 否则（包含等于情况）：list2[0] + merge( list1l, list2[1:])，并返回list2
    - 迭代
      - 顺序迭代的思路
      - 设定一个哨兵节点 "prehead" （以便在最后比较容易地返回合并后的链表）
      - 维护一个 prev 指针，并调整它的 next 指针
      - 重复以下过程，直到 l1 或者 l2 指向了 null ：
        - 如果 l1 当前位置的值小于等于 l2 ，把 l1 的值接在 prev 节点的后面，同时将 l1 指针往后移一个。
        - 否则，对 l2 做同样的操作。
        - 不管将哪一个元素接在了后面，都把 prev 向后移一个元素。
      - 最后加一步对于空链表的分析，并返回prehead

- ## 代码链接：
  - [合并两个有序链表](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0021-merge-two-sorted-lists.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 83. 删除排序链表中的重复元素
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。
  - ### 解题思路
    - 思路：简单链表操作
    - 因为是已排序链表，因此只需比较next值，相同则更新next，不同则更新current
      - 相同时next指向next的next，不同时移动当前结点current到它的next
    - 注意是head，不是current，current相当于for循环中的int i

- ## 代码链接：
  - [删除排序链表中的重复元素](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0083-remove-duplicates-from-sorted-list.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 141. 环形链表
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个链表，判断链表中是否有环。
    - 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。
  - ### 解题思路
    - 思路：哈希表；双指针
    - 哈希表：
      - 复杂度：时间O(n)，空间O(n)
      - 思路：可以通过检查一个结点此前是否被访问过来判断链表是否为环形链表。常用的方法是使用哈希表。
      - 分析：遍历所有结点并在哈希表中存储每个结点的引用（或内存地址）。
        - 如果当前结点为空结点 null（即已检测到链表尾部的下一个结点），那么我们已经遍历完整个链表，并且该链表不是环形链表。
        - 如果当前结点的引用已经存在于哈希表中，那么返回 true（即该链表为环形链表）。
      - 注：哈希表有hashmap和hashset两种，hashmap存储键值对，而hashset存储对象。本题仅需要存储各个结点，因此选择hashset
      - 算法：新建hashset；遍历链表直到next为null(即达到尾结点)：验证，已存在则返回true，否则更新到下一结点；遍历结束后仍没有返回时，返回false。
    - 双指针：
      - 复杂度：时间O(n)，空间O(1)
      - 思路：通过使用具有 ‘不同速度’ 的快、慢两个指针遍历链表，空间复杂度可以被降低至 O(1)。慢指针每次移动一步，而快指针每次移动两步。
        - 如果列表中不存在环，最终快指针将会最先到达尾部，此时我们可以返回 false。
        - 否则，快慢指针最终会相遇
      - 算法：判空；新建快慢指针；循环直到两指针相等：循环中若出现任一指针为null，则返回false；循环结束后返回true
        - 注：循环条件为相等，而不是判空；反过来也可以，只是看起来代码不够优雅了。
        - 注：判空时判断当前结点和next是为了避免下面操作的空指针异常，不单单是为了判断循环结束。注意循环中的判空条件是fast和fast.next，因为快指针在前，如果快指针没问题，那么慢指针也没问题。

- ## 代码链接:
  - [环形链表](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0141-linked-list-cycle.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 160. 相交链表
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 编写一个程序，找到两个单链表相交的起始节点。
    - 注意：
      - 如果两个链表没有交点，返回 null.
      - 在返回结果后，两个链表仍须保持原有的结构。
      - 可假定整个链表结构中没有循环。
      - 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。
  - ### 解题思路
    - 思路：暴力法；哈希表法；双指针法
    - 方法一: 暴力法
      - 对链表A中的每一个结点 ai ，遍历整个链表 B 并检查链表 B 中是否存在结点和 ai 相同。
      - 复杂度分析：时间复杂度 : (mn)。空间复杂度 : O(1)。
    - 方法二: 哈希表法 
      - 遍历链表 A 并将每个结点的地址/引用存储在哈希表中。然后检查链表 B 中的每一个结点 bi 是否在哈希表中。若在，则 bi 为相交结点。
      - 复杂度分析：时间复杂度 : O(m+n)。空间复杂度 : O(m) 或 O(n)。
    - 方法三：双指针法 
      - 复杂度：时间O(m+n)，空间O(1)。
      - 思路：链表A：a+c, 链表B : b+c. a+c+b+c = b+c+a+c 。则会在第二个c起点相遇。若不相交，a+b = b+a 。因此相遇处是NULL（尾）
      - 算法：判空；新建结点；循环：两结点移动，直到相等。
      - 注：没有公共时，最后都指向null，此时相等，退出循环。因此不会死循环。
      - 代码使用了三目运算符，很巧妙。

- ## 代码链接:
  - [相交链表](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0160-intersection-of-two-linked-lists.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 206. 反转链表
- ## 简述：（[easy2](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy2.md)）
  - ### 题目描述
    - 反转一个单链表。
    - 示例: 输入: 1->2->3->4->5->NULL，输出: 5->4->3->2->1->NULL
    - 进阶: 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？
  - ### 解题思路
    - 思路：迭代；递归
      - 注：配合图示理解效果更佳。
      - 注意：链表要特别注意结点存储的顺序，防止把链子断了。
    - 迭代：
      - 复杂度：时间O(n)，空间O(1)
      - 分析：用双指针，实现每两个链表结点之间反转，以达到整体反转链表的目的。
        - 其实用到三个指针，因为在两个结点反转的时候，需要把cur存起来，防止丢失next信息使得链表断开。
      - 算法：
        - 定义双指针：当前指针cur指向当前结点，前指针pre指向当前结点的前一个结点；
        - 循环：当cur不指向null时遍历链表
          - 定义临时结点tmp，将cur的next结点信息存在tmp中；
          - 将cur的下个结点指向pre，完成反转；
          - 将pre和cur往后移动一个结点：pre赋值为cur，cur赋值为tmp（此时，pre与cur直接断开了，但是下个循环就会连起来）；
          - 注：循环到最后，cur会赋值为尾结点指向的null，这时pre是最后一个不为空的结点，并且和cur不连接，可以作为返回值。
        - 返回结果pre。
      - 注：本方法自带判空，也可以处理单个结点的链表。
    - 递归：
      - 复杂度：时间O(n)，空间O(n)
      - 分析：
        - 递归的两个条件：
          - 终止条件是当前节点或者下一个节点==null
          - 在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 递归函数那句：`head.next.next = head;`
          - 不好理解，其实就是 head 的下一个节点指向head：相当于head与head.next和head形成了一个环。
        - 递归函数中每次返回的 cur 其实只最后一个节点，在递归函数内部，改变的是当前节点的指向。
      - 算法：
        - 判空：当head为空，或者仅有一个结点时，返回head本身；
        - 递归：结点cur赋值为head.next的反转链表结果，这句会一直dfs到末尾，然后开始返回；
          - 把head看做一个结点，把剩余结点并且已经调用过反转函数的返回值看做cur。
        - 形成环：将head.next的下一个结点赋值为head，即将head.next连接到head；
        - 切断head与head.next的连接；
        - 最后返回cur：cur是尾结点。

- ## 代码链接：
  - [反转链表](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0206-reverse-linked-list.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->




### END
