# 双指针
- 内含题目：60

# 目录
<!-- GFM-TOC -->
* [3. 无重复字符的最长子串](#3-无重复字符的最长子串)
* [26. 删除排序数组中的重复项](#26-删除排序数组中的重复项)
* [27. 移除元素](#27-移除元素)
* [28. 实现strStr()](#28-实现strstr)
* [88. 合并两个有序数组](#88-合并两个有序数组)
* [125. 验证会文串](#125-验证回文串)
* [141. 环形链表](#141-环形链表)
* [167. 两数之和II-输入有序数组](#167-两数之和ii-输入有序数组)
* []()
<!-- GFM-TOC -->



# 3. 无重复字符的最长子串
- ## 简述：（[medium](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium.md)）
  - ### 题目描述
    - 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
    - 请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
  - ### 解题思路
      - 思路：暴力法；滑动窗口。
    - 暴力法：
      - 复杂度：O(n^3)，O(min(m,n)) -- 字符串 n 的大小以及字符集/字母 m 的大小。
      - 分析：
        - 假设有一个函数 boolean allUnique(String substring) ，如果子字符串中的字符都是唯一的，它会返回 true，否则会返回 false。
        - 遍历给定字符串 s 的所有可能的子字符串并调用函数 allUnique。 如果事实证明返回值为 true，那么将会更新无重复字符子串的最大长度的答案。
        - 为了枚举给定字符串的所有子字符串，需要枚举它们开始和结束的索引。假设开始和结束的索引分别为 i 和 j。那么有 0≤i<j≤n（这里的结束索引 j 是按惯例排除的）。因此，使用 i 从 0 到 n−1 以及 j 从 i+1 到 n 这两个嵌套的循环，我们可以枚举出 s 的所有子字符串。
        - 要检查一个字符串是否有重复字符，使用集合。
        - 遍历字符串中的所有字符，并将它们逐个放入 set 中。在放置一个字符之前，检查该集合是否已经包含它。如果包含，返回 false。循环结束后，返回 true。
      - 算法：
        - 定义判断左闭右开区间内是否符合各个字符唯一的函数allUnique；
        - 主函数内定义结果变量res并初始化为0；
        - 两层循环：外循环定义起始基准，内循环定义基准起到末尾的所有子串，并调用allUnique函数判断，为真时与res比较并将res更新为其中的最大值；
        - 返回res。
    - 滑动窗口
      - 复杂度：O(n)，O(min(m,n)) -- 字符串 n 的大小以及字符集/字母 m 的大小。
      - 滑动窗口是数组/字符串问题中常用的抽象概念。 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 i到j（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 i-j左闭右开 向右滑动 1 个元素，则它将变为 i+1到j+1（左闭，右开）。
      - 分析：
        - 使用 HashSet 将字符存储在当前窗口  i到j 左闭右开（最初 j=i）中。 然后我们向右侧滑动索引 j，如果它不在 HashSet 中，我们会继续滑动 j。直到 s[j] 已经存在于 HashSet 中。此时，我们找到的没有重复字符的最长子字符串将会以索引 i 开头。如果我们对所有的 i 这样做，就可以得到答案。
        - 优化：使用哈希map，如果 s[j] 在 i到j左闭右开 范围内有与 j' 重复的字符，我们不需要逐渐增加 i ，直接跳过 [i，j′] 范围内的所有元素，并将 i 变为 j′+1。
        - HashMap：记录char的位置+1，便于窗口start位置的滑动
      - 算法：
        - 定义一个 map 存储 (k, v)，其中 key 值为字符，value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复
        - 定义不重复子串的开始位置为 start，结束位置为 end
        - 随着 end 不断遍历向后，会遇到与 [start, end] 区间内字符相同的情况，此时将字符作为 key 值，获取其 value 值，并更新 start，此时 [start, end] 区间内不存在重复字符
        - 无论是否更新 start，都会更新其 map 数据结构和结果 ans。

- ## 代码链接：
  - [无重复字符的最长子串](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0003-longest-substring-without-repeating-characters.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->
- ## 简述：（[medium](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium.md)）
  - ### 题目描述
    - 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
    - 请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
  - ### 解题思路
      - 思路：暴力法；滑动窗口。
    - 暴力法：
      - 复杂度：O(n^3)，O(min(m,n)) -- 字符串 n 的大小以及字符集/字母 m 的大小。
      - 分析：
        - 假设有一个函数 boolean allUnique(String substring) ，如果子字符串中的字符都是唯一的，它会返回 true，否则会返回 false。
        - 遍历给定字符串 s 的所有可能的子字符串并调用函数 allUnique。 如果事实证明返回值为 true，那么将会更新无重复字符子串的最大长度的答案。
        - 为了枚举给定字符串的所有子字符串，需要枚举它们开始和结束的索引。假设开始和结束的索引分别为 i 和 j。那么有 0≤i<j≤n（这里的结束索引 j 是按惯例排除的）。因此，使用 i 从 0 到 n−1 以及 j 从 i+1 到 n 这两个嵌套的循环，我们可以枚举出 s 的所有子字符串。
        - 要检查一个字符串是否有重复字符，使用集合。
        - 遍历字符串中的所有字符，并将它们逐个放入 set 中。在放置一个字符之前，检查该集合是否已经包含它。如果包含，返回 false。循环结束后，返回 true。
      - 算法：
        - 定义判断左闭右开区间内是否符合各个字符唯一的函数allUnique；
        - 主函数内定义结果变量res并初始化为0；
        - 两层循环：外循环定义起始基准，内循环定义基准起到末尾的所有子串，并调用allUnique函数判断，为真时与res比较并将res更新为其中的最大值；
        - 返回res。
    - 滑动窗口
      - 复杂度：O(n)，O(min(m,n)) -- 字符串 n 的大小以及字符集/字母 m 的大小。
      - 滑动窗口是数组/字符串问题中常用的抽象概念。 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 i到j（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 i-j左闭右开 向右滑动 1 个元素，则它将变为 i+1到j+1（左闭，右开）。
      - 分析：
        - 使用 HashSet 将字符存储在当前窗口  i到j 左闭右开（最初 j=i）中。 然后我们向右侧滑动索引 j，如果它不在 HashSet 中，我们会继续滑动 j。直到 s[j] 已经存在于 HashSet 中。此时，我们找到的没有重复字符的最长子字符串将会以索引 i 开头。如果我们对所有的 i 这样做，就可以得到答案。
        - 优化：使用哈希map，如果 s[j] 在 i到j左闭右开 范围内有与 j' 重复的字符，我们不需要逐渐增加 i ，直接跳过 [i，j′] 范围内的所有元素，并将 i 变为 j′+1。
        - HashMap：记录char的位置+1，便于窗口start位置的滑动
      - 算法：
        - 定义一个 map 存储 (k, v)，其中 key 值为字符，value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复
        - 定义不重复子串的开始位置为 start，结束位置为 end
        - 随着 end 不断遍历向后，会遇到与 [start, end] 区间内字符相同的情况，此时将字符作为 key 值，获取其 value 值，并更新 start，此时 [start, end] 区间内不存在重复字符
        - 无论是否更新 start，都会更新其 map 数据结构和结果 ans。

- ## 代码链接：
  - [无重复字符的最长子串](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0003-longest-substring-without-repeating-characters.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 26. 删除排序数组中的重复项
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
    - 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
  - ### 解题思路
    - 双指针
    - 双指针具体操作：
      - 数组完成排序后，放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。
        - i，j是数组索引值
        - 注：j负责遍历整个数组（循环），i负责控制新数组的长度（返回值）
      - 只要 nums[i] = nums[j]，就增加 j 以跳过重复项（j是快指针）；
        - 仅j增加，没有其他操作，可作为循环体中if判断的不成立情况，这时，每次循环仅j自增
      - 当 nums[j] != nums[i] 时，跳过重复项的运行已经结束；
        - 这种情况下，有后续操作，可作为循环体中if判断成立的情况，并把后续操作放在if语句中
      - 把 nums[j] 的值复制到 nums[i + 1]；
      - 然后递增 i，再次重复相同的过程，直到 j 到达数组的末尾为止。
      - 遍历结束后返回慢指针 i+1
    
- ## 代码链接：
  - [删除排序数组中的重复项](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0026-remove-duplicates-from-sorted-array.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 27. 移除元素
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个数组 nums 和一个值 val，原地移除所有数值等于 val 的元素，返回移除后数组的新长度。
    - 不要使用额外的数组空间，必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
    - 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
  - ### 解题思路
    - 双指针（分为常规双指针和不需要移动）
    - 双指针具体操作：
      - 保留两个指针 i 和 j，其中 i 是慢指针，j 是快指针。
      - 当 nums[j] 与给定的值相等时，递增 j 以跳过该元素。
      - 只要 nums[j] != val，就复制 nums[j] 到 nums[i] ，并同时递增两个索引。
      - 重复这一过程，直到 j 到达数组的末尾，该数组的新长度为 i。
    - 当要删除元素很少时的双指针：
      - 注：这里的双指针不是快慢指针，是首尾指针，一前一后逼近
      - 若val只占1或2个，且在首、尾等位置时，为了避免不必要的操作，对原来双指针方法进行改进
      - 当遇到 nums[i] = valnums[i]=val 时，可以将当前元素与最后一个元素进行交换，并释放最后一个元素。
        - 这实际上使数组的大小减少了 1。
      - 请注意，被交换的最后一个元素可能是想要移除的值。但是不要担心，在下一次迭代中，仍然会检查这个元素

- ## 代码链接：
  - [移除元素](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0027-remove-element.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 28. 实现strStr()
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
    - 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
  - ### 解题思路
    - 思路：暴力法（超时）；kmp（未尝试）；indexOf()（直接用内置函数）
    - 题目标签是"字符串"和"双指针"，题解是kmp算法，但因为是简单题所以好多人用indexOf()
    - 双指针暴力解决会超时
    - 尝试用indexOf()解决：（一行代码）

- ## 代码链接：
  - [实现strStr()](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0028-implement-strstr.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 88. 合并两个有序数组
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。
  - ### 解题思路
    - 思路：暴力法；双指针从前遍历；双指针从后遍历
    - 暴力法
      - 先复制数组2到数组1，后排序
      - 复杂度：时间O((m+n)log(m+n))，空间O(1)
    - 双指针从前往后：
      - 先把数组1存起来，然后选值存入数组1，最后如果仍有剩余，直接存入
      - 复杂度：时间O(n)，空间O(n)
    - 双指针从后往前：
      - 改进：优化了空间复杂度，不用另外存数组1
      - 复杂度：时间O(n)，空间O(1)
    - 注意
      - 数组是引用型数据变量，操作即改变本体，不需要return，结果保存在数组1中即可  
      - 本身不难，但要特别注意临界值
  
- ## 代码链接：
  - [合并两个有序数组](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0088-merge-sorted-array.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 125. 验证回文串
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
    - 说明：本题中，我们将空字符串定义为有效的回文串。
  - ### 解题思路
    - 思路：双指针
    - 复杂度：时间O(n)，空间O(1)
    - 分析：
      - 不区分大小写：先转为小写 `s = s.toLowerCase();`
      - 按顺序处理字符串的每个字符：字符串转为字符数组 `char[] chs = s.toCharArray();`
      - 不计除了字母和数字之外的字符：判断字符是否在字母或者数字的范围内，不在时直接略个这个字符
      - 最后如果没有出现不相等的情况，则返回true
    - 算法：转为小写；转为字符数组；双指针遍历：当遇到非数字和非字母的字符时指针指向下一个位置，之后判断两指针对应的字符是否相等；返回结果。

- ## 代码链接:
  - [验证回文串](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0125-valid-palindrome.java)
  
<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 141. 环形链表
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个链表，判断链表中是否有环。
    - 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。
  - ### 解题思路
    - 思路：哈希表；双指针
    - 哈希表：
      - 复杂度：时间O(n)，空间O(n)
      - 思路：可以通过检查一个结点此前是否被访问过来判断链表是否为环形链表。常用的方法是使用哈希表。
      - 分析：遍历所有结点并在哈希表中存储每个结点的引用（或内存地址）。
        - 如果当前结点为空结点 null（即已检测到链表尾部的下一个结点），那么我们已经遍历完整个链表，并且该链表不是环形链表。
        - 如果当前结点的引用已经存在于哈希表中，那么返回 true（即该链表为环形链表）。
      - 注：哈希表有hashmap和hashset两种，hashmap存储键值对，而hashset存储对象。本题仅需要存储各个结点，因此选择hashset
      - 算法：新建hashset；遍历链表直到next为null(即达到尾结点)：验证，已存在则返回true，否则更新到下一结点；遍历结束后仍没有返回时，返回false。
    - 双指针：
      - 复杂度：时间O(n)，空间O(1)
      - 思路：通过使用具有 ‘不同速度’ 的快、慢两个指针遍历链表，空间复杂度可以被降低至 O(1)。慢指针每次移动一步，而快指针每次移动两步。
        - 如果列表中不存在环，最终快指针将会最先到达尾部，此时我们可以返回 false。
        - 否则，快慢指针最终会相遇
      - 算法：判空；新建快慢指针；循环直到两指针相等：循环中若出现任一指针为null，则返回false；循环结束后返回true
        - 注：循环条件为相等，而不是判空；反过来也可以，只是看起来代码不够优雅了。
        - 注：判空时判断当前结点和next是为了避免下面操作的空指针异常，不单单是为了判断循环结束。注意循环中的判空条件是fast和fast.next，因为快指针在前，如果快指针没问题，那么慢指针也没问题。

- ## 代码链接:
  - [环形链表](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0141-linked-list-cycle.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 167. 两数之和II-输入有序数组
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个 已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。
    - 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。
    - 说明:
      - 返回的下标值（index1 和 index2）不是从零开始的。
      - 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
  - ### 解题思路
    - 分析：与1题的区别：数组是有序的。
      - 注：1题的解题思路包括暴力法；哈希表（两次哈希表；一次哈希表）
    - 思路：双指针与二分查找的结合
    - 使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。
      - 如果两个指针指向元素的和 sum==target，那么得到要求的结果；
      - 如果 sum>target，移动较大的元素，使 sum 变小一些；
      - 如果 sum<target，移动较小的元素，使 sum 变大一些。
    - 复杂度：时间O(N)，空间O(1)。
    - 算法：判空；定义两变量作为左右指针并初始化；循环直到(a<b)不再成立：比较sum与target并移动指针；最后返回null。
      - 循环条件(a<b)：题目要求index1必须小于index2
      - 找到时返回数组的索引值要+1：题目要求返回的下标值（index1 和 index2）不是从零开始的，是从1开始的。

- ## 代码链接:
  - [相交链表](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0167-two-sum-ii-input-array-is-sorted.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->  


### END 
