# 字符串
- 内含题目：157

# 目录
<!-- GFM-TOC -->
* [13. 罗马数字转整数](#13-罗马数字转整数)
* [14. 最长公共前缀](#14-最长公共前缀)
* [20. 有效的括号](#20-有效的括号)
* [28. 实现strStr()](#28-实现strstr)
* [38. 外观数列](#38-外观数列)
* [58. 最后一个单词的长度](#58-最后一个单词的长度)
* [67. 二进制求和](#67-二进制求和)
* []()
* []()
<!-- GFM-TOC -->



# 13. 罗马数字转整数
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 要求：给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。
    - 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M，分别对应1,5,10,50,100,500,1000
    - 规则：通常情况下，罗马数字中小的数字在大的数字的右边。否则，用右边的大数减去左边的小数
  - ### 解题思路
    - 多个字符对应不同的数字，考虑“查表法”，可用哈希表 或者 “switch”
    - 比较相邻两个字符，若高位不小于低位，直接相加；否则，要用低位的大数减去高位的小数。
    - 将每位对应的数字累加：可以从高位到低位，即从字符串的0到length-1

- ## 代码链接：
  - [罗马数字转整数](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0013-roman-to-integer.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 14. 最长公共前缀
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 编写一个函数来查找字符串数组中的最长公共前缀，如果不存在公共前缀，返回空字符串 ""。
    - 注意：是公共前缀，不是公共子序列
  - ### 解题思路
    - 水平扫描法，水平扫描，二分，分治，字典树
    - 水平扫描法：减法思想
      - 复杂度分析：时间复杂度低（战胜100%），空间复杂度高（战胜14%），相当于空间换时间了
      - 当字符串数组为空时，即长度为0时，即不存在公共前缀，返回空字符串""；
      - 以字符串数组中的第一个元素为基准，遍历整个数组，进行比较；
      - prefix保存当前最长公共前缀，如果prefix不是当前字符串的前缀，则删除最后一个字符再进行比较，一直到prefix变成当前字符串的前缀，或者变成空字符串
      - 注意是求公共前缀，不是最长公共子序列，因此可以从后面减，也是while判0的原因
    - 用到的字符串相关知识：
      - indexOf()
      - substring()
      - isEmpty()
      - 注意长度：字符串长度加小括号
      
- ## 代码链接：
  - [最长公共前缀](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0014-longest-common-prefix.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 20. 有效的括号
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。
  - ### 解题思路
    - 思路：暴力法；栈
    - 暴力法：
      - 每次检测是否有最里侧的成对某种括号，若有，则替换所有成对括号为空字符串，直到检测不到相邻的成对括号
      - 遍历完成后，如果是有效表达式，则最后的字符串会只剩下空串，判断是否==空串
    - 栈：
      - 初始化哈希表 char型
      - 初始化栈 char型
      - 遍历字符串，每次对遍历到的字符进行判断
        - 压栈：遇到开括号，将其推到栈上。
        - 弹栈：否则，当栈非空，且当前字符串的字符与栈顶元素配对成功时，弹栈
        - 无效：否则，表达式无效。
      - 最后，若栈非空，则表达式无效。
      
- ## 代码链接：
  - [有效的括号](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0020-valid-parentheses.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 28. 实现strStr()
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
    - 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
  - ### 解题思路
    - 思路：暴力法（超时）；kmp（未尝试）；indexOf()（直接用内置函数）
    - 题目标签是"字符串"和"双指针"，题解是kmp算法，但因为是简单题所以好多人用indexOf()
    - 双指针暴力解决会超时
    - 尝试用indexOf()解决：（一行代码）

- ## 代码链接：
  - [实现strStr()](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0028-implement-strstr.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 38. 外观数列
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 外观数列 是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：
      - `1, 11, 21, 1211, 111221, ...`
    -   - 给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。
    - 注意：整数序列中的每一项将表示为一个字符串。
  - ### 解题思路
    - 本题的本质是计数器，本题的关键是理清数字规律，并将数学规律转为代码
      - 本题输入是int型，返回值是String型
      - 首先自定义n=1时，s="1"; 
      - 当n=1时直接返回；当n>=2时，再进行后续的复杂操作
        - 注：题目要求"正整数 n（1 ≤ n ≤ 30）"，故不作其他判断，甚至能用穷举法存入字典查表解决...
      - 两层循环：外循环控制行数，内循环遍历上一行生成的字符串并“报数”
      - 外循环：2-n（包含等于n），从2开始，n=1的情况直接返回
      - 内循环：
        - 从s的[0]开始设置"flag"-pre，计数器count，循环从1开始向后遍历，数(动词)与pre相等的个数，直到不再相等
        - 不相等的时候，调整pre为不再相等的位置的数字，并将count归为1，重新开始计数
    - 注：本题标签是字符串，考虑用可变字符串StringBuilder，最后toString()转为String形式
    
- ## 代码链接：
  - [外观数列](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0038-count-and-say.java)
 
<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 58. 最后一个单词的长度
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个仅包含大小写字母和空格 ' ' 的字符串 s，返回其最后一个单词的长度。
    - 如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。
    - 英文：(last word means the last appearing word if we loop from left to right) in the string.
      - 由英文表述可知：是从左向右遍历字符串
    - 如果不存在最后一个单词，请返回 0 。
    - 说明：一个单词是指仅由字母组成、不包含任何空格的 最大子字符串
  - ### 解题思路
    - 标签字符串的简单题
    - 因为是从左向右遍历，因此可以从末尾开始，即从最右侧的非空格开始计数
      - 需要考虑最右侧的空格和不是空格的情况
    - 初始化count为0，从length-1开始往回遍历，从非空格开始计数，当开始计数以后，且再次遇到空格时停止计数并返回
    - 需要考虑多种临界：比如单个字母返回1
    
- ## 代码链接：
  - [最后一个单词的长度](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0058-length-of-last-word.java)
  
<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 67. 二进制求和
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定两个二进制字符串，返回他们的和（用二进制表示）。
    - 输入为非空字符串且只包含数字 1 和 0。
  - ### 解题思路
    - 思路：逐位计算（位运算的方法要考虑过多的细枝末节，这里不详述）
    - 补0使两字符串长度相等，然后从末尾开始遍历，并不断添加结果，最后对结果进行反转
      - 补0：在遍历过程中判断，长度小于0时直接返回0
      - 添加：需要在字符串上添加，因此使用可变字符串StrinBuilder
      - 反转：添加顺序是每次在右侧添加，即不断将较高位添加到右侧，因此最后需要反转
    - 定义可变字符串res，进位标志flag
    - 循环：从末尾开始，同时遍历两个字符串，并在两字符串均遍历至第一个元素时终止循环（双或）
    - 赋值sum=flag，并分别取a和b两字符串的最右位累加到sum
    - 用三目运算符在判断的同时得到sum的值，其中先判断i和j是否大于等于0为了补0，`a.charAt(i)-'0'`根据字符距离得到相应数值计算结果
    - 之后对所得sum值判断：取余得到添加结果，整除得到flag的值
    - 返回时需要对最后一次循环后flag的值进行判断，之后反转，并转为String型
    - 注：本代码好几处把几句代码合并到一句的
    
- ## 代码链接：
  - [二进制求和](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0067-add-binary.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



#


<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



#


<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



#


<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



#


<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



#


<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



#


<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



#


<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



### END
