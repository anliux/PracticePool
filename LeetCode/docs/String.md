# 字符串
- 内含题目：157

# 目录
<!-- GFM-TOC -->
* [3. 无重复字符的最长子串](#3-无重复字符的最长子串)
* [5. 最长回文子串](#5-最长回文子串)
* [6. Z字形变换](#6-z字形变换)
* [8. 字符串转换整数atoi](#8-字符串转换整数atoi)
* [12. 整数转罗马数字](#12-整数转罗马数字)
* [13. 罗马数字转整数](#13-罗马数字转整数)
* [14. 最长公共前缀](#14-最长公共前缀)
* [20. 有效的括号](#20-有效的括号)
* [28. 实现strStr()](#28-实现strstr)
* [38. 外观数列](#38-外观数列)
* [58. 最后一个单词的长度](#58-最后一个单词的长度)
* [67. 二进制求和](#67-二进制求和)
* [125. 验证回文串](#125-验证回文串)
* [1071. 字符串的最大公因子](#1071-字符串的最大公因子)
<!-- GFM-TOC -->



# 3. 无重复字符的最长子串
- ## 简述：（[medium](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium.md)）
  - ### 题目描述
    - 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
    - 请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
  - ### 解题思路
      - 思路：暴力法；滑动窗口。
    - 暴力法：
      - 复杂度：O(n^3)，O(min(m,n)) -- 字符串 n 的大小以及字符集/字母 m 的大小。
      - 分析：
        - 假设有一个函数 boolean allUnique(String substring) ，如果子字符串中的字符都是唯一的，它会返回 true，否则会返回 false。
        - 遍历给定字符串 s 的所有可能的子字符串并调用函数 allUnique。 如果事实证明返回值为 true，那么将会更新无重复字符子串的最大长度的答案。
        - 为了枚举给定字符串的所有子字符串，需要枚举它们开始和结束的索引。假设开始和结束的索引分别为 i 和 j。那么有 0≤i<j≤n（这里的结束索引 j 是按惯例排除的）。因此，使用 i 从 0 到 n−1 以及 j 从 i+1 到 n 这两个嵌套的循环，我们可以枚举出 s 的所有子字符串。
        - 要检查一个字符串是否有重复字符，使用集合。
        - 遍历字符串中的所有字符，并将它们逐个放入 set 中。在放置一个字符之前，检查该集合是否已经包含它。如果包含，返回 false。循环结束后，返回 true。
      - 算法：
        - 定义判断左闭右开区间内是否符合各个字符唯一的函数allUnique；
        - 主函数内定义结果变量res并初始化为0；
        - 两层循环：外循环定义起始基准，内循环定义基准起到末尾的所有子串，并调用allUnique函数判断，为真时与res比较并将res更新为其中的最大值；
        - 返回res。
    - 滑动窗口
      - 复杂度：O(n)，O(min(m,n)) -- 字符串 n 的大小以及字符集/字母 m 的大小。
      - 滑动窗口是数组/字符串问题中常用的抽象概念。 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 i到j（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 i-j左闭右开 向右滑动 1 个元素，则它将变为 i+1到j+1（左闭，右开）。
      - 分析：
        - 使用 HashSet 将字符存储在当前窗口  i到j 左闭右开（最初 j=i）中。 然后我们向右侧滑动索引 j，如果它不在 HashSet 中，我们会继续滑动 j。直到 s[j] 已经存在于 HashSet 中。此时，我们找到的没有重复字符的最长子字符串将会以索引 i 开头。如果我们对所有的 i 这样做，就可以得到答案。
        - 优化：使用哈希map，如果 s[j] 在 i到j左闭右开 范围内有与 j' 重复的字符，我们不需要逐渐增加 i ，直接跳过 [i，j′] 范围内的所有元素，并将 i 变为 j′+1。
        - HashMap：记录char的位置+1，便于窗口start位置的滑动
      - 算法：
        - 定义一个 map 存储 (k, v)，其中 key 值为字符，value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复
        - 定义不重复子串的开始位置为 start，结束位置为 end
        - 随着 end 不断遍历向后，会遇到与 [start, end] 区间内字符相同的情况，此时将字符作为 key 值，获取其 value 值，并更新 start，此时 [start, end] 区间内不存在重复字符
        - 无论是否更新 start，都会更新其 map 数据结构和结果 ans。

- ## 代码链接：
  - [无重复字符的最长子串](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0003-longest-substring-without-repeating-characters.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 5. 最长回文子串
- ## 简述：（[medium](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium.md)）
  - ### 题目描述
    - 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
  - ### 解题思路
    - ### 思路：暴力匹配；动态规划；中心扩散；Manacher 算法。
      - “暴力匹配”是基础，“动态规划”必须掌握，“中心扩散” 要会写，“Manacher 算法”不用看
    - ### 暴力匹配：
      - 复杂度：O(n^3)，O(1)
      - 分析：
        - 根据回文子串的定义，枚举所有长度大于等于 2 的子串，依次判断它们是否是回文；
        - 在具体实现时，可以只针对大于“当前得到的最长回文子串长度”的子串进行“回文验证”；
        - 在记录最长回文子串的时候，可以只记录“当前子串的起始位置”和“子串长度”，不必做截取。
        - 暴力解法时间复杂度高，但是思路清晰、编写简单，可以作为基础来优化实现其他方法。
      - 算法：
        - 定义valid函数，用于判断left到right范围内的子串是否是回文串；
        - 主体函数中：边界值判断，字符串长度为0和1的直接返回s，即s.length()<2时；
        - 定义几个变量：最长子串的长度lens，最长子串结果res。字符串s可以用s.substring()截取；
        - 循环：两层遍历，外层控制起始基准，内层控制从基准开始到末尾的所有子串，并if进行判断并更新相应的变量数值；
        - 最内层if判断：如果当前子串的长度大于最长子串长度lens，并且valid为真，则更新lens，并将最长子串res更新为当前子串；
        - 循环结束后返回res。
      - 字符串相关知识点：
        - `substring(int beginIndex, int endIndex)` ：索引值左闭右开，返回一个新字符串，它是此字符串的一个子字符串。
        - `charAt(int index)` ：返回指定索引处的 char 值。
        - 注：substring是截取子串，charAt是返回字符串中的某一个字符，注意使用场景，以及返回值所存储到的变量的数据类型。
    - ### 动态规划：
      - 复杂度：O(n^2)，O(n^2)
        - 虽然以时间换空间，但是仍然需要两层循环来遍历整个字符串。
      - “动态规划”作为一种打表格法，是在用“空间”换“时间”。
      - 动态规划思考路径：状态？状态转移方程？初始化？输出？状态压缩？
      - 本题关键：
        - 在头尾字符相等的情况下，里面子串的回文性质据定了整个子串的回文性质，这就是状态转移。
        - 因此可以把“状态”定义为原字符串的一个子串是否为回文子串。
        - dp[i][j] 表示子串 s[i, j] 是否为回文子串。
        - 状态转移方程：`dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]`
        - i 和 j 的关系是 i <= j ，因此，只需要填这张表的一半；
        - 边界条件是：表达式 [i+1, j-1] 不构成区间，即长度严格小于2，即 j-1-(i+1)+1<2，整理得 j-i<3。
          - 显然：当子串 s[i, j] 的长度等于2或者等于3的时候，只需要判断一下头尾两个字符是否相等就可以直接下结论了。
        - 找到时，仅记录
      - 算法：
        - 定义字符串长度lens，方便后面使用；判断边界条件：lens<2时
        - 定义布尔型二维数组`dp[][]`，（注：不需要初始化对角线为true，因为控制好i和j区间，对角线用不到，经测试可以ac）
        - 定义int遍历maxlens和start，并初始化start=0，maxlens=1，而不是0，因为回文串长至少是1，例如"ac"，返回"a"；
        - 两层循环遍历全部数组，因为遍历中会用到dp[i+1][j-1]，要注意遍历的顺序(不是常规那种)，否则遍历过程中会遇到dp[i+1][j-1]没有值的情况
          - 外循环：控制结尾j，内循环遍历从字符串索引0开始到结尾j的所有子串；（不是常规的外起始i，内从起始i到字符串末尾的方式）
        - 内循环体：两部分 - 首先，判断dp[i][j]的真假；其次，dp为真时更新记录最长子串信息的变量。
        - 最后截取子串并返回。
    - ### 中心扩散：
      - 复杂度：O(n^2)，O(1)
      - 中心扩散法的思路是：遍历每一个索引，以这个索引为中心，利用“回文串”中心对称的特点，往两边扩散，看最多能扩散多远。
      - 回文串在长度为奇数和偶数的时候，“回文中心”的形式是不一样的。
        - 奇数回文串的“中心”是一个具体的字符，例如：回文串 "aba" 的中心是字符 "b"；
        - 偶数回文串的“中心”是位于中间的两个字符的“空隙”，例如：回文串串 "abba" 的中心是两个 "b" 中间的那个“空隙”；
        - 综上，遍历中心位置时，要同时计算 (i,i) 和 (i,i+1)，因此，for循环到length-2为止。
      - 算法：
        - 定义一个函数centerSpread，返回以left和right为中心扩散时的回文串
          - while在left和right没有超过字符串s的首尾时循环；
          - 循环体：if判断，相等时移动指针，不等时跳出循环；
          - 跳出循环时，恰好满足 s.charAt(i) != s.charAt(j)，因此不能取i和j，而substring是左闭右开的，取(i+1,j)
        - 主体函数：
          - 边界值s.length()=0和1时为真，返回s；
          - 定义最长子串res及其长度maxLens，并初始化，注意长度最小为1；
          - for循环遍历中心位置i，直到i<s.length()-1，因为循环体中会调用奇数和偶数两种扩散方式，防止角标越界；
          - 循环体中首先，分别定义奇数串和偶数串，并调用函数计算(i,i)和(i,i+1)作为中心的扩散结果；
          - 循环体重其次：取奇数串和偶数串中最长的一个作为maxLensStr，并与res的长度maxLens比较，更长时更新res及maxLens；
          - 循环结束后返回res。
    - ### Manacher(马拉车)算法：
      - Manacher算法本质上还是中心扩散法，只不过它使用了类似 KMP 算法的技巧，充分挖掘了已经进行回文判定的子串的特点，在遍历的过程中，记录了已经遍历过的子串的信息，也是典型的以空间换时间思想的体现。

- ## 代码链接：
  - [最长回文子串](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0005-longest-palindromic-substring.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 6. Z字形变换
- ## 简述：（[medium](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium.md)）
  - ### 题目描述
    - 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。
    - 比如输入字符串为 "LEETCODEISHIRING" 行数为 3 时，按照Z字排列
    - 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："LCIRETOESIIGEDHN"。
    - 请你实现这个将字符串进行指定行数变换的函数：string convert(string s, int numRows);
    - 示例 1: 输入: s = "LEETCODEISHIRING", numRows = 3，输出: "LCIRETOESIIGEDHN"
    - 示例 2: 输入: s = "LEETCODEISHIRING", numRows = 4，输出: "LDREOEIIECIHNTSG"
  - ### 解题思路
    - 思路：按行排序
    - 本题关键：最后只需要按行输出，并不需要考虑中间的空格，即忽略空格，只要按Z字形将s铺在每一行即可
      - 注：如果找规律，然后使用二维数组把每个字符放到正确的位置，再输出，就走了弯路，没有看清本题的本质。
    - 复杂度：O(n)，O(n)
    - 分析：
      - 整体的思路是遍历字符串，遍历过程中将每行都看成新的字符串构成字符串数组，最后再将该数组拼接起来即可
      - 边界值：如果 numRows=1 则说明当前字符串即为结果，直接返回 s
      - 遍历整个字符串：向下向右，向下向右，反复循环
      - 设定 down 变量表示是否向下，loc 变量表示当前字符串数组的下标（down表示方向，loc表示所在行）
        - 如果 down 为 true，则 loc+=1，字符串数组下标向后移动，将当前字符加入当前字符串中
        - 如果 down 为 false，则表示向右，则 loc−=1，字符串数组下标向前移动，将当前字符加入当前字符串中
    - 算法：边界值-初始化-循环-拼接并返回。
      - 边界值处理：当numRows=1时，返回s；
      - 定义变量len为行数n和s长度的最小值：考虑如果s长度更小，只需要开辟更小的空间即可；
      - 定义长度为len的字符串数组，并初始化为空串 `""`；
      - 定义所在行的位置变量loc，定义布尔型变量down；
      - 循环：遍历字符串s，将每个字符放在正确的位置，根据down的真假更新loc的值，并截取s的子串添加到字符串数组的正确行；
      - 新建字符串res，并将上述字符串数组拼接起来，最后返回。

- ## 代码链接：
  - [Z字形变换](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0006-zigzag-conversion.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 8. 字符串转换整数atoi
- ## 简述：（[medium](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium.md)）
  - ### 题目描述
    - 请你来实现一个 atoi 函数，使其能将字符串转换成整数。
    - 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。
    - 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。
    - 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。
    - 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。
    - 在任何情况下，若函数不能进行有效的转换时，请返回 0。
    - 说明：
    - 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,2^31−1]。如果数值超过这个范围，请返回INT_MAX(2^31−1)或INT_MIN (−2^31) 。
    - 示例 1: 输入: "42"，输出: 42
    - 示例 2: 输入: "   -42"，输出: -42.
      - 解释: 第一个非空白字符为 '-', 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
    - 示例 3: 输入: "4193 with words"，输出: 4193.
      - 解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。
    - 示例 4: 输入: "words and 987"，输出: 0.
      - 解释: 第一个非空字符是 'w', 但它不是数字或正、负号。因此无法执行有效的转换。
    - 示例 5: 输入: "-91283472332"，输出: -2147483648。
      - 解释: 数字 "-91283472332" 超过 32 位有符号整数范围。因此返回 INT_MIN (−2^31) 。
  - ### 解题思路
    - 思路：正则和非正则。
      - 非正则的话，本题就是考虑多种不同的边界情况然后用一堆if-else来完成，同时面向测试用例编程来完善代码；
      - 正则表达式解题：更快更简洁，但是不熟练。这里贴代码和思路。
    - 关键：本题需要考虑的情况比较多，要非常细心。例如测试题目所列情况以及下列情况：
      - "    -42" --> -42；" + 413" --> 0；"0-1" --> 0；"- 234" -- > 0；"-2147483648" --> -2147483648；"+1" --> 1等
    - 非正则：
      - 函数返回值是int型，在任何情况下，不能进行有效的转换时都返回 0；
      - 从非空格字符开始算起：`str.trim()`剪去空格
        - str.trim() ：返回字符串的副本，忽略前导空白和尾部空白；如果字符串是空串，则返回str。
      - 判空：字符串为null，或者字符串长度为0时返回 0；
      - 定义结果变量res=0，起始位start=0；
      - 取第一个字符并赋值给firstChar
      - 考虑结果的符号正负：定义符号变量sign=1，然后判断firstChar是否是正负号中的一个，如果不是，不操作，继续后续步骤；
      - 循环：遍历字符串直到末尾，同时逐个取字符进行判断
        - 如果不是数字，就结束循环并返回结果：`Character.isDigit(j)==false`时`return (int) res * sign;`
        - 将第i个字符转为数字并赋值给变量：`pop = str.charAt(i) - '0';`
        - 为防止溢出，对res的值进行越界判断：sign为1时，以及为-1时，分类讨论
        - 排除各种异常情况后，计算res的值：`res = (int) res*10 + pop;`
      - 循环结束后返回`return res * sign;`
      - 注：越界判断参考<easy-7题>
        - 对于正数部分：
          - 考虑常规：`rev > Integer.MAX_VALUE/10` 时，rev * 10 必定大于Integer的Max值，不符合条件
          - 考虑临界：`rev == Integer.MAX_VALUE / 10` 时，整除会削去个位的值，因此，若再乘以10，个位是0。这时再加某值，这个值需要小于MAX值的个位，否则越界。因此：`pop > Integer.MAX_VALUE % 10`
        - 对于负数部分：因为sign符号是return的时候再添加的，所以需要rev和pop在此处写为-rev和-pop
          - 同理：`rev < Integer.MIN_VALUE / 10， 以及 rev == Integer.MIN_VALUE / 10 && x < Integer.MIN_VALUE % 10`
    - 正则：
      - 参考题解评论区大佬的代码实现，虽然简洁但是奈何不会啊....
    - 正则表达式知识点：
      - 参考[菜鸟教程-正则表达式](https://www.runoob.com/java/java-regular-expressions.html)
      - `^[\\+\\-]?\\d+`
      - `^ 表示匹配字符串开头，我们匹配的就是 '+'  '-'  号`
      - `[] 表示匹配包含的任一字符，比如[0-9]就是匹配数字字符 0 - 9 中的一个`
      - `? 表示前面一个字符出现零次或者一次，这里用 ? 是因为 '+' 号可以省略`
      - `\\d 表示一个数字 0 - 9 范围`
      - `+ 表示前面一个字符出现一次或者多次，\\d+ 合一起就能匹配一连串数字了`

- ## 代码链接：
  - [字符串转换整数atoi](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0008-string-to-integer-atoi.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 12. 整数转罗马数字
- ## 简述：（[medium](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium.md)）
  - ### 题目描述
    - 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。
    - 对应关系：I: 1; V: 5; X: 10; L: 50; C: 100; D: 500; M: 1000
    - 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
    - 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
      - I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
      - X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
      - C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
    - 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。
      - 示例 1: 输入: 3，输出: "III"
      - 示例 2: 输入: 4，输出: "IV"
      - 示例 3: 输入: 9，输出: "IX"
      - 示例 4: 输入: 58，输出: "LVIII"。解释: L = 50, V = 5, III = 3.
      - 示例 5: 输入: 1994，输出: "MCMXCIV"。解释: M = 1000, CM = 900, XC = 90, IV = 4.
  - ### 解题思路
    - 思路：贪心；哈希表。
      - 贪心的思想，哈希表的方法。
    - 参考<easy-13. 罗马数字转整数>，是本题的逆向，使用了查表发和相邻字符比较。
    - 分析：
      - 类型找零，用最少张数的纸币凑够所需的值，从最大的面值开始凑起。
      - 贪心或者哈希表法，都是围绕这一核心。其中哈希表可以用数组构建表的查表法替代。
      - 本题“整数转罗马数字”也有贪心类似的思想：
        - 在表示一个较大整数的时候，“罗马数字”的设计者不会让你都用 1 加起来；
        - 我们总是希望写出来的“罗马数字”的个数越少越好，以方便表示，并且这种表示方式还应该是唯一的。
      - 贪心算法的规则：每一步都使用当前较大的罗马数字作为加法因子，最后得到罗马数字表示就是长度最少的
      - 注意范围：int，且在 1 到 3999 的范围内。
    - 算法：
      - 复杂度：时间O(1)，空间O(1) -- 因为表的长度是有限的13个。
      - 首先：建表，使用两个数组模拟哈希表的键值对，一个数组values存放数字，一个数组strs存放数字对应的字母，数字按照从大到小的顺序；
        - 注意：strs数组赋值时，记得给字母加双引号。
      - 新建可变字符串StringBuilder，命名为res，用于存放转化为的字母；
      - 遍历数字数组：
        - 从头开始，整除结果quotient如果是0，continue直接结束本次循环并进入下一次循环；
        - 整除结果如果不是0，则对应到字符串数组中，并使用小循环将'商'次的对应字母添加到结果字符串；
        - 将num减去进行添加的`quotient * values[i]`；
        - 对num的值进行判断，为0时终止循环。
      - 返回结果：先转为String，然后返回。
      - 注意：对特殊值的处理是，将几个特殊值加入表中。

- ## 代码链接：
  - [整数转罗马数字](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0012-integer-to-roman.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 13. 罗马数字转整数
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 要求：给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。
    - 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M，分别对应1,5,10,50,100,500,1000
    - 规则：通常情况下，罗马数字中小的数字在大的数字的右边。否则，用右边的大数减去左边的小数
  - ### 解题思路
    - 多个字符对应不同的数字，考虑“查表法”，可用哈希表 或者 “switch”
    - 比较相邻两个字符，若高位不小于低位，直接相加；否则，要用低位的大数减去高位的小数。
    - 将每位对应的数字累加：可以从高位到低位，即从字符串的0到length-1

- ## 代码链接：
  - [罗马数字转整数](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0013-roman-to-integer.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 14. 最长公共前缀
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 编写一个函数来查找字符串数组中的最长公共前缀，如果不存在公共前缀，返回空字符串 ""。
    - 注意：是公共前缀，不是公共子序列
  - ### 解题思路
    - 水平扫描法，水平扫描，二分，分治，字典树
    - 水平扫描法：减法思想
      - 复杂度分析：时间复杂度低（战胜100%），空间复杂度高（战胜14%），相当于空间换时间了
      - 当字符串数组为空时，即长度为0时，即不存在公共前缀，返回空字符串""；
      - 以字符串数组中的第一个元素为基准，遍历整个数组，进行比较；
      - prefix保存当前最长公共前缀，如果prefix不是当前字符串的前缀，则删除最后一个字符再进行比较，一直到prefix变成当前字符串的前缀，或者变成空字符串
      - 注意是求公共前缀，不是最长公共子序列，因此可以从后面减，也是while判0的原因
    - 用到的字符串相关知识：
      - indexOf()
      - substring()
      - isEmpty()
      - 注意长度：字符串长度加小括号
      
- ## 代码链接：
  - [最长公共前缀](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0014-longest-common-prefix.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 20. 有效的括号
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。
  - ### 解题思路
    - 思路：暴力法；栈
    - 暴力法：
      - 每次检测是否有最里侧的成对某种括号，若有，则替换所有成对括号为空字符串，直到检测不到相邻的成对括号
      - 遍历完成后，如果是有效表达式，则最后的字符串会只剩下空串，判断是否==空串
    - 栈：
      - 初始化哈希表 char型
      - 初始化栈 char型
      - 遍历字符串，每次对遍历到的字符进行判断
        - 压栈：遇到开括号，将其推到栈上。
        - 弹栈：否则，当栈非空，且当前字符串的字符与栈顶元素配对成功时，弹栈
        - 无效：否则，表达式无效。
      - 最后，若栈非空，则表达式无效。
      
- ## 代码链接：
  - [有效的括号](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0020-valid-parentheses.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 28. 实现strStr()
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
    - 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
  - ### 解题思路
    - 思路：暴力法（超时）；kmp（未尝试）；indexOf()（直接用内置函数）
    - 题目标签是"字符串"和"双指针"，题解是kmp算法，但因为是简单题所以好多人用indexOf()
    - 双指针暴力解决会超时
    - 尝试用indexOf()解决：（一行代码）

- ## 代码链接：
  - [实现strStr()](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0028-implement-strstr.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 38. 外观数列
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 外观数列 是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：
      - `1, 11, 21, 1211, 111221, ...`
    -   - 给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。
    - 注意：整数序列中的每一项将表示为一个字符串。
  - ### 解题思路
    - 本题的本质是计数器，本题的关键是理清数字规律，并将数学规律转为代码
      - 本题输入是int型，返回值是String型
      - 首先自定义n=1时，s="1"; 
      - 当n=1时直接返回；当n>=2时，再进行后续的复杂操作
        - 注：题目要求"正整数 n（1 ≤ n ≤ 30）"，故不作其他判断，甚至能用穷举法存入字典查表解决...
      - 两层循环：外循环控制行数，内循环遍历上一行生成的字符串并“报数”
      - 外循环：2-n（包含等于n），从2开始，n=1的情况直接返回
      - 内循环：
        - 从s的[0]开始设置"flag"-pre，计数器count，循环从1开始向后遍历，数(动词)与pre相等的个数，直到不再相等
        - 不相等的时候，调整pre为不再相等的位置的数字，并将count归为1，重新开始计数
    - 注：本题标签是字符串，考虑用可变字符串StringBuilder，最后toString()转为String形式
    
- ## 代码链接：
  - [外观数列](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0038-count-and-say.java)
 
<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 58. 最后一个单词的长度
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个仅包含大小写字母和空格 ' ' 的字符串 s，返回其最后一个单词的长度。
    - 如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。
    - 英文：(last word means the last appearing word if we loop from left to right) in the string.
      - 由英文表述可知：是从左向右遍历字符串
    - 如果不存在最后一个单词，请返回 0 。
    - 说明：一个单词是指仅由字母组成、不包含任何空格的 最大子字符串
  - ### 解题思路
    - 标签字符串的简单题
    - 因为是从左向右遍历，因此可以从末尾开始，即从最右侧的非空格开始计数
      - 需要考虑最右侧的空格和不是空格的情况
    - 初始化count为0，从length-1开始往回遍历，从非空格开始计数，当开始计数以后，且再次遇到空格时停止计数并返回
    - 需要考虑多种临界：比如单个字母返回1
    
- ## 代码链接：
  - [最后一个单词的长度](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0058-length-of-last-word.java)
  
<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 67. 二进制求和
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定两个二进制字符串，返回他们的和（用二进制表示）。
    - 输入为非空字符串且只包含数字 1 和 0。
  - ### 解题思路
    - 思路：逐位计算（位运算的方法要考虑过多的细枝末节，这里不详述）
    - 补0使两字符串长度相等，然后从末尾开始遍历，并不断添加结果，最后对结果进行反转
      - 补0：在遍历过程中判断，长度小于0时直接返回0
      - 添加：需要在字符串上添加，因此使用可变字符串StrinBuilder
      - 反转：添加顺序是每次在右侧添加，即不断将较高位添加到右侧，因此最后需要反转
    - 定义可变字符串res，进位标志flag
    - 循环：从末尾开始，同时遍历两个字符串，并在两字符串均遍历至第一个元素时终止循环（双或）
    - 赋值sum=flag，并分别取a和b两字符串的最右位累加到sum
    - 用三目运算符在判断的同时得到sum的值，其中先判断i和j是否大于等于0为了补0，`a.charAt(i)-'0'`根据字符距离得到相应数值计算结果
    - 之后对所得sum值判断：取余得到添加结果，整除得到flag的值
    - 返回时需要对最后一次循环后flag的值进行判断，之后反转，并转为String型
    - 注：本代码好几处把几句代码合并到一句的
    
- ## 代码链接：
  - [二进制求和](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0067-add-binary.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 125. 验证回文串
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
    - 说明：本题中，我们将空字符串定义为有效的回文串。
  - ### 解题思路
    - 思路：双指针
    - 复杂度：时间O(n)，空间O(1)
    - 分析：
      - 不区分大小写：先转为小写 `s = s.toLowerCase();`
      - 按顺序处理字符串的每个字符：字符串转为字符数组 `char[] chs = s.toCharArray();`
      - 不计除了字母和数字之外的字符：判断字符是否在字母或者数字的范围内，不在时直接略个这个字符
      - 最后如果没有出现不相等的情况，则返回true
    - 算法：转为小写；转为字符数组；双指针遍历：当遇到非数字和非字母的字符时指针指向下一个位置，之后判断两指针对应的字符是否相等；返回结果。

- ## 代码链接:
  - [验证回文串](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0125-valid-palindrome.java)
  
<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 


<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 1071. 字符串的最大公因子
- ## 简述：（[easy6](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy6.md)）
  - ### 题目描述
    - 对于字符串 S 和 T，只有在 S = T + ... + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。
    - 返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。
    - 示例 1：输入：str1 = "ABCABC", str2 = "ABC"; 输出："ABC"
    - 示例 2：输入：str1 = "ABABAB", str2 = "ABAB"; 输出："AB"
    - 示例 3：输入：str1 = "LEET", str2 = "CODE"; 输出：""
    - 提示：1 <= str1.length <= 1000; 1 <= str2.length <= 1000; str1[i] 和 str2[i] 为大写英文字母  
  - ### 解题思路
    - 思路：暴力枚举；辗转相除法
    - 分析：
      - 题目定义中的T是公因子，多个T拼接在一起组成S，除尽，即字符串S被公因子T除尽。
    - 暴力枚举：
      - 答案肯定是字符串的某个前缀，然后简单直观的想法就是枚举所有的前缀来判断，
      - 复杂度较高
    - 辗转相除法：
      - 复杂度：时间O(n)，空间O(n)
      - 性质：如果 str1 和 str2 拼接后等于 str2和 str1 拼接起来的字符串（注意拼接顺序不同），那么一定存在符合条件的字符串 X。
      - 符合上述相等时，求s1和s2长度的最大公因子，并以此为长度取子串，即为所求。
      - 辗转相除：
        - 欧几里德算法又称辗转相除法，是指用于计算两个正整数a，b的最大公约数。
        - 应用领域有数学和计算机两个方面；
        - 以除数和余数反复做除法运算，当余数为 0 时，取当前算式除数为最大公约数；
        - 计算公式`gcd(a,b) = gcd(b,a mod b)`，前一个可看做被除数，后一个是除数，(a%b)即为余数，递归。
      - 算法：
        - 定义求最大公因数的函数gcd：使用公式`gcd(a,b) = gcd(b,a mod b)`；
        - 判断s1+s2与s2+s1是否相等，不相等时返回空串；
        - 相等时，返回s1的子串，子串从0开始，取到gcd长度为止。
      
- ## 代码链接：
  - [字符串的最大公因子](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/1071-greatest-common-divisor-of-strings.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



#


<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



#


<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



#


<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



#


<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



#


<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



#


<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



### END
