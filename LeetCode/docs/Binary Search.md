# 二分查找
- 内含题目：83

# 目录
<!-- GFM-TOC -->
* [35. 搜索插入位置](#35-搜索插入位置)
* [69. x的平方根](#69-x的平方根)
* [153. 寻找旋转排序数组中的最小值](#153-寻找旋转排序数组中的最小值)
* [167. 两数之和II-输入有序数组](#167-两数之和ii-输入有序数组)
* []()
* [240. 搜索二维矩阵II](#240-搜索二维矩阵ii)
* []()
<!-- GFM-TOC -->



# 35. 搜索插入位置
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。
    - 如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
  - ### 解题思路
    - 思路：暴力法；二分查找
    - 暴力法：
      - 遍历并比较，直到`nums[i] < target`不再成立
    - 二分：
      - 常规二分查找的写法会超时....
    - 内置函数二分查找：
      - 使用`Arrays.binarySearch(nums, target)`并在找不到时返回-a-1
      - 用时0ms...

- ## 代码链接：
  - [搜索插入位置](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0035-search-insert-position.java)


<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 69. x的平方根
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 实现 int sqrt(int x) 函数。
    - 计算并返回 x 的平方根，其中 x 是非负整数。
    - 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
  - ### 解题思路
    - 思路：二分；牛顿迭代法
      - 注：二分是程序员的正常思路，牛顿迭代法是利用数学中的一个结论
      - 牛顿法是近似求根的经典方法，会更快
    - 二分：
      - 复杂度：时间O(logn), 空间O(1)
      - 当 x≥2 时，它的整数平方根一定小于 x/2 且大于 0，即 0<a<x/2。由于 a 一定是整数，此问题转换成在有序整数集中寻找一个特定值
      - 用二分查找的思想不断取中间值并比较，最终逼近结果
    - 牛顿迭代法：
      - 复杂度：时间O(logn), 空间O(1)
      - 一种在实数域和复数域上近似求解方程的方法
      - 求开平方，即求c(c>=0)的算术平方根，等同于求f(x)=x^2-c的正根，得迭代公式x(n+1) = 0.5 * ( x(n) + c/x(n) )
      - 本题向下取整，x(i+1)-x(i)的误差控制在1以内，最后当误差小于 1 时结束迭代。

- ## 代码链接：
  - [x的平方根](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0069-sqrtx.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 153. 寻找旋转排序数组中的最小值
- ## 简述：（[medium2](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium2.md)）
  - ### 题目描述
    - 假设按照升序排序的数组在预先未知的某个点上进行了旋转。
      - 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2])。
    - 请找出其中最小的元素。
    - 你可以假设数组中不存在重复元素。
    - 示例 1: 输入: [3,4,5,1,2], 输出: 1
    - 示例 2: 输入: [4,5,6,7,0,1,2], 输出: 0
  - ### 解题思路
    - 思路：暴力法；排序；二分。
    - 注：
      - 本题与<154-hard>的区别：本题规定不存在重复元素，154题可能存在重复元素。
      - 本题java解法貌似不需要判空，毕竟如果空，也不知道返回什么来表示。抛出异常？
    - ### 暴力法：
      - 复杂度：时间O(n)，空间O(1)
      - 算法：定义最小值；遍历数组并更新最小值；返回最小值。
    - ### 排序：
      - 复杂度：时间O(nlogn)，空间O(1)
      - 算法：Arrays.sort()排序；返回索引为0的元素。
      - 注：这种方法代码两行，但是时间复杂度高于暴力法。
    - ### 二分：
      - 复杂度：时间O(logn)，空间O(1)
      - 利用好“升序数组”这一特性，使用类似二分查找的方法，用双指针遍历数组
        - 注：因为不存在重复元素，因此不要考虑某两个元素相等的情况。
      - 算法：
        - 定义双指针；
        - 左右指针不相等时遍历数组：取mid，比较mid对应元素与right对应元素，mid大则left=mid+1，mid小则right=mid；
        - 返回left对应元素(right也行，因为最后两个指针相等了)。
    
- ## 代码链接：
  - [寻找旋转排序数组中的最小值](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0153-find-minimum-in-rotated-sorted-array.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->

  

# 167. 两数之和II-输入有序数组
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个 已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。
    - 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。
    - 说明:
      - 返回的下标值（index1 和 index2）不是从零开始的。
      - 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
  - ### 解题思路
    - 分析：与1题的区别：数组是有序的。
      - 注：1题的解题思路包括暴力法；哈希表（两次哈希表；一次哈希表）
    - 思路：双指针与二分查找的结合
    - 使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。
      - 如果两个指针指向元素的和 sum==target，那么得到要求的结果；
      - 如果 sum>target，移动较大的元素，使 sum 变小一些；
      - 如果 sum<target，移动较小的元素，使 sum 变大一些。
    - 复杂度：时间O(N)，空间O(1)。
    - 算法：判空；定义两变量作为左右指针并初始化；循环直到(a<b)不再成立：比较sum与target并移动指针；最后返回null。
      - 循环条件(a<b)：题目要求index1必须小于index2
      - 找到时返回数组的索引值要+1：题目要求返回的下标值（index1 和 index2）不是从零开始的，是从1开始的。

- ## 代码链接:
  - [相交链表](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0167-two-sum-ii-input-array-is-sorted.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->  



# 240. 搜索二维矩阵II
- ## 简述：（[medium3](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium3.md)）
  - ### 题目描述
    - 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：
    - 每行的元素从左到右升序排列。每列的元素从上到下升序排列。
  - ### 解题思路
    - 思路：暴力法；线性查找。
    - 暴力法：忽略存在的顺序，直接暴力查找；时间复杂度高。
      - 复杂度：时间O(mn)，空间O(1)  -- m 为行数，n 为 列数。
    - 线性查找：
      - 复杂度：时间O(m+n)，空间O(1)  -- m 为行数，n 为 列数。
      - 关键：站在右上角看。这个矩阵其实就像是一个Binary Search Tree。
      - 分析：
        - 分析复杂问题：从一个具体的例子入手
        - 可以发现：该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。
        - 考虑从右上角或者左下角开始，可以避免可能选取区域重叠。
        - 右上角：左侧为小于，下侧为大于。若小，下移；若大，左移。
        - 测试用例考虑：有目标；没有目标（大于max，小于min，介于但不存在）；空指针；行列数非正
        - 空指针即地址为null，行列数非正，这两个需要排除。而没有目标中各种情况都属于找不到，返回false即可，无需特意判断。
      - 算法本质： 
        - 每轮 i 或 j 移动后，相当于生成了“消去一行（列）的新矩阵”， 索引(i,j) 指向新矩阵的左下角元素（标志数）
        - 因此可重复使用以上性质消去行（列）。
      - 算法：判空(如果定义了范围，可省略)；定义右上角行列索引值；遍历数组：范围内，大则左移，小则下移，否则返回true；最后返回false。
  
- ## 代码链接：
   - [搜索二维矩阵II](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0240-search-a-2d-matrix-ii.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



### END
