# 二分查找
- 内含题目：83

# 目录
<!-- GFM-TOC -->
* [34. 在排序数组中查找元素的第一个和最后一个位置](#34-在排序数组中查找元素的第一个和最后一个位置)
* [35. 搜索插入位置](#35-搜索插入位置)
* [69. x的平方根](#69-x的平方根)
* [153. 寻找旋转排序数组中的最小值](#153-寻找旋转排序数组中的最小值)
* [154. 寻找旋转排序数组中的最小值II](#154-寻找旋转排序数组中的最小值ii)
* [167. 两数之和II-输入有序数组](#167-两数之和ii-输入有序数组)
* []()
* [240. 搜索二维矩阵II](#240-搜索二维矩阵ii)
* []()
<!-- GFM-TOC -->



# 34. 在排序数组中查找元素的第一个和最后一个位置
- ## 简述：（[medium](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium.md)）
  - ### 题目描述
    - 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
    - 你的算法时间复杂度必须是 O(log n) 级别。
    - 如果数组中不存在目标值，返回 [-1, -1]。
    - 示例 1:
      - 输入: nums = [5,7,7,8,8,10], target = 8
      - 输出: [3,4]
    - 示例 2:
      - 输入: nums = [5,7,7,8,8,10], target = 6
      - 输出: [-1,-1]
  - ### 解题思路
    - 参考：剑指-53.1-在排序数组中查找数字的思路
    - 思路：二分查找
    - 复杂度：时间O(logn), 空间O(1)
    - 分析：
      - 排序数组中的搜索问题，首先想到 二分法 解决。
        - 但可能只找到target其中之一，若向前向后遍历来找所有target，则时间复杂度变为暴力遍历相同的O(n)。
      - 排序数组 nums 中的所有数字 target 形成一个窗口，记窗口的 左 / 右边界 索引分别为 left 和 right ，分别对应窗口左边 / 右边的首个元素。
      - 本题要求统计数字 target 的出现次数，可转化为：使用二分法分别找到 左边界 left 和 右边界 right ，易得数字 target 的数量为 right−left+1 
        - 分别用二分求左右边界，则时间复杂度仍为O(logn)。
    - 算法：
      - 初始化边界指针为数组的左右端点；
      - 两次二分；
        - 不等时，同二分处理；
        - nums[mid]与target相等时：
          - 右边界：在mid对应元素的右侧，因此小指针更新为mid+1；
          - 左边界：在mid对应元素的左侧，因此大指针更新为mid-1；
          - 注：这种区别可以通过<=的等于号，并配合if-else实现。
      - 判空：根据左右边界值索引求长度，若为0，则target不存在，返回{-1,-1}
      - 新建数组，并将最终的左右边界索引传入后返回；
      - 注：target不存在的情况会返回0，符合预期结果。
    - 改进：两次二分的代码可以封装起来，然后进行调用，并直接返回差值。
      - 数组 nums 中元素都为整数，因此可以分别二分查找 target 和 target−1 的右边界，将两结果相减并返回即可。
      - 未尝试：如果target-1对应的值不存在或存在多个，需要考虑的东西很多。  
  
- ## 代码链接：
  - [在排序数组中查找元素的第一个和最后一个位置](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0034-find-first-and-last-position-of-element-in-sorted-array.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 35. 搜索插入位置
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。
    - 如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
  - ### 解题思路
    - 思路：暴力法；二分查找
    - 暴力法：
      - 遍历并比较，直到`nums[i] < target`不再成立
    - 二分：
      - 常规二分查找的写法会超时....
    - 内置函数二分查找：
      - 使用`Arrays.binarySearch(nums, target)`并在找不到时返回-a-1
      - 用时0ms...

- ## 代码链接：
  - [搜索插入位置](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0035-search-insert-position.java)


<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 69. x的平方根
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 实现 int sqrt(int x) 函数。
    - 计算并返回 x 的平方根，其中 x 是非负整数。
    - 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
  - ### 解题思路
    - 思路：二分；牛顿迭代法
      - 注：二分是程序员的正常思路，牛顿迭代法是利用数学中的一个结论
      - 牛顿法是近似求根的经典方法，会更快
    - 二分：
      - 复杂度：时间O(logn), 空间O(1)
      - 当 x≥2 时，它的整数平方根一定小于 x/2 且大于 0，即 0<a<x/2。由于 a 一定是整数，此问题转换成在有序整数集中寻找一个特定值
      - 用二分查找的思想不断取中间值并比较，最终逼近结果
    - 牛顿迭代法：
      - 复杂度：时间O(logn), 空间O(1)
      - 一种在实数域和复数域上近似求解方程的方法
      - 求开平方，即求c(c>=0)的算术平方根，等同于求f(x)=x^2-c的正根，得迭代公式x(n+1) = 0.5 * ( x(n) + c/x(n) )
      - 本题向下取整，x(i+1)-x(i)的误差控制在1以内，最后当误差小于 1 时结束迭代。

- ## 代码链接：
  - [x的平方根](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0069-sqrtx.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 153. 寻找旋转排序数组中的最小值
- ## 简述：（[medium2](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium2.md)）
  - ### 题目描述
    - 假设按照升序排序的数组在预先未知的某个点上进行了旋转。
      - 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2])。
    - 请找出其中最小的元素。
    - 你可以假设数组中不存在重复元素。
    - 示例 1: 输入: [3,4,5,1,2], 输出: 1
    - 示例 2: 输入: [4,5,6,7,0,1,2], 输出: 0
  - ### 解题思路
    - 思路：暴力法；排序；二分。
    - 注：
      - 本题与<154-hard>的区别：本题规定不存在重复元素，154题可能存在重复元素。
      - 本题java解法貌似不需要判空，毕竟如果空，也不知道返回什么来表示。抛出异常？
    - ### 暴力法：
      - 复杂度：时间O(n)，空间O(1)
      - 算法：定义最小值；遍历数组并更新最小值；返回最小值。
    - ### 排序：
      - 复杂度：时间O(nlogn)，空间O(1)
      - 算法：Arrays.sort()排序；返回索引为0的元素。
      - 注：这种方法代码两行，但是时间复杂度高于暴力法。
    - ### 二分：
      - 复杂度：时间O(logn)，空间O(1)
      - 利用好“升序数组”这一特性，使用类似二分查找的方法，用双指针遍历数组
        - 注：因为不存在重复元素，因此不要考虑某两个元素相等的情况。
      - 算法：
        - 定义双指针；
        - 左右指针不相等时遍历数组：取mid，比较mid对应元素与right对应元素，mid大则left=mid+1，mid小则right=mid；
        - 返回left对应元素(right也行，因为最后两个指针相等了)。
    
- ## 代码链接：
  - [寻找旋转排序数组中的最小值](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0153-find-minimum-in-rotated-sorted-array.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->

  

# 154. 寻找旋转排序数组中的最小值II
- ## 简述：（[hard](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/hard.md)）
  - ### 题目描述
    - 假设按照升序排序的数组在预先未知的某个点上进行了旋转。
      - 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2]。
    - 请找出其中最小的元素。
    - 注意数组中可能存在重复的元素。
    - 示例 1：输入: [1,3,5], 输出: 1;
    - 示例 2：输入: [2,2,2,0,1], 输出: 0
    - 说明：这道题是 寻找旋转排序数组中的最小值 的延伸题目。允许重复会影响算法的时间复杂度吗？会如何影响，为什么？
  - ### 解题思路
    - 思路：暴力法；排序；二分。
    - 注：
      - 本题与<153-medium>的区别：本题规定可能存在重复元素，153题规定不存在重复元素。
      - 153题与本题：暴力法和排序没有区别，二分需要在判断时注意处理重复元素。
      - 本题java解法貌似不需要判空，毕竟如果空，也不知道返回什么来表示。抛出异常？
    - ### 暴力法：
      - 复杂度：时间O(n)，空间O(1)
      - 算法：定义最小值；遍历数组并更新最小值；返回最小值。
    - ### 排序：
      - 复杂度：时间O(nlogn)，空间O(1)
      - 算法：Arrays.sort()排序；返回索引为0的元素。
      - 注：这种方法代码两行，但是时间复杂度高于暴力法。
    - ### 二分：
      - 复杂度：时间O(logn)，空间O(1)
      - 利用好“升序数组”这一特性，使用类似二分查找的方法，用双指针遍历数组
        - 注：因为可能存在重复元素，因此需要考虑某两个元素相等的情况。
      - 注意：比较的是mid与right，如果用left指针，可能出问题。
      - 算法：
        - 定义双指针；
        - 左右指针不相等时遍历数组：取mid，比较mid对应元素与right对应元素，mid大则left=mid+1，mid小则right=mid；
          - 注意：如果mid与right对应元素相等，则right--；（分类讨论各种情况可以验证抛弃right后min仍然在left到right范围内）。
        - 返回left对应元素(right也行，因为最后两个指针相等了)。

- ## 代码链接：
  - [寻找旋转排序数组中的最小值II](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0154-find-minimum-in-rotated-sorted-array-ii.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 167. 两数之和II-输入有序数组
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个 已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。
    - 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。
    - 说明:
      - 返回的下标值（index1 和 index2）不是从零开始的。
      - 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
  - ### 解题思路
    - 分析：与1题的区别：数组是有序的。
      - 注：1题的解题思路包括暴力法；哈希表（两次哈希表；一次哈希表）
    - 思路：双指针与二分查找的结合
    - 使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。
      - 如果两个指针指向元素的和 sum==target，那么得到要求的结果；
      - 如果 sum>target，移动较大的元素，使 sum 变小一些；
      - 如果 sum<target，移动较小的元素，使 sum 变大一些。
    - 复杂度：时间O(N)，空间O(1)。
    - 算法：判空；定义两变量作为左右指针并初始化；循环直到(a<b)不再成立：比较sum与target并移动指针；最后返回null。
      - 循环条件(a<b)：题目要求index1必须小于index2
      - 找到时返回数组的索引值要+1：题目要求返回的下标值（index1 和 index2）不是从零开始的，是从1开始的。

- ## 代码链接:
  - [相交链表](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0167-two-sum-ii-input-array-is-sorted.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->  



# 240. 搜索二维矩阵II
- ## 简述：（[medium3](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium3.md)）
  - ### 题目描述
    - 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：
    - 每行的元素从左到右升序排列。每列的元素从上到下升序排列。
  - ### 解题思路
    - 思路：暴力法；线性查找。
    - 暴力法：忽略存在的顺序，直接暴力查找；时间复杂度高。
      - 复杂度：时间O(mn)，空间O(1)  -- m 为行数，n 为 列数。
    - 线性查找：
      - 复杂度：时间O(m+n)，空间O(1)  -- m 为行数，n 为 列数。
      - 关键：站在右上角看。这个矩阵其实就像是一个Binary Search Tree。
      - 分析：
        - 分析复杂问题：从一个具体的例子入手
        - 可以发现：该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。
        - 考虑从右上角或者左下角开始，可以避免可能选取区域重叠。
        - 右上角：左侧为小于，下侧为大于。若小，下移；若大，左移。
        - 测试用例考虑：有目标；没有目标（大于max，小于min，介于但不存在）；空指针；行列数非正
        - 空指针即地址为null，行列数非正，这两个需要排除。而没有目标中各种情况都属于找不到，返回false即可，无需特意判断。
      - 算法本质： 
        - 每轮 i 或 j 移动后，相当于生成了“消去一行（列）的新矩阵”， 索引(i,j) 指向新矩阵的左下角元素（标志数）
        - 因此可重复使用以上性质消去行（列）。
      - 算法：判空(如果定义了范围，可省略)；定义右上角行列索引值；遍历数组：范围内，大则左移，小则下移，否则返回true；最后返回false。
  
- ## 代码链接：
   - [搜索二维矩阵II](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0240-search-a-2d-matrix-ii.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



### END
