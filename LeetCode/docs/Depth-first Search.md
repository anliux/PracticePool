# 深度优先搜索
- 内含题目：129

# 目录
<!-- GFM-TOC -->
* [100. 相同的树](#100-相同的树)
* [101. 对称二叉树](#101-对称二叉树)
* [104. 二叉树的最大深度](#104-二叉树的最大深度)
* [108. 将有序数组转换为二叉搜索树](#108-将有序数组转换为二叉搜索树)
* []()
* []()
* []()
* []()
* []()
<!-- GFM-TOC -->



# 100. 相同的树
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定两个二叉树，编写一个函数来检验它们是否相同。
    - 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
    - 图和示例略，具体而言，是按“中-左-右”的顺序对两棵树进行遍历和判断是否相等
  - ### 解题思路
    - 思路：递归；迭代
      - 注：标签里有“深度优先搜索”，dfs分为递归和非递归，递归比较顺手...
    - 递归：
      - 复杂度：时间O(n)，平衡二叉树是最优为O(logn)，空间O(n)
      - 先判断根节点是否相同，在调用本体分别对左节点和右节点进行判断
      - 首先：判空，即全空true，一空false
      - 根节点的值判断是否相等：不等false，相等返回对左和右的调用本体结果
    - 迭代：
      - 复杂度：时间O(n)，平衡二叉树是最优为O(logn)，空间O(n)
      - 从根开始，每次迭代将当前结点从双向队列中弹出。然后判断：非空且值相等时，压入子结点
      - 注：代码太多了，用递归就好

- ## 代码链接：
  - [相同的树](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0100-same-tree.java)
  
<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->
  


# 101. 对称二叉树
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个二叉树，检查它是否是镜像对称的。注：数组层序遍历树。
    - 示例1：二叉树 [1,2,2,3,4,4,3] 是对称的。
    - 示例2：二叉树 [1,2,2,null,3,null,3] 则不是镜像对称的:
    - 图略
  - ### 解题思路
  - 思路：递归；迭代
  - 递归
    - 复杂度：时间O(n)，空间O(n)
    - 如果一个树的左子树与右子树镜像对称，那么这个树是对称的。
    - 如果同时满足下面的条件，两个树互为镜像：
      - 它们的两个根结点具有相同的值。
      - 每个树的右子树都与另一个树的左子树镜像对称。
    - 定义镜像函数：
      - 判空：全空；一空一不空；
      - 根结点相等时，返回调用本体判断（结点1的左和结点2的右）以及（结点1的右和结点2度左）；
      - 注：借鉴100题的递归优化方法先判全空，后判根结点值相等，最后false这种设置可能用空指针异常，判相等一定记得 && 全不空
  - 迭代
    - 复杂度：时间O(n)，空间O(n)
    - 注：代码太多了，用递归就好

- ## 代码链接：
  - [对称二叉树](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0101-symmetric-tree.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 104. 二叉树的最大深度
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个二叉树，找出其最大深度。
    - 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
    - 说明: 叶子节点是指没有子节点的节点。
    - 示例：给定二叉树 [3,9,20,null,null,15,7]，则最大深度为3（层序遍历树表示为数组）
  - ### 解题思路
    - 思路：递归；迭代
    - 递归
      - 复杂度：时间O(n)，空间O(n)
      - 规律：树的高度 = 1 + max(左子树的高，右子树的高)
      - 算法：首先判空；其次返回调用本体的左右子树的高，取得max值，并且+1后返回
    - 迭代
      - 复杂度：时间O(n)，空间O(n)
      - 在栈的帮助下将上面的递归转换为迭代。
      - 使用 DFS 策略访问每个结点，同时在每次访问时更新最大深度。
      - 从包含根结点且相应深度为 1 的栈开始。然后继续迭代：将当前结点弹出栈并推入子结点。每一步都会更新深度。
      - 具体代码略
    
- ## 代码链接：
  - [二叉树的最大深度](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0104-maximum-depth-of-binary-tree.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 108. 将有序数组转换为二叉搜索树
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。
  - ### 解题思路
    - 遍历树的方法。DFS：先序遍历，中序遍历，后序遍历；BFS。
    - 二叉搜索树的中序遍历是一个升序序列。将有序数组作为输入，可以把该问题看做根据中序遍历序列创建二叉搜索树。
    - 高度平衡意味着每次必须选择中间数字作为根节点。
    - 中序遍历：始终选择中间位置左边元素作为根节点
      - 复杂度：时间O(n)，空间O(n)
      - 中间左：向下取整，整除2即可取小。具体地，被除数为奇数时向下取整，被除数为偶数时可以整除直接返回得数
      - 方法 helper(left, right) 使用数组 nums 中索引从 left 到 right 的元素创建 BST：
        - 如果 left > right，子树中不存在元素，返回空。
        - 找出中间元素：p = (left + right) // 2。
        - 创建根节点：root = TreeNode(nums[p])。
        - 递归创建左子树 root.left = helper(left, p - 1) 和右子树 root.right = helper(p + 1, right)。
      - 返回 helper(0, len(nums) - 1)。
    - 中序遍历：始终选择中间位置右边元素作为根节点
      - 复杂度：时间O(n)，空间O(n)
      - 中间右：在中间左的取平均基础上，加一个判断，如果被除数是奇数，整除会向下取整，因此手动mid++
      - 注意：因为数组索引值从0开始，因此偶数个时，
    - 中序遍历：选择任意一个中间位置元素作为根节点
      - 复杂度：时间O(n)，空间O(n)
      - 左右随机：在中间左的取平均基础上，加一个判断，如果被除数是奇数，整除会向下取整，因此手动mid随机取+0或+1
      - 取随机数代码：
        - `Random rand = new Random();`
        - `if ((left + right) % 2 == 1) mid += rand.nextInt(2);`

- ## 代码链接
  - [将有序数组转换为二叉搜索树](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0108-convert-sorted-array-to-binary-search-tree.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->





<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->






<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->

### END
