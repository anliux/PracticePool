# 栈
- 内含题目：54

# 目录
<!-- GFM-TOC -->
* [20. 有效的括号](#20-有效的括号)
* [155. 最小栈](#155-最小栈)
* []()
* []()
* []()
* [946. 验证栈序列](#946-验证栈序列)
* []()
<!-- GFM-TOC -->



# 20. 有效的括号
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。
  - ### 解题思路
    - 思路：暴力法；栈
    - 暴力法：
      - 每次检测是否有最里侧的成对某种括号，若有，则替换所有成对括号为空字符串，直到检测不到相邻的成对括号
      - 遍历完成后，如果是有效表达式，则最后的字符串会只剩下空串，判断是否==空串
    - 栈：
      - 初始化哈希表 char型
      - 初始化栈 char型
      - 遍历字符串，每次对遍历到的字符进行判断
        - 压栈：遇到开括号，将其推到栈上。
        - 弹栈：否则，当栈非空，且当前字符串的字符与栈顶元素配对成功时，弹栈
        - 无效：否则，表达式无效。
      - 最后，若栈非空，则表达式无效。
      
- ## 代码链接：
  - [有效的括号](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0020-valid-parentheses.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->




# 155. 最小栈
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。
    - push(x) -- 将元素 x 推入栈中。
    - pop() -- 删除栈顶的元素。
    - top() -- 获取栈顶元素。
    - getMin() -- 检索栈中的最小元素。
  - ### 解题思路
    - 注：本题重点是getMin()，因此可以考虑借用现成栈实现，相当于重写功能
    - 思路：两个栈；一个栈；不借用栈
    - 两个栈：
      - 用两个栈，一个栈去保存正常的入栈出栈的值，另一个栈去存最小值，也就是用栈顶保存当前所有元素的最小值。
      - 存最小值的栈的具体操作流程如下：
        - 将第一个元素入栈。
        - 新加入的元素如果大于栈顶元素，那么新加入的元素就不处理。
        - 新加入的元素如果小于等于栈顶元素，那么就将新元素入栈。
        - 出栈元素不等于栈顶元素，不操作。
        - 出栈元素等于栈顶元素，那么就将栈顶元素出栈。
    - 一个栈：
      - 只用一个变量去保存最小值，这时的关键是：如何保留最小值的记录（如果最小值弹出了，就会用到历史的最小值）
      - 解决：当有更小的值来的时候，只需要把之前的最小值入栈，当前更小的值再入栈即可。当这个最小值要出栈的时候，下一个值便是之前的最小值了。
      - 注意：push()中的if判断需要包含等于：因为如果此时的x弹出，最小值仍是原来的那个。如果等于就不压栈，那么一旦弹出，原相等的最小值就没了。
        - 等于不会死循环，这里的push是库函数不是上面的push
    
- ## 代码链接:
  - [最小栈](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0155-min-stack.java)
   
<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 946. 验证栈序列
- ## 简述：（[medium11](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium11.md)）
  - ### 题目描述
    - 给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。
    - 示例 1：
      - 输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
      - 输出：true
      - 解释：我们可以按以下顺序执行：
        - push(1), push(2), push(3), push(4), pop() -> 4,
        - push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
    - 示例 2：
      - 输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
      - 输出：false
      - 解释：1 不能在 2 之前弹出。
    - 提示：
      - 1 <= pushed.length <= 1000
      - 0 <= pushed[i] <= 1000
      - pushed 的所有元素 互不相同
      - popped.length == pushed.length
      - popped 是 pushed 的一个排列
  - ### 解题思路
    - 思路关键点：
      - 模拟：同样用栈辅助。
      - 根据弹出的数字去栈顶匹配：匹配到时继续走，没匹配到时压栈直到指定数字出现。 
      - 两个数组会有两个索引值，不需要控制的压栈数组可以考虑使用foreach循环。
      - 判断结果也很巧妙，只有当遍历了压栈序列退出循环，而辅助栈也全部弹栈的情况下为真。
    - 模拟思路：
      - 考虑借用一个辅助栈 stack，模拟 压入 / 弹出操作的排列。根据是否模拟成功，即可得到结果。
        - 注意这里判断是否成功用的是：遍历压栈序列结束后，辅助栈是否为空。 
      - 入栈操作： 按照压栈序列的顺序执行。
      - 出栈操作： 每次入栈后，循环判断 “栈顶元素 == 弹出序列的当前元素” 是否成立，将符合弹出序列顺序的栈顶元素全部弹出。
      - 由于题目规定 栈的所有数字均不相等 ，因此在循环入栈中，每个元素出栈的位置的可能性是唯一的（若有重复数字，则具有多个可出栈的位置）。因而，在遇到 “栈顶元素 == 弹出序列的当前元素” 就应立即执行出栈。
    - 算法流程：初始化栈和索引值；遍历压栈数组(内外循环)；返回结果
      - 初始化： 辅助栈 stack ，弹出序列的索引 i ；
      - 遍历压栈序列： 各元素记为 num ；
        - 元素 num 入栈；
        - 循环出栈：若 stack 的栈顶元素 == 弹出序列元素 popped[i] ，则执行出栈与 i++ ；
      - 返回值： 若 stack 为空，则此弹出序列合法。
    - 复杂度：
      - 时间O(N), 空间O(N)
    - 注意：
      - 题目指出 pushed 是 popped 的排列 。因此，无需考虑 pushed 和 popped 长度不同 或 包含元素不同 的情况 
    
- ## 代码链接：
  - [验证栈序列](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0946-validate-stack-sequences.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->







### END
