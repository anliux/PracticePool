# 栈
- 内含题目：54

# 目录
<!-- GFM-TOC -->
* [20. 有效的括号](#20-有效的括号)
* [155. 最小栈](#155-最小栈)
* []()
* []()
* []()
* []()
* []()
<!-- GFM-TOC -->



# 20. 有效的括号
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。
  - ### 解题思路
    - 思路：暴力法；栈
    - 暴力法：
      - 每次检测是否有最里侧的成对某种括号，若有，则替换所有成对括号为空字符串，直到检测不到相邻的成对括号
      - 遍历完成后，如果是有效表达式，则最后的字符串会只剩下空串，判断是否==空串
    - 栈：
      - 初始化哈希表 char型
      - 初始化栈 char型
      - 遍历字符串，每次对遍历到的字符进行判断
        - 压栈：遇到开括号，将其推到栈上。
        - 弹栈：否则，当栈非空，且当前字符串的字符与栈顶元素配对成功时，弹栈
        - 无效：否则，表达式无效。
      - 最后，若栈非空，则表达式无效。
      
- ## 代码链接：
  - [有效的括号](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0020-valid-parentheses.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->




# 155. 最小栈
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。
    - push(x) -- 将元素 x 推入栈中。
    - pop() -- 删除栈顶的元素。
    - top() -- 获取栈顶元素。
    - getMin() -- 检索栈中的最小元素。
  - ### 解题思路
    - 注：本题重点是getMin()，因此可以考虑借用现成栈实现，相当于重写功能
    - 思路：两个栈；一个栈；不借用栈
    - 两个栈：
      - 用两个栈，一个栈去保存正常的入栈出栈的值，另一个栈去存最小值，也就是用栈顶保存当前所有元素的最小值。
      - 存最小值的栈的具体操作流程如下：
        - 将第一个元素入栈。
        - 新加入的元素如果大于栈顶元素，那么新加入的元素就不处理。
        - 新加入的元素如果小于等于栈顶元素，那么就将新元素入栈。
        - 出栈元素不等于栈顶元素，不操作。
        - 出栈元素等于栈顶元素，那么就将栈顶元素出栈。
    - 一个栈：
      - 只用一个变量去保存最小值，这时的关键是：如何保留最小值的记录（如果最小值弹出了，就会用到历史的最小值）
      - 解决：当有更小的值来的时候，只需要把之前的最小值入栈，当前更小的值再入栈即可。当这个最小值要出栈的时候，下一个值便是之前的最小值了。
      - 注意：push()中的if判断需要包含等于：因为如果此时的x弹出，最小值仍是原来的那个。如果等于就不压栈，那么一旦弹出，原相等的最小值就没了。
        - 等于不会死循环，这里的push是库函数不是上面的push
    
- ## 代码链接:
  - [最小栈](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0155-min-stack.java)
   
<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->






### END
