# 数学
- 内含题目：167


# 目录
<!-- GFM-TOC -->
* [2. 两数相加](#2-两数相加)
* [7. 整数反转](#7-整数反转)
* [8. 字符串转换整数atoi](#8-字符串转换整数atoi)
* [9. 回文数](#9-回文数)
* [12. 整数转罗马数字](#12-整数转罗马数字)
* [13. 罗马数字转整数](#13-罗马数字转整数)
* [67. 二进制求和](#67-二进制求和)
* [69. x的平方根](#69-x的平方根)
* [168. Excel表列名称](#168-excel表列名称)
* [171. Excel表列序号](#171-excel表列序号)
* [172. 阶乘后的零](#172-阶乘后的零)
* []()
* []()
* []()
* []()
* []()
* [836. 矩形重叠](#836-矩形重叠)
* []()
* []()
* [1103. 分糖果II](#1103-分糖果ii)
* []()
* []()
<!-- GFM-TOC -->



# 2. 两数相加
- ## 简述：（[medium](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium.md)）
  - ### 题目描述
    - 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。
    - 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
    - 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
    - 示例：输入：(2 -> 4 -> 3) + (5 -> 6 -> 4), 输出：7 -> 0 -> 8, 原因：342 + 465 = 807
  - ### 解题思路
    - 思路：模拟初等数学的加法运算
    - 分析：
      - 非空链表按照逆序，同初等数学加法计算从低位到高位，根据示例，结果也是逆序，最后不用反转；
      - 进位：两个数字相加（考虑到进位）可能出现的最大和为 9+9+1=19 ，使用变量carry来跟踪进位，并将carry带入下一次迭代；
      - 结果返回一个额外的链表，因此定义一个链表res来存储每一位，最后返回res.next
      - 边界情况：两链表长度不同；一链表为空；两链表最后一位仍然有进位..等等。
    - 算法：
      - 定义res链表结点并初始化，定义三个结点p，q，cur追踪两链表的移动和res链表的当前位置，定义进位carry
      - 循环直到两链表均为空:
        - 定义变量存储当前结点对应的值val，存储前需要判断当前结点是否为null，为空时返回0，可以用三目运算符；
        - 定义sum和将上述变量和进位carry的和，并整除计算进位carry；
        - 将整除取余结果存入新建结点并赋值给cur.next，然后将cur向后移动；
        - 判断p，q结点是否为空，不为空时p，q结点向后移动。
      - 循环结束后，判断最高位是否仍有进位，即carry是否大于0
      - 返回res.next链表
    - 链表知识点：
      - 新建链表结点：`ListNode dummyHead = new ListNode(0);`
    
- ## 代码链接：
  - [两数相加](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0002-add-two-numbers.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 7. 整数反转
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。
    - 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,2^31−1]。请根据这个假设，如果反转后整数溢出那么就返回 0。
  - ### 解题思路
    - 思路：使用数学方法取单个位，并重新组合；注意题目的临界条件。
    - 没有辅助堆栈/数组的帮助下 “弹出” 和 “推入” 数字，使用数学方法: 整除取余获得最低位数字，整除获得除去最低位外的数字
    - 只能存储得下32位的有符号整数，则其数值范围为 [−2^31,2^31−1]，在`temp=rev*10 + pop;`这一步容易越界，应事先判断
    
- ## 代码链接：
  - [整数反转](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0007-reverse-integer.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 8. 字符串转换整数atoi
- ## 简述：（[medium](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium.md)）
  - ### 题目描述
    - 请你来实现一个 atoi 函数，使其能将字符串转换成整数。
    - 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。
    - 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。
    - 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。
    - 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。
    - 在任何情况下，若函数不能进行有效的转换时，请返回 0。
    - 说明：
    - 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,2^31−1]。如果数值超过这个范围，请返回INT_MAX(2^31−1)或INT_MIN (−2^31) 。
    - 示例 1: 输入: "42"，输出: 42
    - 示例 2: 输入: "   -42"，输出: -42.
      - 解释: 第一个非空白字符为 '-', 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
    - 示例 3: 输入: "4193 with words"，输出: 4193.
      - 解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。
    - 示例 4: 输入: "words and 987"，输出: 0.
      - 解释: 第一个非空字符是 'w', 但它不是数字或正、负号。因此无法执行有效的转换。
    - 示例 5: 输入: "-91283472332"，输出: -2147483648。
      - 解释: 数字 "-91283472332" 超过 32 位有符号整数范围。因此返回 INT_MIN (−2^31) 。
  - ### 解题思路
    - 思路：正则和非正则。
      - 非正则的话，本题就是考虑多种不同的边界情况然后用一堆if-else来完成，同时面向测试用例编程来完善代码；
      - 正则表达式解题：更快更简洁，但是不熟练。这里贴代码和思路。
    - 关键：本题需要考虑的情况比较多，要非常细心。例如测试题目所列情况以及下列情况：
      - "    -42" --> -42；" + 413" --> 0；"0-1" --> 0；"- 234" -- > 0；"-2147483648" --> -2147483648；"+1" --> 1等
    - 非正则：
      - 函数返回值是int型，在任何情况下，不能进行有效的转换时都返回 0；
      - 从非空格字符开始算起：`str.trim()`剪去空格
        - str.trim() ：返回字符串的副本，忽略前导空白和尾部空白；如果字符串是空串，则返回str。
      - 判空：字符串为null，或者字符串长度为0时返回 0；
      - 定义结果变量res=0，起始位start=0；
      - 取第一个字符并赋值给firstChar
      - 考虑结果的符号正负：定义符号变量sign=1，然后判断firstChar是否是正负号中的一个，如果不是，不操作，继续后续步骤；
      - 循环：遍历字符串直到末尾，同时逐个取字符进行判断
        - 如果不是数字，就结束循环并返回结果：`Character.isDigit(j)==false`时`return (int) res * sign;`
        - 将第i个字符转为数字并赋值给变量：`pop = str.charAt(i) - '0';`
        - 为防止溢出，对res的值进行越界判断：sign为1时，以及为-1时，分类讨论
        - 排除各种异常情况后，计算res的值：`res = (int) res*10 + pop;`
      - 循环结束后返回`return res * sign;`
      - 注：越界判断参考<easy-7题>
        - 对于正数部分：
          - 考虑常规：`rev > Integer.MAX_VALUE/10` 时，rev * 10 必定大于Integer的Max值，不符合条件
          - 考虑临界：`rev == Integer.MAX_VALUE / 10` 时，整除会削去个位的值，因此，若再乘以10，个位是0。这时再加某值，这个值需要小于MAX值的个位，否则越界。因此：`pop > Integer.MAX_VALUE % 10`
        - 对于负数部分：因为sign符号是return的时候再添加的，所以需要rev和pop在此处写为-rev和-pop
          - 同理：`rev < Integer.MIN_VALUE / 10， 以及 rev == Integer.MIN_VALUE / 10 && x < Integer.MIN_VALUE % 10`
    - 正则：
      - 参考题解评论区大佬的代码实现，虽然简洁但是奈何不会啊....
    - 正则表达式知识点：
      - 参考[菜鸟教程-正则表达式](https://www.runoob.com/java/java-regular-expressions.html)
      - `^[\\+\\-]?\\d+`
      - `^ 表示匹配字符串开头，我们匹配的就是 '+'  '-'  号`
      - `[] 表示匹配包含的任一字符，比如[0-9]就是匹配数字字符 0 - 9 中的一个`
      - `? 表示前面一个字符出现零次或者一次，这里用 ? 是因为 '+' 号可以省略`
      - `\\d 表示一个数字 0 - 9 范围`
      - `+ 表示前面一个字符出现一次或者多次，\\d+ 合一起就能匹配一连串数字了`

- ## 代码链接：
  - [字符串转换整数atoi](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0008-string-to-integer-atoi.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 9. 回文数
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
  - ### 解题思路
    - 回文数：即反转之后与原数值相等
    - 改进：为防止溢出，考虑只反转一半，并与原始数值比较
    - 临界：负数，0，个位是0但本身非0，奇数位数的数字，偶数位数的数字
    - 判停：当剩余x不再大于反转数字rev时，表示已经反转到一半（等于为数字0的情况，不包含在循环中）
    
- ## 代码链接：
  - [回文数](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0009-palindrome-number.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 12. 整数转罗马数字
- ## 简述：（[medium](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium.md)）
  - ### 题目描述
    - 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。
    - 对应关系：I: 1; V: 5; X: 10; L: 50; C: 100; D: 500; M: 1000
    - 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
    - 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
      - I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
      - X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
      - C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
    - 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。
      - 示例 1: 输入: 3，输出: "III"
      - 示例 2: 输入: 4，输出: "IV"
      - 示例 3: 输入: 9，输出: "IX"
      - 示例 4: 输入: 58，输出: "LVIII"。解释: L = 50, V = 5, III = 3.
      - 示例 5: 输入: 1994，输出: "MCMXCIV"。解释: M = 1000, CM = 900, XC = 90, IV = 4.
  - ### 解题思路
    - 思路：贪心；哈希表。
      - 贪心的思想，哈希表的方法。
    - 参考<easy-13. 罗马数字转整数>，是本题的逆向，使用了查表发和相邻字符比较。
    - 分析：
      - 类型找零，用最少张数的纸币凑够所需的值，从最大的面值开始凑起。
      - 贪心或者哈希表法，都是围绕这一核心。其中哈希表可以用数组构建表的查表法替代。
      - 本题“整数转罗马数字”也有贪心类似的思想：
        - 在表示一个较大整数的时候，“罗马数字”的设计者不会让你都用 1 加起来；
        - 我们总是希望写出来的“罗马数字”的个数越少越好，以方便表示，并且这种表示方式还应该是唯一的。
      - 贪心算法的规则：每一步都使用当前较大的罗马数字作为加法因子，最后得到罗马数字表示就是长度最少的
      - 注意范围：int，且在 1 到 3999 的范围内。
    - 算法：
      - 复杂度：时间O(1)，空间O(1) -- 因为表的长度是有限的13个。
      - 首先：建表，使用两个数组模拟哈希表的键值对，一个数组values存放数字，一个数组strs存放数字对应的字母，数字按照从大到小的顺序；
        - 注意：strs数组赋值时，记得给字母加双引号。
      - 新建可变字符串StringBuilder，命名为res，用于存放转化为的字母；
      - 遍历数字数组：
        - 从头开始，整除结果quotient如果是0，continue直接结束本次循环并进入下一次循环；
        - 整除结果如果不是0，则对应到字符串数组中，并使用小循环将'商'次的对应字母添加到结果字符串；
        - 将num减去进行添加的`quotient * values[i]`；
        - 对num的值进行判断，为0时终止循环。
      - 返回结果：先转为String，然后返回。
      - 注意：对特殊值的处理是，将几个特殊值加入表中。

- ## 代码链接：
  - [整数转罗马数字](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0012-integer-to-roman.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->

  

# 13. 罗马数字转整数
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 要求：给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。
    - 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M，分别对应1,5,10,50,100,500,1000
    - 规则：通常情况下，罗马数字中小的数字在大的数字的右边。否则，用右边的大数减去左边的小数
  - ### 解题思路
    - 多个字符对应不同的数字，考虑“查表法”，可用哈希表 或者 “switch”
    - 比较相邻两个字符，若高位不小于低位，直接相加；否则，要用低位的大数减去高位的小数。
    - 将每位对应的数字累加：可以从高位到低位，即从字符串的0到length-1

- ## 代码链接：
  - [罗马数字转整数](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0013-roman-to-integer.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 67. 二进制求和
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定两个二进制字符串，返回他们的和（用二进制表示）。
    - 输入为非空字符串且只包含数字 1 和 0。
  - ### 解题思路
    - 思路：逐位计算（位运算的方法要考虑过多的细枝末节，这里不详述）
    - 补0使两字符串长度相等，然后从末尾开始遍历，并不断添加结果，最后对结果进行反转
      - 补0：在遍历过程中判断，长度小于0时直接返回0
      - 添加：需要在字符串上添加，因此使用可变字符串StrinBuilder
      - 反转：添加顺序是每次在右侧添加，即不断将较高位添加到右侧，因此最后需要反转
    - 定义可变字符串res，进位标志flag
    - 循环：从末尾开始，同时遍历两个字符串，并在两字符串均遍历至第一个元素时终止循环（双或）
    - 赋值sum=flag，并分别取a和b两字符串的最右位累加到sum
    - 用三目运算符在判断的同时得到sum的值，其中先判断i和j是否大于等于0为了补0，`a.charAt(i)-'0'`根据字符距离得到相应数值计算结果
    - 之后对所得sum值判断：取余得到添加结果，整除得到flag的值
    - 返回时需要对最后一次循环后flag的值进行判断，之后反转，并转为String型
    - 注：本代码好几处把几句代码合并到一句的
    
- ## 代码链接：
  - [二进制求和](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0067-add-binary.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 69. x的平方根
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 实现 int sqrt(int x) 函数。
    - 计算并返回 x 的平方根，其中 x 是非负整数。
    - 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
  - ### 解题思路
    - 思路：二分；牛顿迭代法
      - 注：二分是程序员的正常思路，牛顿迭代法是利用数学中的一个结论
      - 牛顿法是近似求根的经典方法，会更快
    - 二分：
      - 复杂度：时间O(logn), 空间O(1)
      - 当 x≥2 时，它的整数平方根一定小于 x/2 且大于 0，即 0<a<x/2。由于 a 一定是整数，此问题转换成在有序整数集中寻找一个特定值
      - 用二分查找的思想不断取中间值并比较，最终逼近结果
    - 牛顿迭代法：
      - 复杂度：时间O(logn), 空间O(1)
      - 一种在实数域和复数域上近似求解方程的方法
      - 求开平方，即求c(c>=0)的算术平方根，等同于求f(x)=x^2-c的正根，得迭代公式x(n+1) = 0.5 * ( x(n) + c/x(n) )
      - 本题向下取整，x(i+1)-x(i)的误差控制在1以内，最后当误差小于 1 时结束迭代。

- ## 代码链接：
  - [x的平方根](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0069-sqrtx.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 168. Excel表列名称
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个正整数，返回它在 Excel 表中相对应的列名称。
    - 例如：1 -> A，2 -> B，3 -> C，... 26 -> Z， 27 -> AA，28 -> AB ，  ...
  - ### 解题思路
    - 这道题看做是进制转换问题的变形，思考时参照十进制转二进制的除法与取余数运算。
      - eg. 十进制转二进制时，原数整除2，先取余数得到第一个结果，后对上一步所得商（即上一步整除结果）再次整除2并取余得到第二个结果..
    - 区别就在于题目规定的数字中没有 0 ，换句话讲，正常的 26 进制本应该满 26 进 1，然后低位补 0，但是这里满 26 的话就用 26 表示。满 27 的时候才会向前进 1，然后低位补 1。所以 Z(26) 的下一个数字就是 A(1)A(1)，即 27 对应 AA。
    - 关键：n--，将本题的1-26的范围修正为
    - 算法：判空：非正返回空字符串；定义可变字符串；循环：；最后反转，转为String类型并返回。

- ## 代码链接:
  - [Excel表列名称](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0168-excel-sheet-column-title.java)
  
<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 171. Excel表列序号
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个Excel表格中的列名称，返回其相应的列序号。
    - 例如，A -> 1, B -> 2, C -> 3, ...,  Z -> 26, AA -> 27, AB -> 28, ...
  - ### 解题思路
    - 进制转换问题：其他进制转十进制。参考二进制转十进制的不断乘和加的方法。
    - 初始化结果ans = 0，遍历时将每个字母与A做减法，因为A表示1，所以减法后需要每个数加1，计算其代表的数值num = 字母 - ‘A’ + 1
    - 因为有26个字母，所以相当于26进制，每26个数则向前进一位，所以每遍历一位则ans = ans * 26 + num
    - 以ZY为例，Z的值为26，Y的值为25，则结果为26 * 26 + 25=701
    - 算法：初始化；遍历字符串：从高位到低位；返回结果。

- ## 代码链接:
  - [Excel表列序号](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0171-excel-sheet-column-number.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 172. 阶乘后的零
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个整数 n，返回 n! 结果尾数中零的数量。
    - 示例 1: 输入: 3，输出: 0。解释: 3! = 6, 尾数中没有零。
    - 示例 2: 输入: 5，输出: 1。解释: 5! = 120, 尾数中有 1 个零.
    - 说明: 你算法的时间复杂度应为 O(log n) 。
  - ### 解题思路
    - 思路：数学题
    - 本题是纯数学问题，需要挖掘数学规律然后通过代码实现。
    - 分析：
      - 阶乘是乘积的结果，而一个10可以得到一个0，10是2和5的乘积，即一组2和5可以得到一个10；
      - 2是所有偶数都有的，而5只有5的倍数才有，因此2因子的个数远大于5，即，只需要考虑有多少个5即可；
      - 计算5的个数：整除5取余为0时，计数器+1，整除，然后循环，直到n%5不再为0。复杂度较高。
      - 继续找规律：分析可知，1到n的乘数因子中，每隔5个出现一次5，因此n/5个数；
      - 进一步地：每隔25个数会出现两个5，即25=5*5。而每隔5个数已经计算过了，因此每隔25个数再多加一遍5，即n/25个数；
      - 同理，每隔5的i次方，会多加一遍5，即n/(5^i)个数
      - 按照5的次方计算时可能溢出，因此，采用对n更新的方法，计算一轮之后，n=n/5，类似次方的逆向，然后仍然按照5计算
    - 算法：定义计数器count并初始化为0；n为正时循环：n/5计算个数并计入count，之后更新n=n/5；返回计数器count。

- ## 代码链接:
  - [阶乘后的零](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0172-factorial-trailing-zeroes.java)  

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 836. 矩形重叠
- ## 简述：（[easy5](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy5.md)）
  - ### 题目描述
    - 矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。
    - 如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。
    - 给出两个矩形，判断它们是否重叠并返回结果。
    - 示例 1：
      - 输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]
      - 输出：true
    - 示例 2：
      - 输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]
      - 输出：false
    - 说明：
      - 两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。
      - 矩形中的所有坐标都处于 -10^9 和 10^9 之间。 
  - ### 解题思路
    - 思路：检查位置；检查区域
    - 检查位置：
      - 复杂度：时间O(1)，空间O(1)
      - 分析：
        - 考虑不重叠情况：四周，即一个矩阵在另一个矩阵的左侧，右侧，上侧，下侧
        - 代码体现为：
          - 左侧：`rec1[2] <= rec2[0]`；
          - 右侧：`rec1[0] >= rec2[2]`；
          - 上方：`rec1[1] >= rec2[3]`；
          - 下方：`rec1[3] <= rec2[1]`。
        - 将不重叠情况排除，剩余的就是重叠情况
      - 算法：
        - 直接return：将不重叠情况排除，剩余的就是重叠情况。
    - 检查区域：
      - 复杂度：时间O(1)，空间O(1)
      - 分析：
        - 如果两个矩形重叠，那么它们重叠的区域一定也是一个矩形；
        - 那么这代表了两个矩形与 x 轴平行的边（水平边）投影到 x 轴上时会有交集，与 y 轴平行的边（竖直边）投影到 y 轴上时也会有交集。
        - 因此，我们可以将问题看作一维线段是否有交集的问题。
        - 考虑分离情况来辅助理解重叠情况：
          - x轴：如果不重叠，那么左端点的最大值(即分离的大矩形的左端点)，会大于右端点的最小值(即分离的小矩形的右端点)
          - y轴：同理
          - 总结就是分离“min<max, 大的最小值(在小矩形里)小于小的最大值(在大矩形里)”，等于就是重合的情况。
        - 因此，重叠就是“min>max，大的最小值(小矩形)大于小的最大值(大矩形)”
        - 交集代码体现：
          - x轴：`min(rec1[2], rec2[2]) > max(rec1[0], rec2[0])`
          - y轴：`min(rec1[3], rec2[3]) > max(rec1[1], rec2[1])`
          - 考虑不重叠情况来辅助理解重叠情况。
        - 两个方向都有交集时，证明可以构成重叠区域，此时重叠。
          - 考虑两个方向都存在交集是因为如果一真一假，可能只是边界重合，但没有重叠。
      - 算法：
        - 直接return：两个方向都有交集时，返回true。

- ## 代码链接：
  - [矩形重叠](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0836-ectangle-overlap.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 914. 卡牌分组
- ## 简述：（[easy5](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy5.md)）
  - ### 题目描述
    - 给定一副牌，每张牌上都写着一个整数。
    - 此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：
      - 每组都有 X 张牌。
      - 组内所有的牌上都写着相同的整数。
      - 仅当你可选的 X >= 2 时返回 true。
    - 示例 1：
      - 输入：[1,2,3,4,4,3,2,1]，输出：true
      - 解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]
    - 示例 2：
      - 输入：[1,1,1,2,2,2,3,3]，输出：false
      - 解释：没有满足要求的分组。
    - 示例 3：
      - 输入：[1]，输出：false
      - 解释：没有满足要求的分组。
    - 示例 4：
      - 输入：[1,1]，输出：true
      - 解释：可行的分组是 [1,1]
    - 示例 5：
      - 输入：[1,1,2,2,2,2]，输出：true
      - 解释：可行的分组是 [1,1]，[2,2]，[2,2]
    - 提示：1 <= deck.length <= 10000，0 <= deck[i] < 10000
  - ### 解题思路
    - 思路：暴力法；最大公约数法。
      - 注：最大公约数法参考<leetcode-1071-字符串的最大公因子-easy>
    - 暴力法：
      - 复杂度：时间O(n^2)，空间O(n)
      - 分析：
        - 从 2 开始，从小到大枚举 X。
        - 由于每一组都有 X 张牌，那么 X 必须是卡牌总数 N 的约数。
        - 其次，对于写着数字 i 的牌，如果有 count i  张，那么 X 也必须是 count i 的约数，即：`count i modX==0`
        - 所以对于每一个 X，先判断 X 是否为 N 的约数，然后遍历所有牌中存在的数字 i，看它们对应牌的数量 count i  是否满足上述要求。
        - 如果都满足等式，则 X 为符合条件的解，否则需要继续令 X 增大，枚举下一个数字。
      - 算法：
        - 第一步：计数。
        - 定义数组长度N：即卡牌总数；
        - 模拟哈希表统计每个数字的出现次数：定义长10000的数组count，然后遍历数组deck并将元素值作为count数组索引值并自增1；
        - 第二步：统计数字个数。
        - 定义数组列表values，遍历count数组，并将count数组中所有大于0的元素添加到values数组列表；或依然用普通数组存储即可；
        - 第三步：遍历并判断。
        - 两层循环：外循环控制从2开始枚举的X(包括等于N)，内循环控制两个指标的取余，不符合时继续增加枚举，均符合时返回true，枚举到卡牌数N结束。
        - 注意：这里为了内循环控制外循环，给外循环做了标记，即for()前面的search表示外循环。
    - 最大公约数法：
      - 复杂度：时间O(NlogC)，空间O(N)
      - 分析：
        - 每种数字的卡牌张数必须是X的倍数（只有这样才能每X张牌分为1组，且每组牌的数字都相同), 且X>1。
        - 由此，本题转换成了求: 每种卡牌张数的最大公约数。
        - 只要求出所有 count i 最大公约数 g，判断 g 是否大于等于 2 即可，如果大于等于 2，则满足条件，否则不满足。
        - 最大公约数：辗转相除法，将除数和余数作为参数递归，直到余数为0时返回除数的值即为所求。
      - 算法：
        - 定义求最大公约数gcd的函数：将除数和余数作为新参数传入，并递归，直到余数为0，这时返回除数。
        - 首先定义计数数组，遍历原数组并求出每个数字出现的次数，并存入计数数组中；
        - 定义公约数变量g：
          - 注意：初始化为-1，并且在计数数组元素大于0时赋值，是为了绕过0，避免所有公约数都被计算为0，又保证了获取的是计数数组中的元素。
        - 遍历计数数组，并计算大于0的元素与公约数g的最大公约数；
        - 最后，判断g是否大于等于2，符合则返回true，否则返回false。
      
- ## 代码链接：
  - [卡牌分组](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0914-x-of-a-kind-in-a-deck-of-cards.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 1103. 分糖果II
- ## 简述：（[easy6](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy6.md)）
  - ### 题目描述
    - 我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。
    - 给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。
    - 然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。
    - 重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。
    - 注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。
    - 返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。
    - 示例 1：输入：candies = 7, num_people = 4; 输出：[1,2,3,1]
      - 第一次，ans[0] += 1，数组变为 [1,0,0,0]。
      - 第二次，ans[1] += 2，数组变为 [1,2,0,0]。
      - 第三次，ans[2] += 3，数组变为 [1,2,3,0]。
      - 第四次，ans[3] += 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。
    - 示例 2：输入：candies = 10, num_people = 3; 输出：[5,2,3]
      - 第一次，ans[0] += 1，数组变为 [1,0,0]。
      - 第二次，ans[1] += 2，数组变为 [1,2,0]。
      - 第三次，ans[2] += 3，数组变为 [1,2,3]。
      - 第四次，ans[0] += 4，最终数组变为 [5,2,3]。
    - 提示：1 <= candies <= 10^9; 1 <= num_people <= 1000
  - ### 解题思路
    - 思路：暴力法；数学
    - 暴力法：
      - 复杂度：时间O(sqrt(m),n)，空间O(1) -- m为糖果数，n为人数
      - 暴力法：一遍又一遍地遍历人数
      - 不断地遍历数组，如果还有糖就一直分，直到没有糖为止。
      - 优雅暴力：规划好循环；善用取余调转起始；Math.min()控制糖果数不足的情况。
    - 数学：
      - 复杂度：时间O(n)，空间O(1)
      - 数学法：遍历一次人数
      - 找到每个人可获得的糖果数的公式，直接遍历一遍人数并求得值存入结果数组
      - 具体过程: [本题官方题解](https://leetcode-cn.com/problems/distribute-candies-to-people/solution/fen-tang-guo-ii-by-leetcode-solution/)
      - 注：数学方法时间复杂度低，但是推导过程过于复杂，看了一半没有再继续了。以后吧...
    
- ## 代码链接：
  - [分糖果II](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/1103-distribute-candies-to-people.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->






### END
