# 数学
- 内含题目：167

# 目录
<!-- GFM-TOC -->
* [7. 整数反转](#7-整数反转)
* [9. 回文数](#9-回文数)
* [13. 罗马数字转整数](#13-罗马数字转整数)
* [67. 二进制求和](#67-二进制求和)
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
<!-- GFM-TOC -->



# 7. 整数反转
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。
    - 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,2^31−1]。请根据这个假设，如果反转后整数溢出那么就返回 0。
  - ### 解题思路
    - 思路：使用数学方法取单个位，并重新组合；注意题目的临界条件。
    - 没有辅助堆栈/数组的帮助下 “弹出” 和 “推入” 数字，使用数学方法: 整除取余获得最低位数字，整数获得除去最低位外的数字
    - 只能存储得下32位的有符号整数，则其数值范围为 [−2^31,2^31−1]，在`temp=rev*10 + pop;`这一步容易越界，应事先判断
    
- ## 代码链接：
  - [整数反转](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0007-reverse-integer.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 9. 回文数
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
  - ### 解题思路
    - 回文数：即反转之后与原数值相等
    - 改进：为防止溢出，考虑只反转一半，并与原始数值比较
    - 临界：负数，0，个位是0但本身非0，奇数位数的数字，偶数位数的数字
    - 判停：当剩余x不再大于反转数字rev时，表示已经反转到一半（等于为数字0的情况，不包含在循环中）
    
- ## 代码链接：
  - [回文数](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0009-palindrome-number.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 13. 罗马数字转整数
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 要求：给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。
    - 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M，分别对应1,5,10,50,100,500,1000
    - 规则：通常情况下，罗马数字中小的数字在大的数字的右边。否则，用右边的大数减去左边的小数
  - ### 解题思路
    - 多个字符对应不同的数字，考虑“查表法”，可用哈希表 或者 “switch”
    - 比较相邻两个字符，若高位不小于低位，直接相加；否则，要用低位的大数减去高位的小数。
    - 将每位对应的数字累加：可以从高位到低位，即从字符串的0到length-1

- ## 代码链接：
  - [罗马数字转整数](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0013-roman-to-integer.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 67. 二进制求和
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定两个二进制字符串，返回他们的和（用二进制表示）。
    - 输入为非空字符串且只包含数字 1 和 0。
  - ### 解题思路
    - 思路：逐位计算（位运算的方法要考虑过多的细枝末节，这里不详述）
    - 补0使两字符串长度相等，然后从末尾开始遍历，并不断添加结果，最后对结果进行反转
      - 补0：在遍历过程中判断，长度小于0时直接返回0
      - 添加：需要在字符串上添加，因此使用可变字符串StrinBuilder
      - 反转：添加顺序是每次在右侧添加，即不断将较高位添加到右侧，因此最后需要反转
    - 定义可变字符串res，进位标志flag
    - 循环：从末尾开始，同时遍历两个字符串，并在两字符串均遍历至第一个元素时终止循环（双或）
    - 赋值sum=flag，并分别取a和b两字符串的最右位累加到sum
    - 用三目运算符在判断的同时得到sum的值，其中先判断i和j是否大于等于0为了补0，`a.charAt(i)-'0'`根据字符距离得到相应数值计算结果
    - 之后对所得sum值判断：取余得到添加结果，整除得到flag的值
    - 返回时需要对最后一次循环后flag的值进行判断，之后反转，并转为String型
    - 注：本代码好几处把几句代码合并到一句的
    
- ## 代码链接：
  - [二进制求和](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0067-add-binary.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



#








### END
