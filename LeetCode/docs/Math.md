# 数学
- 内含题目：167


# 目录
<!-- GFM-TOC -->
* [2. 两数相加](#2-两数相加)
* [7. 整数反转](#7-整数反转)
* [8. 字符串转换整数atoi](#8-字符串转换整数atoi)
* [9. 回文数](#9-回文数)
* [13. 罗马数字转整数](#13-罗马数字转整数)
* [67. 二进制求和](#67-二进制求和)
* [69. x的平方根](#69-x的平方根)
* [168. Excel表列名称](#168-excel表列名称)
* [171. Excel表列序号](#171-excel表列序号)
* [172. 阶乘后的零](#172-阶乘后的零)
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
<!-- GFM-TOC -->



# 2. 两数相加
- ## 简述：（[medium](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium.md)）
  - ### 题目描述
    - 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。
    - 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
    - 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
    - 示例：输入：(2 -> 4 -> 3) + (5 -> 6 -> 4), 输出：7 -> 0 -> 8, 原因：342 + 465 = 807
  - ### 解题思路
    - 思路：模拟初等数学的加法运算
    - 分析：
      - 非空链表按照逆序，同初等数学加法计算从低位到高位，根据示例，结果也是逆序，最后不用反转；
      - 进位：两个数字相加（考虑到进位）可能出现的最大和为 9+9+1=19 ，使用变量carry来跟踪进位，并将carry带入下一次迭代；
      - 结果返回一个额外的链表，因此定义一个链表res来存储每一位，最后返回res.next
      - 边界情况：两链表长度不同；一链表为空；两链表最后一位仍然有进位..等等。
    - 算法：
      - 定义res链表结点并初始化，定义三个结点p，q，cur追踪两链表的移动和res链表的当前位置，定义进位carry
      - 循环直到两链表均为空:
        - 定义变量存储当前结点对应的值val，存储前需要判断当前结点是否为null，为空时返回0，可以用三目运算符；
        - 定义sum和将上述变量和进位carry的和，并整除计算进位carry；
        - 将整除取余结果存入新建结点并赋值给cur.next，然后将cur向后移动；
        - 判断p，q结点是否为空，不为空时p，q结点向后移动。
      - 循环结束后，判断最高位是否仍有进位，即carry是否大于0
      - 返回res.next链表
    - 链表知识点：
      - 新建链表结点：`ListNode dummyHead = new ListNode(0);`
    
- ## 代码链接：
  - [两数相加](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0002-add-two-numbers.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 7. 整数反转
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。
    - 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,2^31−1]。请根据这个假设，如果反转后整数溢出那么就返回 0。
  - ### 解题思路
    - 思路：使用数学方法取单个位，并重新组合；注意题目的临界条件。
    - 没有辅助堆栈/数组的帮助下 “弹出” 和 “推入” 数字，使用数学方法: 整除取余获得最低位数字，整除获得除去最低位外的数字
    - 只能存储得下32位的有符号整数，则其数值范围为 [−2^31,2^31−1]，在`temp=rev*10 + pop;`这一步容易越界，应事先判断
    
- ## 代码链接：
  - [整数反转](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0007-reverse-integer.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 8. 字符串转换整数atoi
- ## 简述：（[medium](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium.md)）
  - ### 题目描述
    - 请你来实现一个 atoi 函数，使其能将字符串转换成整数。
    - 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。
    - 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。
    - 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。
    - 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。
    - 在任何情况下，若函数不能进行有效的转换时，请返回 0。
    - 说明：
    - 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,2^31−1]。如果数值超过这个范围，请返回INT_MAX(2^31−1)或INT_MIN (−2^31) 。
    - 示例 1: 输入: "42"，输出: 42
    - 示例 2: 输入: "   -42"，输出: -42.
      - 解释: 第一个非空白字符为 '-', 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
    - 示例 3: 输入: "4193 with words"，输出: 4193.
      - 解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。
    - 示例 4: 输入: "words and 987"，输出: 0.
      - 解释: 第一个非空字符是 'w', 但它不是数字或正、负号。因此无法执行有效的转换。
    - 示例 5: 输入: "-91283472332"，输出: -2147483648。
      - 解释: 数字 "-91283472332" 超过 32 位有符号整数范围。因此返回 INT_MIN (−2^31) 。
  - ### 解题思路
    - 思路：正则和非正则。
      - 非正则的话，本题就是考虑多种不同的边界情况然后用一堆if-else来完成，同时面向测试用例编程来完善代码；
      - 正则表达式解题：更快更简洁，但是不熟练。这里贴代码和思路。
    - 关键：本题需要考虑的情况比较多，要非常细心。例如测试题目所列情况以及下列情况：
      - "    -42" --> -42；" + 413" --> 0；"0-1" --> 0；"- 234" -- > 0；"-2147483648" --> -2147483648；"+1" --> 1等
    - 非正则：
      - 函数返回值是int型，在任何情况下，不能进行有效的转换时都返回 0；
      - 从非空格字符开始算起：`str.trim()`剪去空格
        - str.trim() ：返回字符串的副本，忽略前导空白和尾部空白；如果字符串是空串，则返回str。
      - 判空：字符串为null，或者字符串长度为0时返回 0；
      - 定义结果变量res=0，起始位start=0；
      - 取第一个字符并赋值给firstChar
      - 考虑结果的符号正负：定义符号变量sign=1，然后判断firstChar是否是正负号中的一个，如果不是，不操作，继续后续步骤；
      - 循环：遍历字符串直到末尾，同时逐个取字符进行判断
        - 如果不是数字，就结束循环并返回结果：`Character.isDigit(j)==false`时`return (int) res * sign;`
        - 将第i个字符转为数字并赋值给变量：`pop = str.charAt(i) - '0';`
        - 为防止溢出，对res的值进行越界判断：sign为1时，以及为-1时，分类讨论
        - 排除各种异常情况后，计算res的值：`res = (int) res*10 + pop;`
      - 循环结束后返回`return res * sign;`
      - 注：越界判断参考<easy-7题>
        - 对于正数部分：
          - 考虑常规：`rev > Integer.MAX_VALUE/10` 时，rev * 10 必定大于Integer的Max值，不符合条件
          - 考虑临界：`rev == Integer.MAX_VALUE / 10` 时，整除会削去个位的值，因此，若再乘以10，个位是0。这时再加某值，这个值需要小于MAX值的个位，否则越界。因此：`pop > Integer.MAX_VALUE % 10`
        - 对于负数部分：因为sign符号是return的时候再添加的，所以需要rev和pop在此处写为-rev和-pop
          - 同理：`rev < Integer.MIN_VALUE / 10， 以及 rev == Integer.MIN_VALUE / 10 && x < Integer.MIN_VALUE % 10`
    - 正则：
      - 参考题解评论区大佬的代码实现，虽然简洁但是奈何不会啊....
    - 正则表达式知识点：
      - 参考[菜鸟教程-正则表达式](https://www.runoob.com/java/java-regular-expressions.html)
      - `^[\\+\\-]?\\d+`
      - `^ 表示匹配字符串开头，我们匹配的就是 '+'  '-'  号`
      - `[] 表示匹配包含的任一字符，比如[0-9]就是匹配数字字符 0 - 9 中的一个`
      - `? 表示前面一个字符出现零次或者一次，这里用 ? 是因为 '+' 号可以省略`
      - `\\d 表示一个数字 0 - 9 范围`
      - `+ 表示前面一个字符出现一次或者多次，\\d+ 合一起就能匹配一连串数字了`

- ## 代码链接：
  - [字符串转换整数atoi](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0008-string-to-integer-atoi.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 9. 回文数
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
  - ### 解题思路
    - 回文数：即反转之后与原数值相等
    - 改进：为防止溢出，考虑只反转一半，并与原始数值比较
    - 临界：负数，0，个位是0但本身非0，奇数位数的数字，偶数位数的数字
    - 判停：当剩余x不再大于反转数字rev时，表示已经反转到一半（等于为数字0的情况，不包含在循环中）
    
- ## 代码链接：
  - [回文数](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0009-palindrome-number.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 13. 罗马数字转整数
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 要求：给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。
    - 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M，分别对应1,5,10,50,100,500,1000
    - 规则：通常情况下，罗马数字中小的数字在大的数字的右边。否则，用右边的大数减去左边的小数
  - ### 解题思路
    - 多个字符对应不同的数字，考虑“查表法”，可用哈希表 或者 “switch”
    - 比较相邻两个字符，若高位不小于低位，直接相加；否则，要用低位的大数减去高位的小数。
    - 将每位对应的数字累加：可以从高位到低位，即从字符串的0到length-1

- ## 代码链接：
  - [罗马数字转整数](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0013-roman-to-integer.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 67. 二进制求和
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定两个二进制字符串，返回他们的和（用二进制表示）。
    - 输入为非空字符串且只包含数字 1 和 0。
  - ### 解题思路
    - 思路：逐位计算（位运算的方法要考虑过多的细枝末节，这里不详述）
    - 补0使两字符串长度相等，然后从末尾开始遍历，并不断添加结果，最后对结果进行反转
      - 补0：在遍历过程中判断，长度小于0时直接返回0
      - 添加：需要在字符串上添加，因此使用可变字符串StrinBuilder
      - 反转：添加顺序是每次在右侧添加，即不断将较高位添加到右侧，因此最后需要反转
    - 定义可变字符串res，进位标志flag
    - 循环：从末尾开始，同时遍历两个字符串，并在两字符串均遍历至第一个元素时终止循环（双或）
    - 赋值sum=flag，并分别取a和b两字符串的最右位累加到sum
    - 用三目运算符在判断的同时得到sum的值，其中先判断i和j是否大于等于0为了补0，`a.charAt(i)-'0'`根据字符距离得到相应数值计算结果
    - 之后对所得sum值判断：取余得到添加结果，整除得到flag的值
    - 返回时需要对最后一次循环后flag的值进行判断，之后反转，并转为String型
    - 注：本代码好几处把几句代码合并到一句的
    
- ## 代码链接：
  - [二进制求和](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0067-add-binary.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 69. x的平方根
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 实现 int sqrt(int x) 函数。
    - 计算并返回 x 的平方根，其中 x 是非负整数。
    - 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
  - ### 解题思路
    - 思路：二分；牛顿迭代法
      - 注：二分是程序员的正常思路，牛顿迭代法是利用数学中的一个结论
      - 牛顿法是近似求根的经典方法，会更快
    - 二分：
      - 复杂度：时间O(logn), 空间O(1)
      - 当 x≥2 时，它的整数平方根一定小于 x/2 且大于 0，即 0<a<x/2。由于 a 一定是整数，此问题转换成在有序整数集中寻找一个特定值
      - 用二分查找的思想不断取中间值并比较，最终逼近结果
    - 牛顿迭代法：
      - 复杂度：时间O(logn), 空间O(1)
      - 一种在实数域和复数域上近似求解方程的方法
      - 求开平方，即求c(c>=0)的算术平方根，等同于求f(x)=x^2-c的正根，得迭代公式x(n+1) = 0.5 * ( x(n) + c/x(n) )
      - 本题向下取整，x(i+1)-x(i)的误差控制在1以内，最后当误差小于 1 时结束迭代。

- ## 代码链接：
  - [x的平方根](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0069-sqrtx.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 168. Excel表列名称
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个正整数，返回它在 Excel 表中相对应的列名称。
    - 例如：1 -> A，2 -> B，3 -> C，... 26 -> Z， 27 -> AA，28 -> AB ，  ...
  - ### 解题思路
    - 这道题看做是进制转换问题的变形，思考时参照十进制转二进制的除法与取余数运算。
      - eg. 十进制转二进制时，原数整除2，先取余数得到第一个结果，后对上一步所得商（即上一步整除结果）再次整除2并取余得到第二个结果..
    - 区别就在于题目规定的数字中没有 0 ，换句话讲，正常的 26 进制本应该满 26 进 1，然后低位补 0，但是这里满 26 的话就用 26 表示。满 27 的时候才会向前进 1，然后低位补 1。所以 Z(26) 的下一个数字就是 A(1)A(1)，即 27 对应 AA。
    - 关键：n--，将本题的1-26的范围修正为
    - 算法：判空：非正返回空字符串；定义可变字符串；循环：；最后反转，转为String类型并返回。

- ## 代码链接:
  - [Excel表列名称](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0168-excel-sheet-column-title.java)
  
<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 171. Excel表列序号
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个Excel表格中的列名称，返回其相应的列序号。
    - 例如，A -> 1, B -> 2, C -> 3, ...,  Z -> 26, AA -> 27, AB -> 28, ...
  - ### 解题思路
    - 进制转换问题：其他进制转十进制。参考二进制转十进制的不断乘和加的方法。
    - 初始化结果ans = 0，遍历时将每个字母与A做减法，因为A表示1，所以减法后需要每个数加1，计算其代表的数值num = 字母 - ‘A’ + 1
    - 因为有26个字母，所以相当于26进制，每26个数则向前进一位，所以每遍历一位则ans = ans * 26 + num
    - 以ZY为例，Z的值为26，Y的值为25，则结果为26 * 26 + 25=701
    - 算法：初始化；遍历字符串：从高位到低位；返回结果。

- ## 代码链接:
  - [Excel表列序号](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0171-excel-sheet-column-number.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 172. 阶乘后的零
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个整数 n，返回 n! 结果尾数中零的数量。
    - 示例 1: 输入: 3，输出: 0。解释: 3! = 6, 尾数中没有零。
    - 示例 2: 输入: 5，输出: 1。解释: 5! = 120, 尾数中有 1 个零.
    - 说明: 你算法的时间复杂度应为 O(log n) 。
  - ### 解题思路
    - 思路：数学题
    - 本题是纯数学问题，需要挖掘数学规律然后通过代码实现。
    - 分析：
      - 阶乘是乘积的结果，而一个10可以得到一个0，10是2和5的乘积，即一组2和5可以得到一个10；
      - 2是所有偶数都有的，而5只有5的倍数才有，因此2因子的个数远大于5，即，只需要考虑有多少个5即可；
      - 计算5的个数：整除5取余为0时，计数器+1，整除，然后循环，直到n%5不再为0。复杂度较高。
      - 继续找规律：分析可知，1到n的乘数因子中，每隔5个出现一次5，因此n/5个数；
      - 进一步地：每隔25个数会出现两个5，即25=5*5。而每隔5个数已经计算过了，因此每隔25个数再多加一遍5，即n/25个数；
      - 同理，每隔5的i次方，会多加一遍5，即n/(5^i)个数
      - 按照5的次方计算时可能溢出，因此，采用对n更新的方法，计算一轮之后，n=n/5，类似次方的逆向，然后仍然按照5计算
    - 算法：定义计数器count并初始化为0；n为正时循环：n/5计算个数并计入count，之后更新n=n/5；返回计数器count。

- ## 代码链接:
  - [阶乘后的零](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0172-factorial-trailing-zeroes.java)  

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->




### END
