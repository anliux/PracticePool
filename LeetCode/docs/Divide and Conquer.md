# 分治算法
- 内含题目：19

# 目录
<!-- GFM-TOC -->
* [53. 最大子序和](#53-最大子序和)
* [169. 多数元素](#169-多数元素)
* []()
* [240. 搜索二维矩阵II](#240-搜索二维矩阵ii)
* []()
* []()
<!-- GFM-TOC -->



# 53. 最大子序和
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
    - 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6
      - 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
    - 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。
  - ### 解题思路
    - 思路：暴力法；动态规划；贪心；分治
    - 暴力法：
      - 复杂度：时间O(N^2)，空间O(1)
      - 寻找所有的可能子序和，并求最大值
      - 首先定义并初始化max为数组第一个元素
      - 按照一定规律遍历数组，比如从i开始遍历到末尾，不断取和，比较并取max，然后i++
      - 两层循环：外循环控制开始的i值，内循环控制在i索引开始，形成的子序列
    - 贪心：
      - 复杂度：时间O(n)，空间O(1)
      - 从左向右遍历，一个个数累加；当sum<0，重新开始找子序列
        - 所求最大值max可由if判断语句比较得到，也可由Math.max(i,j)直接求得
        - sum初始化为0，小于0的sum说明累加后比初始值更小了
        - "重新找"指的是：sum归0， 并从下一个元素起，重新累加
    - 动态规划：
      - 复杂度：时间O(n), 空间O(n)，可优化到O(1)
        - 只用到dp数组中的前一项，因此可以用int代替一维数组，对空间复杂度优化
      - dp[i]: nums中，以nums[i]结尾的最大子序和
      - dp[i]=max(dp[i-1]+nums[i], nums[i]);
    - 分治：
      - 复杂度：时间O(nlogn)，空间O(logn)
      - 取数组的中心点为中心，那么最大子序列要么在中心左，要么在右，要么跨中心
      - 分三种情况进行考虑
      - 跨中心的情况，又可以分治中心点左侧和右侧的最大子序列问题
      - 注：对比以上思路，分治的思路过于复杂，不详细分析了。
    - 注：
      - 类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值`max=Integer.MIN_VALUE;`
      - Integer是java.lang包下的，自动导入不用再手写import
      - Math是java.lang包下的，不用再手写import
      - 本题可以定义max为数组第一个元素，因为只是累加计算
 
- ## 代码链接：
  - [最大子序和](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0053-maximum-subarray.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 169. 多数元素
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。
    - 你可以假设数组是非空的，并且给定的数组总是存在多数元素。
  - ### 解题思路
    - 思路：暴力法；哈希表法；排序；分治；投票..
    - 暴力法：
      - 复杂度：时间O(n^2)，空间O(1)
      - 暴力算法遍历整个数组，然后用另一重循环统计每个数字出现的次数。将出现次数比其他数字加起来出现次数还多的元素返回。
      - 算法：初始化n/2；双层循环：外层控制比较基准，内层统计与基准相同的个数，并在内层结束后与n/2比较；最后return任一int型，比如-1.
      - 不足：时间复杂度过高
    - 哈希表：
      - 复杂度：时间O(n)，空间O(n)
      - 使用哈希表来存储每个元素，然后用一个循环在线性时间内遍历 nums ，然后我们只需要返回有最大值的键。
      - 算法：
        - 新建哈希表；
        - 新建max值和次数的变量；
        - 遍历数组：第一次出现时count赋值为1，否则在哈希表中对应count基础上+1，每次判断count范围并更新max两个变量；
        - 返回max值。
      - HashMap知识点：
        - `getOrDefault(Object key, V defaultValue)` : 如果存在key返回对应的value，否则返回defaultValue
    - 排序：
      - 复杂度：时间O(nlogn)，空间O(1)
      - 如果所有数字被单调递增或者单调递减的顺序排了序，那么众数的下标为n/2
      - 算法：对数组排序；返回排序后的n/2索引对应的元素
    - 摩尔投票法：
      - 复杂度：时间O(n)，空间O(1)
      - 把众数记为 +1，把其他数记为 −1 ，将它们全部加起来，显然和大于 0 ，从结果本身我们可以看出众数比其他数多。
      - 算法：
        - 定义比较基准flag=nums[0]和计数器count=1；
        - 遍历数组：与基准相同+1，不同-1，且变为0时，更新基准为下一个索引对应的元素；
        - 返回最后计数器不为0的基准。
    - 注：有分治的方法，但是个人对分治不太熟悉，所以在有其他解法的情况下一般不考虑分治的方法。
    
- ## 代码链接:
  - [多数元素](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0169-majority-element.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->  



# 240. 搜索二维矩阵II
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
 - 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：
  - 每行的元素从左到右升序排列。每列的元素从上到下升序排列。
  - 示例: 现有矩阵 matrix 如下：给定 target = 5，返回 true; 给定 target = 20，返回 false。

```html
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
```

  - ### 解题思路
    - 思路：暴力法；线性查找。
    - 暴力法：忽略存在的顺序，直接暴力查找；时间复杂度高。
      - 复杂度：时间O(mn)，空间O(1)  -- m 为行数，n 为 列数。
    - 线性查找：
      - 复杂度：时间O(m+n)，空间O(1)  -- m 为行数，n 为 列数。
      - 关键：站在右上角看。这个矩阵其实就像是一个Binary Search Tree。
      - 分析：
        - 分析复杂问题：从一个具体的例子入手
        - 可以发现：该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。
        - 考虑从右上角或者左下角开始，可以避免可能选取区域重叠。
        - 右上角：左侧为小于，下侧为大于。若小，下移；若大，左移。
        - 测试用例考虑：有目标；没有目标（大于max，小于min，介于但不存在）；空指针；行列数非正
        - 空指针即地址为null，行列数非正，这两个需要排除。而没有目标中各种情况都属于找不到，返回false即可，无需特意判断。
      - 算法本质： 
        - 每轮 i 或 j 移动后，相当于生成了“消去一行（列）的新矩阵”， 索引(i,j) 指向新矩阵的左下角元素（标志数）
        - 因此可重复使用以上性质消去行（列）。
      - 算法：判空(如果定义了范围，可省略)；定义右上角行列索引值；遍历数组：范围内，大则左移，小则下移，否则返回true；最后返回false。
  
- ## 代码链接：
   - [二维数组中的查找](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0240-search-a-2d-matrix-ii.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#剑指offer题解目录)
<!-- GFM-TOC -->






<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->




### END
