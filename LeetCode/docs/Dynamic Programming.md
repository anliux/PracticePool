# 动态规划
- 内含题目：183

# 目录
<!-- GFM-TOC -->
* [5. 最长回文子串](#5-最长回文子串)
* [53. 最大子序和](#53-最大子序和)
* [70. 爬楼梯](#70-爬楼梯)
* [121. 买卖股票的最佳时机](#121-买卖股票的最佳时机)
* [198. 打家劫舍](#198-打家劫舍)
* [264. 丑数II](#264-丑数ii)
* [322. 零钱兑换](#322-零钱兑换)
* [343. 整数拆分](#343-整数拆分)
<!-- GFM-TOC -->



# 5. 最长回文子串
- ## 简述：（[medium](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium.md)）
  - ### 题目描述
    - 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
  - ### 解题思路
    - ### 思路：暴力匹配；动态规划；中心扩散；Manacher 算法。
      - “暴力匹配”是基础，“动态规划”必须掌握，“中心扩散” 要会写，“Manacher 算法”不用看
    - ### 暴力匹配：
      - 复杂度：O(n^3)，O(1)
      - 分析：
        - 根据回文子串的定义，枚举所有长度大于等于 2 的子串，依次判断它们是否是回文；
        - 在具体实现时，可以只针对大于“当前得到的最长回文子串长度”的子串进行“回文验证”；
        - 在记录最长回文子串的时候，可以只记录“当前子串的起始位置”和“子串长度”，不必做截取。
        - 暴力解法时间复杂度高，但是思路清晰、编写简单，可以作为基础来优化实现其他方法。
      - 算法：
        - 定义valid函数，用于判断left到right范围内的子串是否是回文串；
        - 主体函数中：边界值判断，字符串长度为0和1的直接返回s，即s.length()<2时；
        - 定义几个变量：最长子串的长度lens，最长子串结果res。字符串s可以用s.substring()截取；
        - 循环：两层遍历，外层控制起始基准，内层控制从基准开始到末尾的所有子串，并if进行判断并更新相应的变量数值；
        - 最内层if判断：如果当前子串的长度大于最长子串长度lens，并且valid为真，则更新lens，并将最长子串res更新为当前子串；
        - 循环结束后返回res。
      - 字符串相关知识点：
        - `substring(int beginIndex, int endIndex)` ：索引值左闭右开，返回一个新字符串，它是此字符串的一个子字符串。
        - `charAt(int index)` ：返回指定索引处的 char 值。
        - 注：substring是截取子串，charAt是返回字符串中的某一个字符，注意使用场景，以及返回值所存储到的变量的数据类型。
    - ### 动态规划：
      - 复杂度：O(n^2)，O(n^2)
        - 虽然以时间换空间，但是仍然需要两层循环来遍历整个字符串。
      - “动态规划”作为一种打表格法，是在用“空间”换“时间”。
      - 动态规划思考路径：状态？状态转移方程？初始化？输出？状态压缩？
      - 本题关键：
        - 在头尾字符相等的情况下，里面子串的回文性质据定了整个子串的回文性质，这就是状态转移。
        - 因此可以把“状态”定义为原字符串的一个子串是否为回文子串。
        - dp[i][j] 表示子串 s[i, j] 是否为回文子串。
        - 状态转移方程：`dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]`
        - i 和 j 的关系是 i <= j ，因此，只需要填这张表的一半；
        - 边界条件是：表达式 [i+1, j-1] 不构成区间，即长度严格小于2，即 j-1-(i+1)+1<2，整理得 j-i<3。
          - 显然：当子串 s[i, j] 的长度等于2或者等于3的时候，只需要判断一下头尾两个字符是否相等就可以直接下结论了。
        - 找到时，仅记录
      - 算法：
        - 定义字符串长度lens，方便后面使用；判断边界条件：lens<2时
        - 定义布尔型二维数组`dp[][]`，（注：不需要初始化对角线为true，因为控制好i和j区间，对角线用不到，经测试可以ac）
        - 定义int遍历maxlens和start，并初始化start=0，maxlens=1，而不是0，因为回文串长至少是1，例如"ac"，返回"a"；
        - 两层循环遍历全部数组，因为遍历中会用到dp[i+1][j-1]，要注意遍历的顺序(不是常规那种)，否则遍历过程中会遇到dp[i+1][j-1]没有值的情况
          - 外循环：控制结尾j，内循环遍历从字符串索引0开始到结尾j的所有子串；（不是常规的外起始i，内从起始i到字符串末尾的方式）
        - 内循环体：两部分 - 首先，判断dp[i][j]的真假；其次，dp为真时更新记录最长子串信息的变量。
        - 最后截取子串并返回。
    - ### 中心扩散：
      - 复杂度：O(n^2)，O(1)
      - 中心扩散法的思路是：遍历每一个索引，以这个索引为中心，利用“回文串”中心对称的特点，往两边扩散，看最多能扩散多远。
      - 回文串在长度为奇数和偶数的时候，“回文中心”的形式是不一样的。
        - 奇数回文串的“中心”是一个具体的字符，例如：回文串 "aba" 的中心是字符 "b"；
        - 偶数回文串的“中心”是位于中间的两个字符的“空隙”，例如：回文串串 "abba" 的中心是两个 "b" 中间的那个“空隙”；
        - 综上，遍历中心位置时，要同时计算 (i,i) 和 (i,i+1)，因此，for循环到length-2为止。
      - 算法：
        - 定义一个函数centerSpread，返回以left和right为中心扩散时的回文串
          - while在left和right没有超过字符串s的首尾时循环；
          - 循环体：if判断，相等时移动指针，不等时跳出循环；
          - 跳出循环时，恰好满足 s.charAt(i) != s.charAt(j)，因此不能取i和j，而substring是左闭右开的，取(i+1,j)
        - 主体函数：
          - 边界值s.length()=0和1时为真，返回s；
          - 定义最长子串res及其长度maxLens，并初始化，注意长度最小为1；
          - for循环遍历中心位置i，直到i<s.length()-1，因为循环体中会调用奇数和偶数两种扩散方式，防止角标越界；
          - 循环体中首先，分别定义奇数串和偶数串，并调用函数计算(i,i)和(i,i+1)作为中心的扩散结果；
          - 循环体重其次：取奇数串和偶数串中最长的一个作为maxLensStr，并与res的长度maxLens比较，更长时更新res及maxLens；
          - 循环结束后返回res。
    - ### Manacher(马拉车)算法：
      - Manacher算法本质上还是中心扩散法，只不过它使用了类似 KMP 算法的技巧，充分挖掘了已经进行回文判定的子串的特点，在遍历的过程中，记录了已经遍历过的子串的信息，也是典型的以空间换时间思想的体现。

- ## 代码链接：
  - [最长回文子串](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0005-longest-palindromic-substring.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 53. 最大子序和
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
    - 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6
      - 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
    - 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。
  - ### 解题思路
    - 思路：暴力法；动态规划；贪心；分治
    - 暴力法：
      - 复杂度：时间O(N^2)，空间O(1)
      - 寻找所有的可能子序和，并求最大值
      - 首先定义并初始化max为数组第一个元素
      - 按照一定规律遍历数组，比如从i开始遍历到末尾，不断取和，比较并取max，然后i++
      - 两层循环：外循环控制开始的i值，内循环控制在i索引开始，形成的子序列
    - 贪心：
      - 复杂度：时间O(n)，空间O(1)
      - 从左向右遍历，一个个数累加；当sum<0，重新开始找子序列
        - 所求最大值max可由if判断语句比较得到，也可由Math.max(i,j)直接求得
        - sum初始化为0，小于0的sum说明累加后比初始值更小了
        - "重新找"指的是：sum归0， 并从下一个元素起，重新累加
    - 动态规划：
      - 复杂度：时间O(n), 空间O(n)，可优化到O(1)
        - 只用到dp数组中的前一项，因此可以用int代替一维数组，对空间复杂度优化
      - dp[i]: nums中，以nums[i]结尾的最大子序和
      - dp[i]=max(dp[i-1]+nums[i], nums[i]);
    - 分治：
      - 复杂度：时间O(nlogn)，空间O(logn)
      - 取数组的中心点为中心，那么最大子序列要么在中心左，要么在右，要么跨中心
      - 分三种情况进行考虑
      - 跨中心的情况，又可以分治中心点左侧和右侧的最大子序列问题
      - 注：对比以上思路，分治的思路过于复杂，不详细分析了。
    - 注：
      - 类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值`max=Integer.MIN_VALUE;`
      - Integer是java.lang包下的，自动导入不用再手写import
      - Math是java.lang包下的，不用再手写import
      - 本题可以定义max为数组第一个元素，因为只是累加计算
 
- ## 代码链接：
  - [最大子序和](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0053-maximum-subarray.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 70. 爬楼梯
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
    - 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
    - 注意：给定 n 是一个正整数。
  - ### 解题思路
    - 思路：暴力法（直接调用本体）；动态规划法（用dp数组保存结果）；斐波那契数法（用）
      - 暴力法：直接调用本体，过多的重复操作，复杂度过高
      - 动态规划法：用dp数组保存结果，相比上一种方法改进了时间复杂度
      - 斐波那契数法：不用数组，而用几个变量在循环体中不断更新，相比上一种方法节约了空间
    - 暴力法：
      - 复杂度：时间O(2^n)，空间O(n)
      - 前两项直接返回结果，其他调用本体函数：`return climbStairs(n-1) + climbStairs(n-2);`
      - 是最直接的思路，但是由于中间有太多重复操作，比如某个i，会在调用中计算多次
    - 动态规划法：
      - 复杂度：时间O(n)，空间O(n)
      - 改进：引入数组 dp[] 来保存计算得到的中间值，避免冗余 
      - `dp[i]=dp[i−1]+dp[i−2]`
      - 注：数组索引值0不赋值，因此定义数组长度为n+1；
      - 易错：因为有给数组索引值1和2的位置赋值操作，特别注意数组越界问题，赋值前一定加判断n==1和n==2
    - 斐波那契数法：
      - 复杂度：时间O(n)，空间O(1)
      - 改进：用变量更新代替数组，改进了空间复杂度
      - 易错：最终b==c，但是c是定义在循环体中的，循环结束就释放了，因此返回b，特别注意

- ## 代码链接：
  - [爬楼梯](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0070-climbing-stairs.java)
   
<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 121. 买卖股票的最佳时机
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
    - 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。
    - 注意你不能在买入股票前卖出股票。
  - ### 解题思路
    - 思路：暴力法；一次遍历
    - 暴力法：
      - 复杂度：时间O(n^2)，空间O(1)
      - max初始化为0(至少为0)；
      - 两次遍历：外层控制开始位置，内层比较从开始位置往后的值，并不断更新减去开始结点所得的最大值。
      - 最终返回max。
    - 一次遍历：
      - 复杂度：时间O(n)，空间O(1)
      - 思路：找到最小的谷之后的最大的峰
      - 维持两个变量 - minprice 和 maxprofit，它们分别对应迄今为止所得到的最小的谷值和最大的利润（卖出价格与最低价格之间的最大差值）。
      - 算法：定义两个最值并初始化；遍历：先小后大 - 当[i]值更小时，更新min，否则，比较[i]-min与max的大小并更新max；返回max。

- ## 代码链接
  - [买卖股票的最佳时机](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0121-best-time-to-buy-and-sell-stock.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->  



# 198. 打家劫舍
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
    - 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。
  - ### 解题思路
    - 思路：动态规划
    - 复杂度：时间O(n)，空间O(1)
    - 本题是典型的动态规划问题，关键是找到状态转移方程。即变化规律。
    - 设f(n)是长度为n的数组对应的结果，通过列出前几项来找规律：
      - n=1时，f(1) = arr[0]
      - n=2时，f(2) = max(arr[0], arr[1])
      - n=3时，f(3) = max( f(1) + arr[2], f(2) )
      - n=3的解释：选第三个时，必然不能选第二个，即在n=1最优解的基础上加第三个；或者不选第三个，仍然用第二份的最优解。最后在两个值中取max
      - 同理，f(n) = max( f(n-2)+arr[n-1], f(n-1)), 其中arr[n-2]表示第n个元素
    - f(n)可以存储在数组中，但是考虑到每次只需要用到前两项，因此可以用变量更新的方法，节约空间。
    - 算法：定义变量表示前两项并初始化为0；循环遍历整个数组：公式求f(n)，并更新前两项的值；返回最终结果。
      - 注：初始化前两项时，不能直接定义arr[0]和arr[1]，因为没有判断就直接用，可能数组角标越界异常。
      - 表示前两项的变量dp1和dp2初始化为0，因为dp1的值在后面用不到了，因此只把dp2的值暂存在tmp中，计算后将值赋值作为新的dp1
    
- ## 代码链接:
  - [打家劫舍](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0198-house-robber.java)
  
<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->  



# 264. 丑数II
- ## 简述：（[medium3](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium3.md)）
  - ### 题目描述
    - 编写一个程序，找出第 n 个丑数。
    - 丑数就是质因数只包含 2, 3, 5 的正整数。
    - 示例:
      - 输入: n = 10
      - 输出: 12
      - 解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
    - 说明:   
      - 1 是丑数。
      - n不超过1690。
  - ### 解题思路
    - 求丑数的思路：
      - 验证一个数是否是丑数：先看是否能整除2，即取模得0，若可以则整除2直至余数不为0；然后重复3和5
    - 常规思路：
      - 从1开始，依次验证各个数是否符合
      - 问题：对每个数字进行了运算，时间复杂度高
    - 改进思路：
      - 以空间换时间，创建数组保存已经找到的丑数，并在此基础上乘以因子继续找
      - 现在的思路是在丑数的基础上找新的丑数，避免了遍历每个自然数的操作
      - 具体思路：找下一个丑数，设置flag2,3,5，可从已有丑数基础上乘以因子2,3,5，取最小值，同时改变flag值
    - 注意：
      - Math.min()针对两个数，因此写为：`Math.min(next2, Math.min(next3, next5))`
    - 面试思路：三指针法
      - 分析：思路大致同改进思路。
        - 基数是2，3，5，设置三个指针参数，分别作为三个基数的倍数，求乘积后取三者最小值作为下一个丑数。
        - 求得最小值对应的指针，并更新。
      - 算法：
        - 初始化数组dp[]，三个指针i2，i3，i5;
        - for循环：计算指定前n个丑数
          - 定义并求三个乘积结果：乘积 = 前一个dp[i] * 某个指针；
          - 用两个min找出三者中的最小值，作为下一个丑数存入dp[i]中；
          - 比较并找出dp[i]对应的指针，并+1；
        - 返回结果dp[n-1]。
      - 注：if判断最小指针时，不能用if-else-if的格式，会报错；只能用if-if-if的格式
        - 不知道为什么。

- ## 代码链接：
  - [丑数II](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0264-ugly-number-ii.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 322. 零钱兑换
- ## 简述：（[medium4](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium4.md)）
  - ### 题目描述
    - 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
    - 示例 1: 输入: coins = [1, 2, 5], amount = 11, 输出: 3, 解释: 11 = 5 + 5 + 1
    - 示例 2: 输入: coins = [2], amount = 3, 输出: -1
    - 说明: 你可以认为每种硬币的数量是无限的。
  - ### 解题思路
    - 思路：动态规划（自顶向下；自底向上）
      - 注：暴力递归会超时
    - 动态规划：
      - 复杂度：时间O(Sn), 空间O(S) -- S为金额，n为面值种类总数；
      - 状态转移方程：`f(n) = f(n-coin_i) + 1` -- f(n)为amount=n时的最少硬币个数；
      - 自底向上较自顶向下对重复计算部分有优化；
      - 边界值：amount=0时返回0，amount<0时返回-1；
      - f(amount)最大为1元硬币组成的，因此如果结果比amount+1还大，就返回amount；
      - 算法：
        - 新建dp数组：长度为`amount+1`，因为要额外存放`dp[0]`；
        - 新建最大值`max=amount+1;`, 并将max的值赋值给dp数组的每个位置: `Arrays.fill(dp, max);`;
        - 初始化`dp[0]=0;`;
        - 循环：外层控制当前金额，内层遍历硬币面值;
          - 内层：当硬币面值`coins[j]`小于等于当前金额i时，取`dp[i]`与`dp[i-coins[j]]+1`的最小值;
        - 返回前对结果进行判断：最大为1元硬币构成的amount.
      - Arrays 数组知识点：
        - fill(int[] a, int val)：将指定的 int 值分配给指定 int 型数组的每个元素。
      
- ## 代码链接：
  - [零钱兑换](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0332-coin-change.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 343. 整数拆分
- ## 简述：（[medium4](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/medium4.md)）
  - ### 题目描述
    - 给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。
    - 示例 1:
      - 输入: 2
      - 输出: 1
      - 解释: 2 = 1 + 1, 1 × 1 = 1。
    - 示例2:
      - 输入: 10
      - 输出: 36
      - 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
    - 说明: 你可以假设 n 不小于 2 且不大于 58。
  - ### 解题思路
    - ### 贪心：
      #### 每一步都做一个贪婪的选择，基于这个选择，可以得到最优解。一般需要数学方式证明贪婪选择的正确性。
      - 尽可能多剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现。
      - 如果出现了，就从已经切好长度为 3 的绳子中拿出一段与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。
      - 证明：
        - 当 n >= 5 时，3(n - 3) - n = 2n - 9 > 0，且 2(n - 2) - n = n - 4 > 0。
        - 因此在 n >= 5 的情况下，将绳子剪成一段为 2 或者 3，得到的乘积会更大。
        - 又因为 3(n - 3) - 2(n - 2) = n - 5 >= 0，所以剪成一段长度为 3 比长度为 2 得到的乘积更大。
      - 注：
        - 贪心：偏数学题算法，数学思路走通以后代码实现即可。
        - 定n>1,m>1，故dp[1]可0可1 (leetcode的测试用例中dp[1]为1)；为方便循环计算，可设为1
        - pow() 方法用于返回第一个参数的第二个参数次方。
          - double pow(double base, double exponent) -- 返回值类型默认为double型，而题目要求的是int型，强转为int
    - ### 动态规划：
      - 分析发现符合dp的问题特征：
        - 求一个问题的最优解； 
        - 整体的问题的最优解是依赖于各个子问题的最优解； 
        - 小问题之间还有相互重叠的更小的子问题； 
        - 从上往下分析问题，从下往上求解问题；
      - 不用过多分析，将问题无脑分解为更小的问题。
        - 从小到大，依次计算所有可能解并保存在数组中，直到计算到target为止。
      - 思路：
        - dp[i] 表示长度为i的绳子剪成m段后的最大乘积。
        - 初始化dp[2] = 1 表示如果一个绳子长度为2必然只能分成两段长度为1的绳子，两者的乘积为1。 
        - 然后尝试对绳子进行分割，如果只剪掉长度为1，对最后的乘积无任何增益，所以从长度为2开始剪，代码中的j就是表示尝试剪的长度。 
        - 剪下一段后，剩余部分可以剪也可以不剪。
          - 如果不剪则得到的长度乘积为 j * (i - j) 。
          - 如果剪得到的长度为j * dp[i - j]
          - 两者取最大值 
        - 不断修改剪的长度j （j范围为[2, i -1]）。
        - 从所有结果中找到最大值即为dp[i]的结果。 
        - 从而有状态转移方程dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))    
      - 注意：
        - i/2的略微优化没成，就暂时先这样吧..
        - dp[i]的值包含的内容（包括两个嵌套的Math.max()）需要缕清楚，别写错写漏了

- ## 代码链接：
  - [整数拆分](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0343-integer-break.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->





### END
