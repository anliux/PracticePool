# 动态规划
- 内含题目：183

# 目录
<!-- GFM-TOC -->
* [53. 最大子序和](#53-最大子序和)
* [70. 爬楼梯](#70-爬楼梯)
* [121. 买卖股票的最佳时机](#121-买卖股票的最佳时机)
* []()
* []()
<!-- GFM-TOC -->



# 53. 最大子序和
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
    - 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6
      - 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
    - 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。
  - ### 解题思路
    - 思路：暴力法；动态规划；贪心；分治
    - 暴力法：
      - 复杂度：时间O(N^2)，空间O(1)
      - 寻找所有的可能子序和，并求最大值
      - 首先定义并初始化max为数组第一个元素
      - 按照一定规律遍历数组，比如从i开始遍历到末尾，不断取和，比较并取max，然后i++
      - 两层循环：外循环控制开始的i值，内循环控制在i索引开始，形成的子序列
    - 贪心：
      - 复杂度：时间O(n)，空间O(1)
      - 从左向右遍历，一个个数累加；当sum<0，重新开始找子序列
        - 所求最大值max可由if判断语句比较得到，也可由Math.max(i,j)直接求得
        - sum初始化为0，小于0的sum说明累加后比初始值更小了
        - "重新找"指的是：sum归0， 并从下一个元素起，重新累加
    - 动态规划：
      - 复杂度：时间O(n), 空间O(n)，可优化到O(1)
        - 只用到dp数组中的前一项，因此可以用int代替一维数组，对空间复杂度优化
      - dp[i]: nums中，以nums[i]结尾的最大子序和
      - dp[i]=max(dp[i-1]+nums[i], nums[i]);
    - 分治：
      - 复杂度：时间O(nlogn)，空间O(logn)
      - 取数组的中心点为中心，那么最大子序列要么在中心左，要么在右，要么跨中心
      - 分三种情况进行考虑
      - 跨中心的情况，又可以分治中心点左侧和右侧的最大子序列问题
      - 注：对比以上思路，分治的思路过于复杂，不详细分析了。
    - 注：
      - 类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值`max=Integer.MIN_VALUE;`
      - Integer是java.lang包下的，自动导入不用再手写import
      - Math是java.lang包下的，不用再手写import
      - 本题可以定义max为数组第一个元素，因为只是累加计算
 
- ## 代码链接：
  - [最大子序和](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0053-maximum-subarray.java)



<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 70. 爬楼梯
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
    - 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
    - 注意：给定 n 是一个正整数。
  - ### 解题思路
    - 思路：暴力法（直接调用本体）；动态规划法（用dp数组保存结果）；斐波那契数法（用）
      - 暴力法：直接调用本体，过多的重复操作，复杂度过高
      - 动态规划法：用dp数组保存结果，相比上一种方法改进了时间复杂度
      - 斐波那契数法：不用数组，而用几个变量在循环体中不断更新，相比上一种方法节约了空间
    - 暴力法：
      - 复杂度：时间O(2^n)，空间O(n)
      - 前两项直接返回结果，其他调用本体函数：`return climbStairs(n-1) + climbStairs(n-2);`
      - 是最直接的思路，但是由于中间有太多重复操作，比如某个i，会在调用中计算多次
    - 动态规划法：
      - 复杂度：时间O(n)，空间O(n)
      - 改进：引入数组 dp[] 来保存计算得到的中间值，避免冗余 
      - `dp[i]=dp[i−1]+dp[i−2]`
      - 注：数组索引值0不赋值，因此定义数组长度为n+1；
      - 易错：因为有给数组索引值1和2的位置赋值操作，特别注意数组越界问题，赋值前一定加判断n==1和n==2
    - 斐波那契数法：
      - 复杂度：时间O(n)，空间O(1)
      - 改进：用变量更新代替数组，改进了空间复杂度
      - 易错：最终b==c，但是c是定义在循环体中的，循环结束就释放了，因此返回b，特别注意

- ## 代码链接：
  - [爬楼梯](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0070-climbing-stairs.java)
   
<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 121. 买卖股票的最佳时机
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
    - 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。
    - 注意你不能在买入股票前卖出股票。
  - ### 解题思路
    - 思路：暴力法；一次遍历
    - 暴力法：
      - 复杂度：时间O(n^2)，空间O(1)
      - max初始化为0(至少为0)；
      - 两次遍历：外层控制开始位置，内层比较从开始位置往后的值，并不断更新减去开始结点所得的最大值。
      - 最终返回max。
    - 一次遍历：
      - 复杂度：时间O(n)，空间O(1)
      - 思路：找到最小的谷之后的最大的峰
      - 维持两个变量 - minprice 和 maxprofit，它们分别对应迄今为止所得到的最小的谷值和最大的利润（卖出价格与最低价格之间的最大差值）。
      - 算法：定义两个最值并初始化；遍历：先小后大 - 当[i]值更小时，更新min，否则，比较[i]-min与max的大小并更新max；返回max。

- ## 代码链接
  - [买卖股票的最佳时机](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0121-best-time-to-buy-and-sell-stock.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->  




### END
