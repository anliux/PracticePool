# 动态规划
- 内含题目：183

# 目录
<!-- GFM-TOC -->
* [53. 最大子序和](#53-最大子序和)
* [70. 爬楼梯](#70-爬楼梯)
* [121. 买卖股票的最佳时机](#121-买卖股票的最佳时机)
* [198. 打家劫舍](#198. 打家劫舍)
* []()
<!-- GFM-TOC -->



# 53. 最大子序和
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
    - 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6
      - 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
    - 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。
  - ### 解题思路
    - 思路：暴力法；动态规划；贪心；分治
    - 暴力法：
      - 复杂度：时间O(N^2)，空间O(1)
      - 寻找所有的可能子序和，并求最大值
      - 首先定义并初始化max为数组第一个元素
      - 按照一定规律遍历数组，比如从i开始遍历到末尾，不断取和，比较并取max，然后i++
      - 两层循环：外循环控制开始的i值，内循环控制在i索引开始，形成的子序列
    - 贪心：
      - 复杂度：时间O(n)，空间O(1)
      - 从左向右遍历，一个个数累加；当sum<0，重新开始找子序列
        - 所求最大值max可由if判断语句比较得到，也可由Math.max(i,j)直接求得
        - sum初始化为0，小于0的sum说明累加后比初始值更小了
        - "重新找"指的是：sum归0， 并从下一个元素起，重新累加
    - 动态规划：
      - 复杂度：时间O(n), 空间O(n)，可优化到O(1)
        - 只用到dp数组中的前一项，因此可以用int代替一维数组，对空间复杂度优化
      - dp[i]: nums中，以nums[i]结尾的最大子序和
      - dp[i]=max(dp[i-1]+nums[i], nums[i]);
    - 分治：
      - 复杂度：时间O(nlogn)，空间O(logn)
      - 取数组的中心点为中心，那么最大子序列要么在中心左，要么在右，要么跨中心
      - 分三种情况进行考虑
      - 跨中心的情况，又可以分治中心点左侧和右侧的最大子序列问题
      - 注：对比以上思路，分治的思路过于复杂，不详细分析了。
    - 注：
      - 类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值`max=Integer.MIN_VALUE;`
      - Integer是java.lang包下的，自动导入不用再手写import
      - Math是java.lang包下的，不用再手写import
      - 本题可以定义max为数组第一个元素，因为只是累加计算
 
- ## 代码链接：
  - [最大子序和](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0053-maximum-subarray.java)



<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 70. 爬楼梯
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
    - 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
    - 注意：给定 n 是一个正整数。
  - ### 解题思路
    - 思路：暴力法（直接调用本体）；动态规划法（用dp数组保存结果）；斐波那契数法（用）
      - 暴力法：直接调用本体，过多的重复操作，复杂度过高
      - 动态规划法：用dp数组保存结果，相比上一种方法改进了时间复杂度
      - 斐波那契数法：不用数组，而用几个变量在循环体中不断更新，相比上一种方法节约了空间
    - 暴力法：
      - 复杂度：时间O(2^n)，空间O(n)
      - 前两项直接返回结果，其他调用本体函数：`return climbStairs(n-1) + climbStairs(n-2);`
      - 是最直接的思路，但是由于中间有太多重复操作，比如某个i，会在调用中计算多次
    - 动态规划法：
      - 复杂度：时间O(n)，空间O(n)
      - 改进：引入数组 dp[] 来保存计算得到的中间值，避免冗余 
      - `dp[i]=dp[i−1]+dp[i−2]`
      - 注：数组索引值0不赋值，因此定义数组长度为n+1；
      - 易错：因为有给数组索引值1和2的位置赋值操作，特别注意数组越界问题，赋值前一定加判断n==1和n==2
    - 斐波那契数法：
      - 复杂度：时间O(n)，空间O(1)
      - 改进：用变量更新代替数组，改进了空间复杂度
      - 易错：最终b==c，但是c是定义在循环体中的，循环结束就释放了，因此返回b，特别注意

- ## 代码链接：
  - [爬楼梯](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0070-climbing-stairs.java)
   
<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 121. 买卖股票的最佳时机
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
    - 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。
    - 注意你不能在买入股票前卖出股票。
  - ### 解题思路
    - 思路：暴力法；一次遍历
    - 暴力法：
      - 复杂度：时间O(n^2)，空间O(1)
      - max初始化为0(至少为0)；
      - 两次遍历：外层控制开始位置，内层比较从开始位置往后的值，并不断更新减去开始结点所得的最大值。
      - 最终返回max。
    - 一次遍历：
      - 复杂度：时间O(n)，空间O(1)
      - 思路：找到最小的谷之后的最大的峰
      - 维持两个变量 - minprice 和 maxprofit，它们分别对应迄今为止所得到的最小的谷值和最大的利润（卖出价格与最低价格之间的最大差值）。
      - 算法：定义两个最值并初始化；遍历：先小后大 - 当[i]值更小时，更新min，否则，比较[i]-min与max的大小并更新max；返回max。

- ## 代码链接
  - [买卖股票的最佳时机](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0121-best-time-to-buy-and-sell-stock.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->  



# 198. 打家劫舍
- ## 简述：（[easy](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/easy.md)）
  - ### 题目描述
    - 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
    - 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。
  - ### 解题思路
    - 思路：动态规划
    - 复杂度：时间O(n)，空间O(1)
    - 本题是典型的动态规划问题，关键是找到状态转移方程。即变化规律。
    - 设f(n)是长度为n的数组对应的结果，通过列出前几项来找规律：
      - n=1时，f(1) = arr[0]
      - n=2时，f(2) = max(arr[0], arr[1])
      - n=3时，f(3) = max( f(1) + arr[2], f(2) )
      - n=3的解释：选第三个时，必然不能选第二个，即在n=1最优解的基础上加第三个；或者不选第三个，仍然用第二份的最优解。最后在两个值中取max
      - 同理，f(n) = max( f(n-2)+arr[n-1], f(n-1)), 其中arr[n-2]表示第n个元素
    - f(n)可以存储在数组中，但是考虑到每次只需要用到前两项，因此可以用变量更新的方法，节约空间。
    - 算法：定义变量表示前两项并初始化为0；循环遍历整个数组：公式求f(n)，并更新前两项的值；返回最终结果。
      - 注：初始化前两项时，不能直接定义arr[0]和arr[1]，因为没有判断就直接用，可能数组角标越界异常。
      - 表示前两项的变量dp1和dp2初始化为0，因为dp1的值在后面用不到了，因此只把dp2的值暂存在tmp中，计算后将值赋值作为新的dp1
    
- ## 代码链接:
  - [打家劫舍](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0198-house-robber.java)
  
<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->  



### END
