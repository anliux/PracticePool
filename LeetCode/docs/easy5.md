# easy5
- 本文题号范围：801-1000


# 目录
<!-- GFM-TOC -->
* [836. 矩形重叠](#836-矩形重叠)
* []()
* []()
* [876. 链表的中间结点](#876-链表的中间结点)
* []()
* [914. 卡牌分组](#914-卡牌分组)
* []()
* []()
* []()
* []()
* []()
<!-- GFM-TOC -->



# 836. 矩形重叠
- ## 题目链接：
  - [rectangle-overlap](https://leetcode-cn.com/problems/rectangle-overlap/)

- ## 题目标签：
  - [数学](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/Math.md)
  
- ## 题目描述
  - 矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。
  - 如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。
  - 给出两个矩形，判断它们是否重叠并返回结果。
  - 示例 1：
    - 输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]
    - 输出：true
  - 示例 2：
    - 输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]
    - 输出：false
  - 说明：
    - 两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。
    - 矩形中的所有坐标都处于 -10^9 和 10^9 之间。
 
- ## 解题思路
  - 思路：检查位置；检查区域
  - 检查位置：
    - 复杂度：时间O(1)，空间O(1)
    - 分析：
      - 考虑不重叠情况：四周，即一个矩阵在另一个矩阵的左侧，右侧，上侧，下侧
      - 代码体现为：
        - 左侧：`rec1[2] <= rec2[0]`；
        - 右侧：`rec1[0] >= rec2[2]`；
        - 上方：`rec1[1] >= rec2[3]`；
        - 下方：`rec1[3] <= rec2[1]`。
      - 将不重叠情况排除，剩余的就是重叠情况
    - 算法：
      - 直接return：将不重叠情况排除，剩余的就是重叠情况。
  - 检查区域：
    - 复杂度：时间O(1)，空间O(1)
    - 分析：
      - 如果两个矩形重叠，那么它们重叠的区域一定也是一个矩形；
      - 那么这代表了两个矩形与 x 轴平行的边（水平边）投影到 x 轴上时会有交集，与 y 轴平行的边（竖直边）投影到 y 轴上时也会有交集。
      - 因此，我们可以将问题看作一维线段是否有交集的问题。
      - 考虑分离情况来辅助理解重叠情况：
        - x轴：如果不重叠，那么左端点的最大值(即分离的大矩形的左端点)，会大于右端点的最小值(即分离的小矩形的右端点)
        - y轴：同理
        - 总结就是分离“min<max, 大的最小值(在小矩形里)小于小的最大值(在大矩形里)”，等于就是重合的情况。
      - 因此，重叠就是“min>max，大的最小值(小矩形)大于小的最大值(大矩形)”
      - 交集代码体现：
        - x轴：`min(rec1[2], rec2[2]) > max(rec1[0], rec2[0])`
        - y轴：`min(rec1[3], rec2[3]) > max(rec1[1], rec2[1])`
        - 考虑不重叠情况来辅助理解重叠情况。
      - 两个方向都有交集时，证明可以构成重叠区域，此时重叠。
        - 考虑两个方向都存在交集是因为如果一真一假，可能只是边界重合，但没有重叠。
    - 算法：
      - 直接return：两个方向都有交集时，返回true。

- ## 代码链接：
  - [矩形重叠](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0836-ectangle-overlap.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 876. 链表的中间结点
- ## 题目链接：
  - [middle-of-the-linked-list](https://leetcode-cn.com/problems/middle-of-the-linked-list/)

- ## 题目标签：
  - [链表](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/Linked%20List.md)
  
- ## 题目描述
  - 给定一个带有头结点 head 的非空单链表，返回链表的中间结点。
  - 如果有两个中间结点，则返回第二个中间结点。
  - 示例 1：
    - 输入：[1,2,3,4,5]
    - 输出：此列表中的结点 3 (序列化形式：[3,4,5])
    - 返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。
    - 注意，我们返回了一个 ListNode 类型的对象 ans，这样：
      - `ans.val = 3, ans.next.val = 4, ans.next.next.val = 5`, 以及 `ans.next.next.next = NULL`.
  - 示例 2：
    - 输入：[1,2,3,4,5,6]
    - 输出：此列表中的结点 4 (序列化形式：[4,5,6])
    - 由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。
  - 提示：给定链表的结点数介于 1 和 100 之间。

- ## 解题思路
  - 思路：数组；单指针；快慢指针
    - 注：双指针参考<leetcode-141-环形链表-easy>
  - 数组：
    - 复杂度：时间O(n)，空间O(n)
    - 分析：
      - 对链表进行遍历，同时将遍历到的元素依次放入数组 A 中。
      - 如果我们遍历到了 N 个元素，那么链表以及数组的长度也为 N，对应的中间节点即为 A[N/2]。
    - 算法：
      - 定义链表结点数组；
      - 定义数组索引值(其实也可以看做指针）；
      - 遍历数组，同时将链表结点存入数组，链表指针向后移动；
      - 遍历结束后，根据索引值返回中间结点。
      - 注：pt索引值比最终的存入结点多1，与结点个数是一致的，经测试，奇偶性符合要求。
  - 单指针：
    - 复杂度：时间O(n)，空间O(1)
    - 分析：
      - 对方法一进行空间优化，省去数组 A。
      - 可以对链表进行两次遍历。
      - 第一次遍历时，统计链表中的元素个数 N；
      - 第二次遍历时，我们遍历到第 N/2 个元素（链表的首节点为第 0 个元素）时，将该元素返回即可。
    - 算法：
      - 定义计数器count，以及链表指针cur；
      - 第一次遍历链表，并计数；
      - 重新定义计数器res，并将cur置为head；
      - 第二次遍历链表：当res达到中间值时返回对应结点。
      - 注：计数器初始化为0，并且第一次遍历时，比最终的结点多1，与结点个数是一致的，经测试，奇偶性符合要求。同上。
  - 快慢指针：
    - 复杂度：时间O(n)，空间O(1)
    - 分析：
      - 继续优化方法二，用两个指针 slow 与 fast 一起遍历链表。
      - slow 一次走一步，fast 一次走两步。
      - 那么当 fast 到达链表的末尾时，slow 必然位于中间。
    - 算法：
      - 定义快慢指针；
      - 遍历链表：慢指针走一步，快指针走两步，当快指针到达末尾时终止循环；
      - 返回慢指针。
      - 注：循环判断的是快指针，当前和下一个，因为循环体中的走两步要防止越界。
      - 注：循环停止时，两指针均指向下一个结点，边界值判断经测试符合。

- ## 代码链接：
  - [链表的中间结点](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0876-middle-of-the-linked-list.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 914. 卡牌分组
- ## 题目链接：
  - [x-of-a-kind-in-a-deck-of-cards](https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards/)

- ## 题目标签：
  - [数组](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/Array.md)
  - [数学](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/Math.md)
  
- ## 题目描述
  - 给定一副牌，每张牌上都写着一个整数。
  - 此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：
    - 每组都有 X 张牌。
    - 组内所有的牌上都写着相同的整数。
    - 仅当你可选的 X >= 2 时返回 true。
  - 示例 1：
    - 输入：[1,2,3,4,4,3,2,1]，输出：true
    - 解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]
  - 示例 2：
    - 输入：[1,1,1,2,2,2,3,3]，输出：false
    - 解释：没有满足要求的分组。
  - 示例 3：
    - 输入：[1]，输出：false
    - 解释：没有满足要求的分组。
  - 示例 4：
    - 输入：[1,1]，输出：true
    - 解释：可行的分组是 [1,1]
  - 示例 5：
    - 输入：[1,1,2,2,2,2]，输出：true
    - 解释：可行的分组是 [1,1]，[2,2]，[2,2]
  - 提示：1 <= deck.length <= 10000，0 <= deck[i] < 10000

- ## 解题思路
  - 思路：暴力法；最大公约数法。
    - 注：最大公约数法参考<leetcode-1071-字符串的最大公因子-easy>
  - 暴力法：
    - 复杂度：时间O(n^2)，空间O(n)
    - 分析：
      - 从 2 开始，从小到大枚举 X。
      - 由于每一组都有 X 张牌，那么 X 必须是卡牌总数 N 的约数。
      - 其次，对于写着数字 i 的牌，如果有 count i  张，那么 X 也必须是 count i 的约数，即：`count i modX==0`
      - 所以对于每一个 X，先判断 X 是否为 N 的约数，然后遍历所有牌中存在的数字 i，看它们对应牌的数量 count i  是否满足上述要求。
      - 如果都满足等式，则 X 为符合条件的解，否则需要继续令 X 增大，枚举下一个数字。
    - 算法：
      - 第一步：计数。
      - 定义数组长度N：即卡牌总数；
      - 模拟哈希表统计每个数字的出现次数：定义长10000的数组count，然后遍历数组deck并将元素值作为count数组索引值并自增1；
      - 第二步：统计数字个数。
      - 定义数组列表values，遍历count数组，并将count数组中所有大于0的元素添加到values数组列表；或依然用普通数组存储即可；
      - 第三步：遍历并判断。
      - 两层循环：外循环控制从2开始枚举的X(包括等于N)，内循环控制两个指标的取余，不符合时继续增加枚举，均符合时返回true，枚举到卡牌数N结束。
      - 注意：这里为了内循环控制外循环，给外循环做了标记，即for()前面的search表示外循环。
  - 最大公约数法：
    - 复杂度：时间O(NlogC)，空间O(N)
    - 分析：
      - 每种数字的卡牌张数必须是X的倍数（只有这样才能每X张牌分为1组，且每组牌的数字都相同), 且X>1。
      - 由此，本题转换成了求: 每种卡牌张数的最大公约数。
      - 只要求出所有 count i 最大公约数 g，判断 g 是否大于等于 2 即可，如果大于等于 2，则满足条件，否则不满足。
      - 最大公约数：辗转相除法，将除数和余数作为参数递归，直到余数为0时返回除数的值即为所求。
    - 算法：
      - 定义求最大公约数gcd的函数：将除数和余数作为新参数传入，并递归，直到余数为0，这时返回除数。
      - 首先定义计数数组，遍历原数组并求出每个数字出现的次数，并存入计数数组中；
      - 定义公约数变量g：
        - 注意：初始化为-1，并且在计数数组元素大于0时赋值，是为了绕过0，避免所有公约数都被计算为0，又保证了获取的是计数数组中的元素。
      - 遍历计数数组，并计算大于0的元素与公约数g的最大公约数；
      - 最后，判断g是否大于等于2，符合则返回true，否则返回false。
      
- ## 代码链接：
  - [卡牌分组](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0914-x-of-a-kind-in-a-deck-of-cards.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 
- ## 题目链接：
  - []()

- ## 题目标签：
  - [数组](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/Array.md)
  - [哈希表](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/Hash%20Table.md)
  
- ## 题目描述
 

- ## 解题思路


- ## 代码链接：
  - []()

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->






### END
