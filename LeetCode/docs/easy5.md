# easy5
- 本文题号范围：801-1000


# 目录
<!-- GFM-TOC -->
* [836. 矩形重叠](#836-矩形重叠)
* []()
* []()
* [876. 链表的中间结点](#876-链表的中间结点)
* []()
* []()
* []()
* []()
* []()
* []()
* []()
<!-- GFM-TOC -->



# 836. 矩形重叠
- ## 题目链接：
  - [rectangle-overlap](https://leetcode-cn.com/problems/rectangle-overlap/)

- ## 题目标签：
  - [数学](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/Math.md)
  
- ## 题目描述
  - 矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。
  - 如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。
  - 给出两个矩形，判断它们是否重叠并返回结果。
  - 示例 1：
    - 输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]
    - 输出：true
  - 示例 2：
    - 输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]
    - 输出：false
  - 说明：
    - 两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。
    - 矩形中的所有坐标都处于 -10^9 和 10^9 之间。
 
- ## 解题思路
  - 思路：检查位置；检查区域
  - 检查位置：
    - 复杂度：时间O(1)，空间O(1)
    - 分析：
      - 考虑不重叠情况：四周，即一个矩阵在另一个矩阵的左侧，右侧，上侧，下侧
      - 代码体现为：
        - 左侧：`rec1[2] <= rec2[0]`；
        - 右侧：`rec1[0] >= rec2[2]`；
        - 上方：`rec1[1] >= rec2[3]`；
        - 下方：`rec1[3] <= rec2[1]`。
      - 将不重叠情况排除，剩余的就是重叠情况
    - 算法：
      - 直接return：将不重叠情况排除，剩余的就是重叠情况。
  - 检查区域：
    - 复杂度：时间O(1)，空间O(1)
    - 分析：
      - 如果两个矩形重叠，那么它们重叠的区域一定也是一个矩形；
      - 那么这代表了两个矩形与 x 轴平行的边（水平边）投影到 x 轴上时会有交集，与 y 轴平行的边（竖直边）投影到 y 轴上时也会有交集。
      - 因此，我们可以将问题看作一维线段是否有交集的问题。
      - 考虑分离情况来辅助理解重叠情况：
        - x轴：如果不重叠，那么左端点的最大值(即分离的大矩形的左端点)，会大于右端点的最小值(即分离的小矩形的右端点)
        - y轴：同理
        - 总结就是分离“min<max, 大的最小值(在小矩形里)小于小的最大值(在大矩形里)”，等于就是重合的情况。
      - 因此，重叠就是“min>max，大的最小值(小矩形)大于小的最大值(大矩形)”
      - 交集代码体现：
        - x轴：`min(rec1[2], rec2[2]) > max(rec1[0], rec2[0])`
        - y轴：`min(rec1[3], rec2[3]) > max(rec1[1], rec2[1])`
        - 考虑不重叠情况来辅助理解重叠情况。
      - 两个方向都有交集时，证明可以构成重叠区域，此时重叠。
        - 考虑两个方向都存在交集是因为如果一真一假，可能只是边界重合，但没有重叠。
    - 算法：
      - 直接return：两个方向都有交集时，返回true。

- ## 代码链接：
  - [矩形重叠](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0836-ectangle-overlap.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 876. 链表的中间结点
- ## 题目链接：
  - [middle-of-the-linked-list](https://leetcode-cn.com/problems/middle-of-the-linked-list/)

- ## 题目标签：
  - [链表](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/Linked%20List.md)
  
- ## 题目描述
  - 给定一个带有头结点 head 的非空单链表，返回链表的中间结点。
  - 如果有两个中间结点，则返回第二个中间结点。
  - 示例 1：
    - 输入：[1,2,3,4,5]
    - 输出：此列表中的结点 3 (序列化形式：[3,4,5])
    - 返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。
    - 注意，我们返回了一个 ListNode 类型的对象 ans，这样：
      - `ans.val = 3, ans.next.val = 4, ans.next.next.val = 5`, 以及 `ans.next.next.next = NULL`.
  - 示例 2：
    - 输入：[1,2,3,4,5,6]
    - 输出：此列表中的结点 4 (序列化形式：[4,5,6])
    - 由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。
  - 提示：给定链表的结点数介于 1 和 100 之间。

- ## 解题思路
  - 思路：数组；单指针；快慢指针
    - 注：双指针参考<leetcode-141-环形链表-easy>
  - 数组：
    - 复杂度：时间O(n)，空间O(n)
    - 分析：
      - 对链表进行遍历，同时将遍历到的元素依次放入数组 A 中。
      - 如果我们遍历到了 N 个元素，那么链表以及数组的长度也为 N，对应的中间节点即为 A[N/2]。
    - 算法：
      - 定义链表结点数组；
      - 定义数组索引值(其实也可以看做指针）；
      - 遍历数组，同时将链表结点存入数组，链表指针向后移动；
      - 遍历结束后，根据索引值返回中间结点。
      - 注：pt索引值比最终的存入结点多1，与结点个数是一致的，经测试，奇偶性符合要求。
  - 单指针：
    - 复杂度：时间O(n)，空间O(1)
    - 分析：
      - 对方法一进行空间优化，省去数组 A。
      - 可以对链表进行两次遍历。
      - 第一次遍历时，统计链表中的元素个数 N；
      - 第二次遍历时，我们遍历到第 N/2 个元素（链表的首节点为第 0 个元素）时，将该元素返回即可。
    - 算法：
      - 定义计数器count，以及链表指针cur；
      - 第一次遍历链表，并计数；
      - 重新定义计数器res，并将cur置为head；
      - 第二次遍历链表：当res达到中间值时返回对应结点。
      - 注：计数器初始化为0，并且第一次遍历时，比最终的结点多1，与结点个数是一致的，经测试，奇偶性符合要求。同上。
  - 快慢指针：
    - 复杂度：时间O(n)，空间O(1)
    - 分析：
      - 继续优化方法二，用两个指针 slow 与 fast 一起遍历链表。
      - slow 一次走一步，fast 一次走两步。
      - 那么当 fast 到达链表的末尾时，slow 必然位于中间。
    - 算法：
      - 定义快慢指针；
      - 遍历链表：慢指针走一步，快指针走两步，当快指针到达末尾时终止循环；
      - 返回慢指针。
      - 注：循环判断的是快指针，当前和下一个，因为循环体中的走两步要防止越界。
      - 注：循环停止时，两指针均指向下一个结点，边界值判断经测试符合。

- ## 代码链接：
  - [链表的中间结点](https://github.com/anliux/PracticePool/blob/master/LeetCode/src/0876-middle-of-the-linked-list.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 
- ## 题目链接：
  - []()

- ## 题目标签：
  - [数组](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/Array.md)
  - [哈希表](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/Hash%20Table.md)
  
- ## 题目描述
 

- ## 解题思路


- ## 代码链接：
  - []()

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->





# 
- ## 题目链接：
  - []()

- ## 题目标签：
  - [数组](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/Array.md)
  - [哈希表](https://github.com/anliux/PracticePool/blob/master/LeetCode/docs/Hash%20Table.md)
  
- ## 题目描述
 

- ## 解题思路


- ## 代码链接：
  - []()

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->






### END
