# 2019校招真题刷题目


- 来源牛客： [2019校招题编程题汇总](https://www.nowcoder.com/ta/2019test)
- 排序：通过率降序


## 目录
<!-- GFM-TOC -->
* [1. 二进制中有多少个1](#1-二进制中有多少个1)
* [2. 游戏海报](#2-游戏海报)
* [3. 找零](#3-找零)
* [4. 表达式求值](#4-表达式求值)
* [5. 员工考勤记录](#5-员工考勤记录)
* [6. 访友](#6-访友)
* [7. 非递减序列](#7-非递减序列)
* [8. 数字序列第n位的值](#8-数字序列第n位的值)
* []()
* []()
* []()
* []()
<!-- GFM-TOC -->



# 1. 二进制中有多少个1
- ## 题目描述
  - 把一个32-bit整型转成二进制，其中包含多少个1，比如5的二进制表达是101，其中包含2个1
  - 输入描述: 输入为整型（十进制），只需兼容32-bit即可，如5、32
  - 输出描述: 输出为字符串，如“2”、“1”
  - 例如：输入5，输出2
  
- ## 解题思路
  - 根据10进制转2进制的手算方法：除2取余得结果
  - 因为除2取余的结果只能是0或1，因此可直接将取余结果累加到计数变量
  - 题目要求输出为字符串，这里直接输出计数变量是可以的，因为输出语句默认toString
  - 注意：只是求1的个数，不需要求转成二进制的更多繁琐的东西。
  
- ## 代码链接
  - [二进制中有多少个1](https://github.com/anliux/PracticePool/blob/master/campus/src/001_二进制中有多少个1.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 2. 游戏海报
- ## 题目描述
  - 小明有26种游戏海报，用小写字母"a"到"z"表示。
  - 小明会把游戏海报装订成册（可能有重复的海报），册子可以用一个字符串来表示，每个字符就表示对应的海报，例如abcdea。
  - 小明现在想做一些“特别版”，然后卖掉。特别版就是会从所有海报（26种）中随机选一张，加入到册子的任意一个位置。
  - 那现在小明手里已经有一种海报册子，再插入一张新的海报后，他一共可以组成多少不同的海报册子呢？
  - 输入描述:海报册子的字符串表示，1 <= 字符串长度<= 20
  - 输出描述:一个整数，表示可以组成的不同的海报册子种类数
  - 例如：输入a，输出51（可以组成 'ab','ac',...,'az','ba','ca',...,'za' 还有 'aa', 一共 51 种不同的海报册子）

- ## 解题思路
  - 典型插空题，如果从遍历字符串并比较的角度考虑是非常困难的，不如直接从数学规律角度考虑。
  - 插空问题：设有n个字符，则有n+1个空可以插，一个26个字母有26*(n+1)种情况
  - 考虑重复情况：当插入的字母与旁边字母相同时，插在左侧和右侧是相同的，n个字母就存在n种重复的情况，减去
  - 注意：想不明白的时候及时结合图示
  - 注意：
    - 判空时，符合非法输入情况可直接`return;`，不写return 0 也行的
    - 获取输入时，对于字符串的情况，直接写`sc.next()`或者``sc.nextLine()`均可
    - `length()`要带小括号否则会报错：求数组长度作为属性可不加小括号，求字符串长度时要加小括号

- ## 代码链接
  - [游戏海报](https://github.com/anliux/PracticePool/blob/master/campus/src/002_游戏海报.java)
  
<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 3. 找零
- ## 题目描述
  - Z国的货币系统包含面值1元、4元、16元、64元共计4种硬币，以及面值1024元的纸币。
  - 现在小Y使用1024元的纸币购买了一件价值为N (0 < N \le 1024)N(0<N≤1024)的商品，请问最少他会收到多少硬币？
  - 输入：一个数N；输出：一个数，表示最少收到的硬币数

- ## 解题思路
  - 贪心，或者背包问题动态规划
  - 但是因为本题比较简单，首先人类思维算一下就可以得到解题思路：整除、取余、相减、求和
  - 纯数学的解法仅仅考虑借助计算机进行运算，没有别的。这题可以，别的同类型题就未必可以了

- ## 代码链接
  - [找零](https://github.com/anliux/PracticePool/blob/master/campus/src/003_找零.java)
  
<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->


  
# 4. 表达式求值
- ## 题目描述
  - 小易希望你帮他计算给定3个数a，b，c，在它们中间添加加号、乘号、小括号，能够获得的最大值。
  - 输入描述: 一行三个数a，b，c (1 <= a, b, c <= 10)
  - 输出描述: 能够获得的最大值
  - 例如：输入1 2 3，输出9

- ## 解题思路
  - 看起来像贪心背包问题，但仍然可以用纯数学方法解题
  - 给定范围为1-10闭区间，故定义为int型
  - 先排序，然后根据三个数中1的个数分情况讨论
  - 若三个都是1，则三数相加最大
  - 若有两个数是1，则最小值与次小值相加，并与最大值相乘最大
  - 若有一个数是1，则情况同上
  - 若最小值大于1，三数相乘最大
  
- ## 代码链接
  - [表达式求值](https://github.com/anliux/PracticePool/blob/master/campus/src/004_表达式求值.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 5. 员工考勤记录
- ## 题目描述
  - 如果一个员工的考勤纪录中不超过两个'A'(缺勤),那么这个员工会被奖赏。
  - 如果你作为一个员工，想在连续N天的考勤周期中获得奖赏，请问有多少种考勤的组合能够满足要求
  - 输入描述: 考勤周期的天数N（正整数）
  - 输出描述: 这N天里能获得奖赏的考勤组合数
  - 例如：输入3，输出7
  
- ## 解题思路
  - 纯数学问题，用排列组合公式分别取缺勤0天、1天、2天
    c(n,0)+c(n,1)+c(n,2)
  - 注意考虑边界值如N=1，N=2是否符合公式。是符合的，不用另外讨论。
  
- ## 代码链接
  - [员工考勤记录](https://github.com/anliux/PracticePool/blob/master/campus/src/005_员工考勤记录.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 6. 访友
- ## 题目描述
  - 小易准备去拜访他的朋友，他的家在0点，但是他的朋友的家在x点(x > 0)，均在一条坐标轴上。
  - 小易每一次可以向前走1，2，3，4或者5步。问小易最少走多少次可以到达他的朋友的家。
  - 输入描述: 一行包含一个数字x(1 <= x <= 1000000)，代表朋友家的位置。
  - 输出描述: 一个整数，最少的步数。
  - 例如：输入10，输出2；输入4，输出1
  
- ## 解题思路
  - 如果按照“3-找零”的思路，依次对54321整除取余求和，就走弯路了
  - 特殊值计算会发现，如果不能整除5，则余数必在1234其一，故这4个数任选一个走一步即可，不用每个都计算的。
  - 分类讨论不同情况：n<5，n是5的倍数，n/5不为0，这三种情况都可以用同一个公式表示
  - 注意：x的取值(1 <= x <= 1000000)，使用long。不过看讨论区好像用int也可以ac？？
  
- ## 代码链接
  - [访友](https://github.com/anliux/PracticePool/blob/master/campus/src/006_访友.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 7. 非递减序列
- ## 题目描述
  - 对于一个长度为n的整数序列，你需要检查这个序列是否可以是非递减序列，假如你最多可以改变其中的一个数使其变为非递减序列则为是，否则为否。
  - 非递减序列的定义是：array[i]<=array[i+1], for 1<=i<n;
  - 输入描述: 输入是一个长度为n的整数序列。
  - 输出描述: 输出为； 是为1； 否为0

- ## 解题思路
  - 先说这题的测试用例有问题，**直接输出1就可以100%ac，发家致富野路子get**
  - 测试用例考虑：912345,456123,3465578,1284539
  - 设置标识flag作为修改次数
  - 遍历发现逆序时进行修改arr[i]=arr[i+1]，然后flag++并设置i=-1重新进行遍历检查
  - 最后对flag的值进行判断，当大于1时返回0，否则返回1
  - 知识点：
    - str.split(" ") -- 将字符串str用空格分隔并返回包含str子串的字符串数组，同时将末尾的空格舍去；有数字参数表示分隔为几个子串
    - Integer.parseInt(str); -- 将字符串参数作为有符号的十进制整数进行解析，若参数有数字，数字表示按10,2,8,16等进制解析

- ## 代码链接
  - [非递减序列](https://github.com/anliux/PracticePool/blob/master/campus/src/007_非递减序列.java)
  - **注：此程序通过了牛客的ac，但是通不过自测的456123-0的测试用例，不知道咋回事**

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 8. 数字序列第n位的值
- ## 题目描述
  - 有一个无限长的数字序列1，2，2，3，3，3，4，4，4，4，5，5，5，5，5。。。（数字序列从1开始递增，且数字k在该序列中正好出现k次），求第n项是多少
  - 输入描述: 输入为一个整数n
  - 输出描述: 输出一个整数，即第n项的值
  - 例如：输入4，输出3；输入6，输出3
  
- ## 解题思路
  - 等差数列求和 n(n+1)/2，相当于计算和在第几项以内
  - 故可以看做以项数i递增进行循环比较，当输入值n不再大于第i项和时，说明n值就包含在第i项的数列中。
  - 注意：边界值比如6，对应的是3，while判断没有等号，只要不大于就停止增加，要不然边界值不对。

- ## 代码链接
  - [数字序列第n位的值](https://github.com/anliux/PracticePool/blob/master/campus/src/008_数字序列第n位的值.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->





#





#






#







#







### END
