# 排序算法总结
- 参考链接：[十大经典排序算法动画与解析](https://mp.weixin.qq.com/s/vn3KiV-ez79FmbZ36SX9lg)


## 对比表格
![Image text](https://raw.githubusercontent.com/anliux/PracticePool/master/base/images/comparisonTable.jpg)


## 内部排序和外部排序
- 排序算法可以分为内部排序和外部排序。
- 内部排序是数据记录在内存中进行排序。
- 外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。
- 常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。


## 复杂度 
- O(n^2) 平方阶排序 -- 各类简单排序：直接插入、直接选择和冒泡排序。
- O(nlog2n) 线性对数阶排序 -- 快速排序、堆排序和归并排序；
- O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数 -- 希尔排序
- O(n) 线性阶排序 -- 基数排序，此外还有桶、箱排序。


## 稳定性
- 稳定性是指：所有相等的数经过某种排序方法后，仍保持它们排序前的相对次序（前后次序），则是该排序方法是稳定的。
- 稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。
- 不稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。



## 目录
<!-- GFM-TOC -->
* [冒泡排序](#冒泡排序)
* [选择排序](#选择排序)
* [插入排序](#插入排序)
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
<!-- GFM-TOC -->



# 冒泡排序
- ## 思想
  - 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
  - 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
  - 针对所有的元素重复以上的步骤，除了最后一个。
  - 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

- ## 步骤
  - 以末位为基准，动态遍历（角标移动）
  - 外层循环控制每一轮，内循环控制每一轮具体的比较和交换
  - 因为每一轮比较后最后一个值作为本轮最大值划入已排序部分，故内循环条件要-i，防止越界要-1
  - 外循环只控制轮数，内循环是j和j+1在作比较并交换
  
- ## 性质
  - 时间复杂度：O(n^2): O(n^2)--O(n^2)
  - 空间复杂度：O(1)
  - 稳定
  - 内部排序
  
- ## 注意：
  - 冒泡每次遍历一趟，都会比较并且交换n多次，再一趟又比较并且交换n多次，所以总共会比较和交换很多很多次
  - 关注边界值防止角标越界
  - 内层循环的j和j+1在比
  - 可以正着比，也可以倒着比
  - 正着比：
    - 外层循环：i<arr.length-1
    - 内层循环：j<arr.length-1-i

- ## 冒泡优化
  - 避免在后面已经排好序的情况下仍然进行无意义的遍历，设置一个flag，可以提升一些性能。
  - 布尔型变量flag初始化为true，双与放在外循环的循环条件中，并在每轮外循环开始时设为false，当交换发生时设为true。
  - 因此若无交换发生，说明后面的都排序好了，这时，flag为false，直接跳出外循环。

- ## 代码链接
  - [冒泡排序](https://github.com/anliux/PracticePool/blob/master/base/src/BubbleSort.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 选择排序
- ## 思想
  - 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
  - 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
  - 重复第二步，直到所有元素均排序完毕。

- ## 步骤
  - 以未排序序列的头角标为基准，静态遍历（角标一静一动）
  - 外循环每次将当前外循环i定义为最小值下标min
  - 内循环遍历比较，如有小于当前arr[min]的下标j存在，将其下标赋值给变量min
  - 内循环完成一轮遍历后进行判断，若min不等于i，说明找到不是i对应元素的最小值，进行交换即可

- ## 性质
  - 两层循环
  - 时间复杂度：O(n^2): O(n^2)--O(n^2)
  - 空间复杂度：O(1)
  - 不稳定
  - 内部排序
  - 交换移动数据次数相当少，性能略优于冒泡

- ## 注意
  - 每次外循环进行多次比较，但只进行一次交换，找最值的过程是角标变量在比较和变化
  - 关注边界值防止角标越界
  - 内层循环的min=i（基准）和j（递增）在比
  - 外层循环：i<arr.length-1（因为内层有i+1,防止越界）
  - 内层循环：j<arr.length
  
- ## 代码链接
  - [选择排序](https://github.com/anliux/PracticePool/blob/master/sort/src/SelectSort.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 插入排序
- ## 思想
  - 将数列看作已排序和未排序两部分，然后每次取未排序序列的第一个元素，通过比较插入到已排序序列的合适位置
  - 开始：将未排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 
  - 思路1：记录待插入元素，然后角标遍历找到合适的空位，同时后移已排序序列中的元素使空出位置，最后确定角标变化时，将元素插入到空位（本代码）
  - 思路2：先确定确实需要插入，即已排序序列的最大值大于待插入元素，然后进行比较，当大时，后移一位，最后把待插入元素插入到空位（大话代码）

- ## 步骤
  - 外循环：从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）
  - 内循环：每次拿未排序序列的第一个元素作为基准与已排序序列进行从后到前的比较，当基准小时，将与基准比较的元素向后移动，这样空出来的位置可以放基准或者放下一个较大元素
  - 依次遍历直到头，然后判断基准角标i与内循环的比较元素角标j是否不同，若不同，说明基准小，将基准的值赋值给内循环中的空j的位置
  
- ## 性质
  - 两层循环
  - 时间复杂度：O(n^2): O(n)--O(n^2)
  - 空间复杂度：O(1)
  - 稳定
  - 内部排序
  - 直接插入比冒泡和简单选择排序的性能要好一些
  
- ## 注意
  - 关注边界值防止角标越界
  - 内层循环的i（基准）和j（递增）在比
  - 外层循环：i<arr.length-1（因为内层有i+1,防止越界）
  - 内层循环：j<arr.length
  
- ## 代码链接
  - [插入排序](https://github.com/anliux/PracticePool/blob/master/sort/src/InsertSort.java)

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 希尔排序
- ## 思想
  - 又称“缩小增量排序”
  - 对直接插入排序改进后可以增加效率
  - 将原本有大量记录数的记录进行分组，分割成若干个子序列，然后在这些子序列内分别进行直接插入排序，当整个序列基本有序时，再对全体记录进行一次直接插入排序
  - 基本有序：小的关键字基本在前，大的基本在后，不大不小基本在中间。
  - 采取跳跃分割的策略：将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。

- ## 步骤
  - 增量递减；每一轮遍历中的后一个元素作为基准值，类似插入排序先将基准值存储然后进行比较并在符合条件时移动值并将基准值补在空位
  - 最外层循环：
    - 选择一个增量序列 t1，t2，……，tk，其中 ti > tj（缩小增量，故tk序列是按照某种规则递减的）, tk = 1（最后递减为1）；
    - 按增量序列个数 k，对序列进行 k 趟排序；
  - 次外层循环：
    - 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。
    - 仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。
  - 最内层循环：
    - 比较并在逆序时，按照直接插入排序的规则，先赋值，后插空
  
- ## 性质
  - 三层循环
  - 时间复杂度：O(nlogn)
  - 空间复杂度：O(1)
  - 不稳定
  - 内部排序
  - 首次突破O(n^2)的时间复杂度
  
- ## 注意

- ## 代码链接
  - []()

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 归并排序


<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->

# 快速排序
- ## 步骤

- ## 性质

- ## 注意

- ## 代码链接
  - []()

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 堆排序

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 计数排序

<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 桶排序



<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



# 基数排序


<!-- GFM-TOC -->
* ## [返回顶部目录](#目录)
<!-- GFM-TOC -->



### END
